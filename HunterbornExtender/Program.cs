namespace HunterbornExtender;
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Noggog;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins.Cache;
using static HunterbornExtender.FormKeys;
using System.Linq;
using System.Text.RegularExpressions;
using Mutagen.Bethesda.Plugins.Records;
using Microsoft.CodeAnalysis;
using DynamicData;
using HunterbornExtenderUI;
using SynthEBD;
using Autofac.Core;
using System.Windows.Markup;
using static Mutagen.Bethesda.Skyrim.Furniture;
using static System.Windows.Forms.VisualStyles.VisualStyleElement.TrackBar;
using static System.Windows.Forms.AxHost;

#pragma warning disable IDE1006 // Naming Styles

sealed internal class Program
{

    /// 
    /// <summary>
    /// Stores token prototypes created for each PluginEntry.
    /// </summary>
    //static private Dictionary<PluginEntry, IMiscItemGetter> PluginTokens = new();
    //static private List<DeathItemSelection> MonsterTypes = new();
    //static private List<DeathItemSelection> AnimalTypes = new();

    record CreatureData(INpcGetter Target, ILeveledItemGetter DeathItem, String InternalName, PluginEntry Prototype, bool IsAnimal);
    static readonly Dictionary<PluginEntry, IMiscItemGetter> KnownCarcasses = new();
    static readonly Dictionary<PluginEntry, IFormLinkGetter<IItemGetter>[]> KnownPelts = new();
    static readonly HashSet<ILeveledItemGetter> KnownDeathItems = new();
    private static Lazy<Settings.Settings> _settings = null!;


    public static Task<int> Main(string[] args)
    {
        return SynthesisPipeline.Instance
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch, new PatcherPreferences()
            {
                ExclusionMods = new List<ModKey>() {
                    new ModKey("HunterbornExtenderPatch.esp", ModType.Plugin),
                },
            })
            .SetTypicalOpen(GameRelease.SkyrimSE, "HunterbornExtenderPatch.esp")
            .SetAutogeneratedSettings("settings", "settings.json", out _settings)
            .Run(args);
    }

    record JsonData(List<DeathItemSelection> DeathItems, List<PluginEntry> CreatureData);

    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        try
        {
            var p1 = JSONhandler<PluginEntry>.LoadJSONFile("HunterbornPlugin.json");
            Console.WriteLine($" o Success p1 {p1?.Name ?? "NULL"}");
        }
        catch (Exception ex)
        {
            Console.WriteLine(" x p1 failed.");
            Console.WriteLine("=================================");
            Console.WriteLine(ex);
            Console.WriteLine("=================================");
        }

        try
        {
            var ps = JSONhandler<List<PluginEntry>>.LoadJSONFile("HunterbornPlugins.json");
            Console.WriteLine($" o Success ps {ps?.Count ?? -1}");

        }
        catch (Exception ex)
        {
            Console.WriteLine(" x ps failed.");
            Console.WriteLine("=================================");
            Console.WriteLine(ex);
            Console.WriteLine("=================================");
        }

        JsonData jsonData;
        try
        {
            Console.WriteLine("Trying to load stored DeathItem selections.");
            jsonData = JSONhandler<JsonData>.LoadJSONFile("DeathItemSelectionSample.json") ?? new(new(), new());
            Console.WriteLine($"\tRead {jsonData.DeathItems.Count} selections and {jsonData.CreatureData.Count} plugins.");

            if (jsonData.DeathItems.Count > 0 || jsonData.CreatureData.Count > 0)
                Console.WriteLine($" ✓ Success: {jsonData.DeathItems.Count} selections and {jsonData.CreatureData.Count} plugins loaded.");

            else throw new InvalidOperationException("No data.");
        }
        catch (Exception ex)
        {
            Console.WriteLine(" x Failed to load stored DeathItem selections.");
            Console.WriteLine("=================================");
            Console.WriteLine(ex);
            Console.WriteLine("=================================");
            return;
        }

        StandardRecords std;

        try
        {
            Console.WriteLine("Trying to resolve required forms from Hunterborn.esp, and preparing the patch structure.");
            std = CreateStandardRecords(state);
            Console.WriteLine($" ✓ Success: {std.PatchMod}");
        }
        catch (Exception ex)
        {
            Console.WriteLine(" x Failed to resolve required forms.");
            Console.WriteLine("=================================");
            Console.WriteLine(ex);
            return;
        }

        Plugin corePlugin;
        
        try
        {
            Console.WriteLine("Trying to recreate the hard-coded core plugin from Hunterborn.esp.");
            corePlugin = RecreateCorePlugin(std);
            Console.WriteLine($" ✓ Success: {corePlugin.Entries.Count} plugin entries found.");
        }
        catch (Exception ex)
        {
            Console.WriteLine(" x Failed to recreate core plugin..");
            Console.WriteLine("=================================");
            Console.WriteLine(ex);
            Console.WriteLine("=================================");
            return;
        }

        List<PluginEntry> plugins = new(jsonData.CreatureData);

        var PICKS = MakeBootstrapSelection(plugins, state);
        return;

        foreach (var dis in PICKS.Keys)
        {
            Console.WriteLine($"=== {dis.CreatureEntryName} ===");

            PluginEntry? prototype = PICKS[dis];

            // null is used to indicate "SKIP".
            if (prototype == null)
            {
                Console.WriteLine($"\tSkipped {dis.CreatureEntryName}: User selection is SKIP.");
                continue;
            }

            // Why does the original patcher scan ALL the npcs??
            //p.Key.AssignedNPCs.ForEach(npc =>
            //dis.AssignedNPCs.Take(1).ForEach(npc =>
            if (dis.AssignedNPCs.Count == 0)
            {
                Console.WriteLine($"\tSkipped {dis.CreatureEntryName}: No creatures found.");
                continue;
            }

            try
            {
                Console.WriteLine($"\tCreating CreatureData structure for {dis.CreatureEntryName}.");
                var data = CreateCreatureData(dis.AssignedNPCs.First(), prototype, std);
                if (BlacklistedDeathItems.Contains(data.DeathItem.ToLink()))
                {
                    Console.WriteLine($"\tSkipped {dis.CreatureEntryName}: DeathItem blacklisted.");
                }
                else if (KnownDeathItems.Contains(data.DeathItem))
                {
                    Console.WriteLine($"\tSkipped {dis.CreatureEntryName}: DeathItem already processed.");
                } 
                else
                {
                    AddRecord(data, std);
                    KnownDeathItems.Add(data.DeathItem);
                }
            }
            catch (DeathItemAlreadyAddedException)
            {
                Console.WriteLine($"\tSkipped {dis.CreatureEntryName}: DeathItem already processed.");
            }
            catch (NoDeathItemException)
            {
                Console.WriteLine($"\tSkipped {dis.CreatureEntryName}: No DeathItem.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"\tSkipped {dis.CreatureEntryName}: {ex.Message}");
            }
        }
    }
    static Dictionary<DeathItemSelection, PluginEntry> MakeBootstrapSelection(List<PluginEntry> plugins, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        Dictionary<DeathItemSelection, Dictionary<PluginEntry, int>> PICKS_COLLECTION = new();
        Dictionary<ILeveledItemGetter, DeathItemSelection> KNOWN = new();

        foreach (var npcGetter in state.LoadOrder.PriorityOrder.Npc().WinningOverrides())
        {
            var edid = npcGetter.EditorID;
            if (edid == null) continue;

            var name = npcGetter.Name?.ToString() ?? edid;

            var deathItem = npcGetter.DeathItem?.TryResolve(state.LinkCache);
            if (deathItem == null) continue;

            if (!KNOWN.ContainsKey(deathItem))
                KNOWN[deathItem] = new DeathItemSelection() { DeathItemList = deathItem.FormKey, CreatureEntryName = name };

            var sel = KNOWN[deathItem];
            sel.AssignedNPCs.Add(npcGetter);

            plugins.Where(p => edid.ContainsInsensitive(p.Name)).ForEach(p => {
                if (!PICKS_COLLECTION.ContainsKey(sel)) PICKS_COLLECTION[sel] = new();
                if (!PICKS_COLLECTION[sel].ContainsKey(p)) PICKS_COLLECTION[sel][p] = 0;
                PICKS_COLLECTION[sel][p] += 1;
            });
        }

        int i = 0;

        Dictionary<DeathItemSelection, PluginEntry> PICKS = new();
        foreach (var entry in PICKS_COLLECTION)
        {
            Dictionary<PluginEntry, int> weights = PICKS_COLLECTION[entry.Key];
            List<PluginEntry> options = new(weights.Keys);
            if (options.Count == 0) continue;

            options.Sort((a, b) => weights[b].CompareTo(weights[a]));
            PICKS[entry.Key] = options.First();

            if (i < 4 && weights.Count > 1 && weights.Values.Any(c => c > 1))
            {
                Console.WriteLine(options.ToString());
                Console.WriteLine(weights.ToString());
                i++;
            }
        }

        return PICKS;
    }

    static Plugin RecreateCorePlugin(StandardRecords std)
    {
        Plugin core = new();

        foreach (var type in new List<EntryType>() { EntryType.Animal, EntryType.Monster })
        {
            int count = std.GetCCFor(type).RaceIndex.Data.Count;
            Console.WriteLine($"\tRecreating {count} {type} plugin entries.");

            if (_settings.Value.DebuggingMode)
            {
                if (type == EntryType.Animal) Console.WriteLine($"\tChecks: names={std.GetCCFor(type)._DS_FL_DeathItems.Items.Count}, pelts={std.GetCCFor(type)._DS_FL_PeltLists.Items.Count}, carcasses={std.Animals._DS_FL_CarcassObjects.Items.Count}");
                else Console.WriteLine($"\tChecks: names={std.GetCCFor(type)._DS_FL_DeathItems.Items.Count}, pelts={std.GetCCFor(type)._DS_FL_PeltLists.Items.Count}");
            }

            for (int index = 0; index < count; index++)
            {
                PluginEntry entry = RecreateCorePluginEntry(type, index, std);
                core.Entries.Add(entry);
            }
        }

        return core;
    }

    static PluginEntry RecreateCorePluginEntry(EntryType type, int index, StandardRecords std)
    {
        PluginEntry entry = new();

        entry.Type = type;
        entry.Name = std.GetCCFor(type).RaceIndex.Data[index];
        entry.SortName = SortingNames.GetValueOrDefault(entry.Name, entry.Name);
        entry.AnimalSwitch = std.GetCCFor(type).Switches.Objects[index].Object.FormKey;
        entry.CarcassMessageBox = std.GetCCFor(type).CarcassMessages.Objects[index].Object.FormKey;
        entry.CarcassSize = std.GetCCFor(type).CarcassSizes.Data[index];

        if (type == EntryType.Animal)
        {
            entry.CarcassWeight = (int)std.Animals._DS_FL_CarcassObjects.Items[index].Resolve<IMiscItemGetter>(std.LinkCache).Weight;
            entry.CarcassValue = (int)std.Animals._DS_FL_CarcassObjects.Items[index].Resolve<IMiscItemGetter>(std.LinkCache).Value;
        }
        else
        {
            entry.CarcassWeight = 0;
            entry.CarcassValue = 0;
        }

        entry.Meat = std.GetCCFor(entry.Type).MeatType.Objects[index].Object.FormKey;
        entry.SharedDeathItems = std.GetCCFor(entry.Type).SharedDeathItems.Objects[index].Object.FormKey;

        if (type == EntryType.Monster)
        {
            entry.BloodType = std.Monsters.BloodItems.Objects[index].Object.FormKey;
            entry.Venom = std.Monsters.VenomItems.Objects[index].Object.FormKey;

            IFormListGetter discard = std.Monsters.NegativeTreasure.Objects[index].Object.Resolve<IFormListGetter>(std.LinkCache);
            entry.NegativeTreasure = new(discard.Items.Select(item => item.FormKey));
        }
        else
        {
            entry.NegativeTreasure = new();
            entry.BloodType = new FormKey();
            entry.Venom = new FormKey();
        }

        /*
         * @TODO Finish recreating these from recipes.
        entry.Pelts;
        entry.Mats;
        entry.PeltCount;
        entry.FurPlateCount;
        */

        // @TODO What to do with the Voice field?
        // entry.Voice;

        if (std.GetCCFor(entry.Type)._DS_FL_DeathItems.Items[index].Resolve(std.LinkCache) is not ILeveledItemGetter deathItem)
            throw new CoreRecordMissing(std.GetCCFor(entry.Type)._DS_FL_DeathItems.Items[index]);
        KnownDeathItems.Add(deathItem);

        if (std.GetCCFor(entry.Type)._DS_FL_PeltLists.Items[index].Resolve(std.LinkCache) is not IFormListGetter pelts)
            throw new CoreRecordMissing(std.GetCCFor(entry.Type)._DS_FL_PeltLists.Items[index]);

        if (type == EntryType.Animal)
        {
            if (std.Animals._DS_FL_CarcassObjects.Items[index].Resolve(std.LinkCache) is not IMiscItemGetter carcass)
                throw new CoreRecordMissing(std.Animals._DS_FL_CarcassObjects.Items[index]);
            KnownCarcasses.Add(entry, carcass);
        }

        IFormLinkGetter<IItemGetter>[] peltsArray = pelts.Items.OfType<IFormLinkGetter<IItemGetter>>().ToArray();
        if (peltsArray.Length != 0 && peltsArray.Length != 4)
            throw new InvalidOperationException($"Wrong length for pelts: {entry.Name} -- {std.GetCCFor(entry.Type)._DS_FL_PeltLists.Items[index]}");
        KnownPelts.Add(entry, peltsArray);

        return entry;
    }


    /// <summary>
    /// Things that have to be done for each race:
    /// 
    /// 
    /// ==NEW RECORDS==
    /// Create a token MiscItem that identifies the creature as being Hunterborn-enabled.
    /// Create a carcass MiscItem that can go in the player's inventory.
    /// 
    /// Create a materials FormList containing 4 leveled lists of stuff, for the four levels of harvesting skill.
    /// 
    /// Create either 3 or 4 pelt MiscItems (3 if there's a default one the creature already).
    /// Create Leather and Fur Plate recipes for the pelts.
    /// 
    /// Add the creature's DeathItem to the DeathItems formlist.
    /// 
    /// Creature a new CustomDeathItem that contains tokens for the actions supported by the creature.
    /// 
    /// 
    /// ==HUNTERBORN QUEST SCRIPT==
    /// Add the carcass size to its array property.
    /// Add the carcass custom message (if any) to its array property.
    /// Add the CustomDeathItem to its array property.
    /// Add the meat type (if any) to its array property.
    /// Add the meat weight (if any) to its array property.
    /// Add the default pelt value (if any) to its array property.
    /// Add the shared death item (if any) to its array property.
    /// Add the proper name to its array property.
    /// 
    /// For monsters:
    /// Add the venom (if any) to its array property.
    /// Add the blood (if any) to its array property.
    /// Add the "negative treasure" (if any) to its array property.
    /// 
    /// </summary>
    /// 
    static void AddRecord(CreatureData data, StandardRecords std)
    {
        var token = CreateToken(data, std);
        var carcass = CreateCarcass(data, std);
        var mats = CreateMaterials(data, std);
        var pelts = CreatePelts(data, std);
        var deathDescriptor = CreateDeathDescriptor(data, std, pelts, mats);

        if (_settings.Value.DebuggingMode)
        {
            Console.WriteLine($"\tCreated new forms");
            Console.WriteLine($"\t\tID Token: {token}");
            Console.WriteLine($"\t\tCarcass item: {carcass}");
            Console.WriteLine($"\t\tMaterials: {mats}");
            Console.WriteLine($"\t\tPelts: {pelts}");
            Console.WriteLine($"\t\tDescriptor: {deathDescriptor}");
        }
    }

    static CreatureData CreateCreatureData(INpcGetter npc, PluginEntry prototype, StandardRecords std)
    {
        npc.DeathItem.TryResolve(std.LinkCache, out var deathItem);
        if (deathItem == null) throw new NoDeathItemException(npc.FormKey);
        //if (MiscItems.Contains(deathItem)) throw new DeathItemAlreadyAddedException(deathItem.FormKey);
        CreatureData data = new(npc, deathItem, CreateInternalName(deathItem), prototype, prototype.Type == EntryType.Animal);
        return data;
    }

    /// <summary>
    /// Creates a unique internal name for the specified DeathItem. 
    /// This is used to derive the editorIds for the new forms that will be created 
    /// for the specified DeathItem.
    /// </summary>
    /// <param name="deathItem">The DeathItem to create a reasonably unique name for.</param>
    /// <returns>A reasonably unique name.</returns>
    /// 
    static String CreateInternalName(ILeveledItemGetter deathItem)
    {
        String internalName = $"{deathItem.FormKey}{deathItem.EditorID ?? ""}";
        return NAME_FILTER.Replace(internalName, "");
    }
    readonly static private Regex NAME_FILTER = new("[^a-zA-Z0-9_]", RegexOptions.IgnoreCase);

    /// <summary>
    /// Creates the Misc deathtoken for a creature.
    /// 
    /// The new deathtoken is appended to the deathtoken formlist for animals or monsters.
    /// 
    /// The deathtoken will be derived from the prototype's token (if it exists) or derived from the COW's deathtoken.
    /// 
    /// Naming is done heuristically. 
    /// </summary>
    /// 
    static private MiscItem CreateToken(CreatureData data, StandardRecords std)
    {
        // Get a pre-existing token that already has the keywords and model set.
        // That way all that needs to be done is to change the name and editor ID.
        var existingTokenLink = data.IsAnimal ? DEFAULT_TOKEN_ANIMAL : DEFAULT_TOKEN_MONSTER;
        existingTokenLink.TryResolve(std.LinkCache, out var existingToken);
        if (existingToken == null) throw new CoreRecordMissing(existingTokenLink);

        // Add the token to the patch.
        var token = std.PatchMod.MiscItems.AddNew();
        if (token == null) throw new InvalidOperationException();
        token.DeepCopyIn(existingToken);

        // Set the EditorID.
        token.EditorID = $"_DS_DI{data.InternalName}";
        token.Name = $"{data.InternalName} Token";

        // Put the token in the correct formlist.
        std.GetCCFor(data)._DS_FL_DeathItemTokens.Items.Add(token);

        return token;
    }

    static MiscItem CreateCarcass(CreatureData data, StandardRecords std)
    {
        // Get a pre-existing carcass that already has the keywords set.
        DEFAULT_CARCASS.TryResolve(std.LinkCache, out var existingCarcass);
        if (existingCarcass == null) throw new CoreRecordMissing(DEFAULT_CARCASS);

        // Add the carcass to the patch.
        var carcass = std.PatchMod.MiscItems.AddNew();
        if (carcass == null) throw new InvalidOperationException();
        carcass.DeepCopyIn(existingCarcass);

        var oldName = carcass.Name?.String;
        if (oldName.IsNullOrEmpty()) oldName = "Cow Carcass";

        carcass.EditorID = $"_DS_Carcass{data.InternalName}";
        carcass.Name = oldName.Replace("Cow", $"{data.Prototype.ProperName}");

        carcass.Value = (uint)data.Prototype.CarcassValue;
        carcass.Weight = data.Prototype.CarcassWeight;

        carcass.Model = KnownCarcasses.ContainsKey(data.Prototype)
            ? KnownCarcasses[data.Prototype].Model?.DeepCopy() ?? CreateDefaultCarcassModel()
            : CreateDefaultCarcassModel();

        // Put the carcass in the correct formlist.
        if (data.IsAnimal) std.Animals._DS_FL_CarcassObjects.Items.Add(carcass);

        return carcass;
    }

    static Model CreateDefaultCarcassModel()
    {
        return new Model { File = "Clutter\\Containers\\MiscSackLarge.nif", AlternateTextures = null };
    }

    static FormList CreateMaterials(CreatureData data, StandardRecords std)
    {
        //DEFAULT_MATS.TryResolve(state.LinkCache, out var existingMaterials);
        //if (existingMaterials == null) throw new CoreRecordMissing(DEFAULT_MATS.FormKey);

        var mats = std.PatchMod.FormLists.AddNew();
        if (mats == null) throw new InvalidOperationException();
        //mats.DeepCopyIn(existingMaterials);
        //mats.Items.RemoveAll();
        mats.EditorID = $"_DS_FL_Mats_{data.InternalName}";


        for (int index = 0; index < data.Prototype.Mats.Count; index++)
        {
            var template = data.Prototype.Mats[index];
            var mat = std.PatchMod.LeveledItems.AddNew();
            if (mat == null) throw new InvalidOperationException();

            mat.EditorID = $"{mats.EditorID}{index:D2}";
            var entries = mat.Entries = new();

            foreach (var te in template) {
                entries.Add(CreateLeveledItemEntry(te.Key.ToLink<IItemGetter>() ?? throw new AddonRecordMissing(te.Key), 1, te.Value));
            }

            mats.Items.Add(mat);
        }

        // Put the materials formlist in the correct formlist.
        std.GetCCFor(data)._DS_FL_Mats__Lists.Items.Add(mats);

        return mats;
    }

    static FormList CreatePelts(CreatureData data, StandardRecords std)
    {
        var pelts = std.PatchMod.FormLists.AddNew();
        if (pelts == null) throw new InvalidOperationException();
        pelts.EditorID = $"_DS_FL_Pelts_{data.InternalName}";

        if (!KnownPelts.ContainsKey(data.Prototype))
        {
            IItemGetter standard = GetDefaultPelt(data, std);
            var poor = std.PatchMod.MiscItems.AddNew();
            var fine = std.PatchMod.MiscItems.AddNew();
            var flawless = std.PatchMod.MiscItems.AddNew();

            poor.DeepCopyIn(standard);
            fine.DeepCopyIn(standard);
            flawless.DeepCopyIn(standard);

            String edid = $"_DS_Pelt_{standard.EditorID ?? data.InternalName}";
            poor.EditorID = $"{edid}_00";
            fine.EditorID = $"{edid}_02";
            flawless.EditorID = $"{edid}_03";

            // Store the pelt value to the Hunterborn quest script.
            std.GetCCFor(data).PeltValues.Data.Add((int) poor.Value);

            // Adjust the values of the non-standard pelts.
            poor.Value /= 2;
            fine.Value *= 2;
            flawless.Value *= 20;
            KnownPelts[data.Prototype] = new IFormLinkGetter<IItemGetter>[4] { poor.ToLink(), standard.ToLink(), fine.ToLink(), flawless.ToLink() };
            //KnownPelts[data.Prototype] = pelts;
        }

        // Add the pelts to the pelts formlist.
        pelts.Items.AddRange(KnownPelts[data.Prototype]);

        // Put the pelts formlist in the correct formlist.
        std.GetCCFor(data)._DS_FL_PeltLists.Items.Add(pelts);
        return pelts;
    }

    static readonly Regex DefaultPeltRegex = new("Pelt|Hide|Skin|Fur|Wool|Leather", RegexOptions.IgnoreCase);

    /// <summary>
    /// Checks the creature's DeathItem for anything whose name or editorID contains a string-match
    /// that indicates it's probably a pelt. Returns the pelt.
    /// 
    /// If no default pelt was found, one will be created and added to the patch.
    /// 
    /// </summary>
    /// 
    static IItemGetter GetDefaultPelt(CreatureData data, StandardRecords std)
    {
        IReadOnlyList<ILeveledItemEntryGetter>? entries = data.DeathItem.Entries;
        if (entries == null) return CreateDefaultPelt(data, std);

        foreach (var entry in entries)
        {
            var item = entry.Data?.Reference.TryResolve(std.LinkCache);
            var edid = item?.EditorID ?? "";
            if (item == null || edid == null) continue;
            if (DefaultPeltRegex.Matches(edid).Any()) return item;
        }

        return CreateDefaultPelt(data, std);
    }

    /// <summary>
    /// Create a new default pelt for a creature using a pre-existing pelt as a template.
    /// 
    /// </summary>
    /// <param name="data"></param>
    /// <param name="std"></param>
    /// <returns></returns>
    /// <exception cref="CoreRecordMissing"></exception>
    /// <exception cref="InvalidOperationException"></exception>
    static IItemGetter CreateDefaultPelt(CreatureData data, StandardRecords std)
    {
        DEFAULT_PELT.TryResolve(std.LinkCache, out var existingPelt);
        if (existingPelt == null) throw new CoreRecordMissing(DEFAULT_PELT);

        var pelt = std.PatchMod.MiscItems.AddNew();
        if (pelt == null) throw new InvalidOperationException();
        pelt.DeepCopyIn(DEFAULT_PELT.Resolve(std.LinkCache));

        pelt.EditorID = $"_DS_Pelt_{data.InternalName}_01";
        pelt.Name = $"{data.Prototype.ProperName} Pelt";

        // @TODO Fill this in with something better.
        pelt.Value = (uint)data.Prototype.CarcassValue / 2;
        return pelt;
    }

    /// <summary>
    /// Create a new DeathDescriptor for a creature.
    /// This is a LeveledItem that gets added to a carcass's inventory when the
    /// player interacts with the carcass for the first time.
    /// 
    /// The Tokens it adds are what determine which actions the player can take.
    /// 
    /// </summary>
    /// 
    static ILeveledItemGetter CreateDeathDescriptor(CreatureData data, StandardRecords std, FormList pelts, FormList mats)
    {
        // Create the new descriptor.
        LeveledItem deathDescriptor = std.PatchMod.LeveledItems.AddNew();
        deathDescriptor.EditorID = $"_DS_DeathItem_{data.InternalName}";
        deathDescriptor.Entries = new();

        // If the pelts FormList isn't empty, then harvesting pelts is enabled.
        if (pelts.Items != null && pelts.Items.Count > 0)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Pelt, 1, 1));

        // If the materials FormList isn't empty, then harvesting materials is enabled.
        if (mats.Items != null && mats.Items.Count > 0)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Mat, 1, 1));

        // Animals need to be cleaned. Monsters apparently not?
        if (data.IsAnimal)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Carcass_Clean, 1, 1));

        // If the Meat field in the PluginEntry isn't null then harvesting meat is enabled.
        if (!data.Prototype.Meat.IsNull)
        {
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Meat, 1, 1));
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Meat_Fresh, 1, 1));
        }

        // If the Venom or Blood fields in the PluginEntry aren't null then harvesting venom and/or blood is enabled.
        if (data.Prototype.Type == EntryType.Monster)
        {
            if (!data.Prototype.Venom.IsNull)
                deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Venom, 1, 1));
            if (!data.Prototype.BloodType.IsNull)
                deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Venom, 1, 1));
        }

        // Add the creature's actual DeathItem to the appropriate FormList.
        // When hunterborn starts up, the creature's Token will be added to this formlist.
        // THIS IS HOW HUNTERBORN RECOGNIZES HARVESTABLE CREATURES.
        std.GetCCFor(data)._DS_FL_DeathItems.Items.Add(data.DeathItem);

        // Add the DeathDescriptor to the quest array property.
        std.GetCCFor(data).DeathDescriptors.Objects.Add(new() { Object = deathDescriptor.ToLink() });

        return deathDescriptor;
    }

    readonly static private List<FormLink<IFactionGetter>> ForbiddenFactions = new(new FormLink<IFactionGetter>[] {
        Dawnguard.Faction.DLC1VampireFaction,
        Dragonborn.Faction.DLC2AshSpawnFaction,
        Skyrim.Faction.DragonPriestFaction,
        Skyrim.Faction.DraugrFaction,
        Skyrim.Faction.DwarvenAutomatonFaction,
        Skyrim.Faction.IceWraithFaction,
        Dawnguard.Faction.SoulCairnFaction,
        Skyrim.Faction.VampireFaction,
        Skyrim.Faction.WispFaction
    });

    readonly static private List<FormLink<IVoiceTypeGetter>> AllowedVoice = new(new FormLink<IVoiceTypeGetter>[]{
        Skyrim.VoiceType.CrBearVoice,
        Skyrim.VoiceType.CrChickenVoice,
        Skyrim.VoiceType.CrCowVoice,
        Skyrim.VoiceType.CrDeerVoice,
        Skyrim.VoiceType.CrDogVoice,
        Dawnguard.VoiceType.CrDogHusky,
        Skyrim.VoiceType.CrFoxVoice,
        Skyrim.VoiceType.CrGoatVoice,
        Skyrim.VoiceType.CrHareVoice,
        Skyrim.VoiceType.CrHorkerVoice,
        Skyrim.VoiceType.CrHorseVoice,
        Skyrim.VoiceType.CrMammothVoice,
        Skyrim.VoiceType.CrMudcrabVoice,
        Skyrim.VoiceType.CrSabreCatVoice,
        Skyrim.VoiceType.CrSkeeverVoice,
        Skyrim.VoiceType.CrSlaughterfishVoice,
        Skyrim.VoiceType.CrWolfVoice,
        Dragonborn.VoiceType.DLC2CrBristlebackVoice,
        Skyrim.VoiceType.CrChaurusVoice,
        Skyrim.VoiceType.CrFrostbiteSpiderVoice,
        Skyrim.VoiceType.CrFrostbiteSpiderGiantVoice,
        Skyrim.VoiceType.CrSprigganVoice,
        Skyrim.VoiceType.CrTrollVoice,
        Skyrim.VoiceType.CrWerewolfVoice,
        Skyrim.VoiceType.CrDragonVoice,
        Dawnguard.VoiceType.CrChaurusInsectVoice
    });

    static readonly private List<String> BlacklistedRecords = new() { "HISLCBlackWolf", "BSKEncRat" };

    static readonly private Dictionary<string, string> SortingNames = new() {
        { "BearCave", "Bear, Cave" },
        { "BearSnow", "Bear, Snow" },
        { "CharusHunter", "Chaurus, Hunter" },
        { "ElkFemale", "Elk, Female" },
        { "ElkMale", "Elk, Male" },
        { "FoxIce", "Fox, Snow" },
        { "MudCrab01", "MudCrab, Small" },
        { "MudCrab02", "MudCrab, Large" },
        { "MudCrab03", "MudCrab, Giant" },
        { "SabrecatSnow", "Sabrecat, Snow" },
        { "FrostbiteSpider", "Spider, Frostbite" },
        { "FrostbiteSpiderGiant", "Spider, Giant Frostbite" },
        { "SprigganBurnt", "Spriggan, Burnt" },
        { "DeerVale", "Deer, Vale" },
        { "SabrecatVale", "Sabrecat, Vale" },
        { "WolfIce", "Wolf, Ice" },
        { "TrollFrost", "Troll, Frost" }
    };

    private static readonly List<FormLink<ILeveledItemGetter>> BlacklistedDeathItems = new(new FormLink<ILeveledItemGetter>[] {
        Skyrim.LeveledItem.DeathItemDragonBonesOnly,
        Skyrim.LeveledItem.DeathItemVampire,
        Skyrim.LeveledItem.DeathItemForsworn,
        Dawnguard.LeveledItem.DLC1DeathItemDragon06,
        Dawnguard.LeveledItem.DLC1DeathItemDragon07,
        new(new FormKey(new("Skyrim Immersive Creatures Special Edition", type : ModType.Plugin), 0x11B217))
    });

    /*
    static private Dictionary<string, string> VanillaToCaco = new Dictionary<string, string>() {
        { "_DS_Food_Raw_Bear", "CACO_FoodMeatBear" },
            { "_DS_Food_Raw_Chaurus", "CACO_FoodMeatChaurusMeat" },
            { "_DS_Food_Raw_Dragon", "_DS_Food_Raw_Dragon" },
            { "_DS_Food_Raw_Elk", "FoodMeatVenison" },
            { "_DS_Food_Raw_Fox", "CACO_FoodMeatFox" },
            { "_DS_Food_Raw_Goat", "CACO_FoodMeatGoatPortionRaw" },
            { "_DS_Food_Raw_Hare", "_DS_Food_Raw_Hare" },
            { "_DS_Food_Raw_Mammoth", "CACO_FoodMeatMammoth" },
            { "_DS_Food_Raw_Mudcrab", "_DS_Food_Raw_Mudcrab" },
            { "_DS_Food_Raw_Sabrecat", "CACO_FoodMeatSabre" },
            { "_DS_Food_Raw_Skeever", "CACO_FoodMeatSkeeverRaw" },
            { "_DS_Food_Raw_Slaughterfish", "CACO_FoodSeaSlaughterfishRaw" },
            { "_DS_Food_Raw_Spider", "_DS_Food_Raw_Spider" },
            { "_DS_Food_Raw_Troll", "CACO_FoodMeatTroll" },
            { "_DS_Food_Raw_Wolf", "FoodDogMeat" },
            { "FoodBeef", "FoodBeef" },
            { "FoodChicken", "FoodChicken" },
            { "FoodClamMeat", "FoodClamMeat" },
            { "FoodDogMeat", "FoodDogMeat" },
            { "FoodGoatMeat", "FoodGoatMeat" },
            { "FoodHorkerMeat", "FoodHorkerMeat" },
            { "FoodHorseMeat", "FoodHorseMeat" },
            { "FoodMammothMeat", "FoodMammothMeat" },
            { "FoodPheasant", "FoodPheasant" },
            { "FoodRabbit", "FoodRabbit" },
            { "FoodSalmon", "FoodSalmon" },
            { "FoodVenison", "FoodVenison" },
            { "DLC2FoodAshHopperMeat", "DLC2FoodAshHopperMeat" },
            { "DLC2FoodAshHopperLeg", "DLC2FoodAshHopperLeg" },
            { "DLC2FoodBoarMeat", "DLC2FoodBoarMeat" },
            { "HumanFlesh", "CACO_FoodMeatHumanoidFlesh" }
    };
    */
    
    /*
    static private bool HasFaction(INpcGetter creature, List<FormLink<IFactionGetter>> factions, StandardRecords std) {
        return !creature.Factions
            .Select(rank => rank.Faction.Resolve<IFactionGetter>(std.LinkCache))
            .Where(faction => faction != null && factions.Contains(faction.ToLink()))
            .Any();
    }

    static private bool HasVoice(INpcGetter creature, List<FormLink<IVoiceTypeGetter>> voices)
    {
        var creatureVoice = creature.Voice;
        return voices.Any(v => v.Equals(creatureVoice));
    }

    static private bool IsCreature(INpcGetter actor, StandardRecords std) {
        var deathItem = actor.DeathItem.Resolve(std.LinkCache);
        var edid = actor.EditorID;
        var edidLink = edid != null ? new EDIDLink<IRaceGetter>(edid) : null;

        return !HasFaction(actor, ForbiddenFactions, std)
            && HasVoice(actor, AllowedVoice)
            && deathItem != null
            && !std.CreatureClasses.Any(cls => cls.KnownDeathItems.Contains(deathItem))
            && (edid == null || !BlacklistedRecords.Contains(edid))
            && !BlacklistedDeathItems.Any(item => item.Equals(deathItem));
    }
    */

    /// <summary>
    /// Copies the contents of the pre-existing deathitems formlists into Lists.
    /// </summary>
    /// <param name="cache"></param>
    static private IEnumerable<ILeveledItemGetter> GetKnownDeathItemsAnimals(ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        return _DS_FL_DeathItems.Resolve(linkCache).Items
            .OfType<IFormLinkGetter<ILeveledItemGetter>>()
            .Select(r => r.TryResolve(linkCache))
            .Where(r => r != null)
            .Select(r => r!);
    }
    static private IEnumerable<ILeveledItemGetter> GetKnownDeathItemsMonsters(ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        return _DS_FL_DeathItems_Monsters.Resolve(linkCache).Items
            .OfType<IFormLinkGetter<ILeveledItemGetter>>()
            .Select(r => r.TryResolve(linkCache))
            .Where(r => r != null)
            .Select(r => r!);
    }

    /// <summary>
    /// The quest and formlists needed by the patching methods, already resolved.
    /// </summary>
    readonly record struct StandardRecords(
        Quest _DS_Hunterborn,
        ILinkCache<ISkyrimMod, ISkyrimModGetter> LinkCache,
        ISkyrimMod PatchMod,
        AnimalClass Animals,
        MonsterClass Monsters,
        List<CreatureClass> CreatureClasses)
    {
        public CreatureClass GetCCFor(EntryType t)
        {
            return t switch
            {
                EntryType.Animal => Animals,
                EntryType.Monster => Monsters,
                _ => throw new InvalidOperationException("Unknown CreatureClass requested."),
            };
        }

        public CreatureClass GetCCFor(CreatureData d) 
        {
            return GetCCFor(d.Prototype.Type);
        }

    }

    record CreatureClass(
        //List<ILeveledItemGetter> KnownDeathItems,
        FormList _DS_FL_Mats__Lists,
        FormList _DS_FL_Mats__Perfect,
        FormList _DS_FL_PeltLists,
        FormList _DS_FL_DeathItems,
        FormList _DS_FL_DeathItemTokens,
        ScriptObjectListProperty CarcassMessages,
        ScriptObjectListProperty Switches,
        ScriptObjectListProperty DeathDescriptors,
        ScriptObjectListProperty MeatType,
        ScriptObjectListProperty SharedDeathItems,
        ScriptStringListProperty RaceIndex,
        ScriptFloatListProperty MeatWeights,
        ScriptIntListProperty PeltValues,
        ScriptIntListProperty CarcassSizes
        );

    record AnimalClass(
        CreatureClass proto,
        FormList _DS_FL_CarcassObjects) : CreatureClass(proto);

    record MonsterClass(
        CreatureClass proto, 
        ScriptObjectListProperty BloodItems, 
        ScriptObjectListProperty VenomItems, 
        ScriptObjectListProperty NegativeTreasure) : CreatureClass(proto);


    /// <summary>
    /// Some of the methods in this class require the resolved Hunterborn Quest and resolved FormLists.
    /// This resolves them, adds them to the patch, and packs them into a Record.
    /// </summary>
    static StandardRecords CreateStandardRecords(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        Quest hunterbornQuest = state.PatchMod.Quests.GetOrAddAsOverride(_DS_Hunterborn.Resolve(state.LinkCache));
        if (_settings.Value.DebuggingMode) QueryImportantProperties(hunterbornQuest);

        var animals = new AnimalClass(new(
                    //new(GetKnownDeathItemsAnimals(state.LinkCache)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Lists.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Lists)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Perfect.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Perfect)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_PeltLists.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_PeltLists)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItems.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItems)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItemTokens.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItemTokens)),

                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_MAIN", "FreshCarcassMsgBoxes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "ActiveAnimalSwitches"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "DeathItemLI"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "MeatTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "SharedDeathItems"),
                    GetProperty<ScriptStringListProperty>(hunterbornQuest, "_DS_HB_Animals", "AnimalIndex"),
                    GetProperty<ScriptFloatListProperty>(hunterbornQuest, "_DS_HB_Animals", "AllMeatWeights"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Animals", "DefaultPeltValues"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Animals", "CarcassSizes")),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_CarcassObjects.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_CarcassObjects)));

        var monsters = new MonsterClass(new(
                    //new(GetKnownDeathItemsMonsters(state.LinkCache)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Lists_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Lists_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Perfect_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Perfect_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_PeltLists_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_PeltLists_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItems_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItems_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItemTokens_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItemTokens_Monsters)),

                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_MAIN", "FreshCarcassMsgBoxes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "ActiveMonsterSwitches"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "DeathItemLI"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "MeatTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "SharedDeathItems"),
                    GetProperty<ScriptStringListProperty>(hunterbornQuest, "_DS_HB_Monsters", "MonsterIndex"),
                    GetProperty<ScriptFloatListProperty>(hunterbornQuest, "_DS_HB_Animals", "AllMeatWeights"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Monsters", "DefaultPeltValues"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Monsters", "CarcassSizes")),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "BloodTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "VenomTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "NegativeTreasure"));


        StandardRecords std = new(
                hunterbornQuest,
                state.LinkCache,
                state.PatchMod,
                animals,
                monsters,
                new() { animals, monsters }
                );

        return std;
    }
    
    static void QueryImportantProperties(Quest hunterbornQuest)
    {
        hunterbornQuest.VirtualMachineAdapter?.Scripts.ForEach(script => {
            script.Properties
                .Where(p => p is ScriptObjectListProperty)
                .Select(p => (p as ScriptObjectListProperty)!)
                .Where(p => p.Objects.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant object array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptBoolListProperty)
                .Select(p => (p as ScriptBoolListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant bool array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptIntListProperty)
                .Select(p => (p as ScriptIntListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant int array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptFloatListProperty)
                .Select(p => (p as ScriptFloatListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant float array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptStringListProperty)
                .Select(p => (p as ScriptStringListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant string array property: {script.Name}.{p.Name}"));
        });
    }

    static ScriptTProperty GetProperty<ScriptTProperty>(Quest quest, String scriptName, String propertyName) where ScriptTProperty : ScriptProperty
    {
        String questName = quest.Name?.ToString() ?? quest.EditorID ?? "Quest";

        var scriptFilter = ScriptFilter(scriptName);
        var propertyFilter = PropertyFilter(propertyName);

        var script = quest.VirtualMachineAdapter?.Scripts.Where(scriptFilter).FirstOrDefault();
        if (script == null) throw new ScriptMissing(questName, scriptName);

        if (script.Properties.Where(propertyFilter).FirstOrDefault() is not ScriptTProperty property) 
            throw new PropertyMissing(questName, scriptName, propertyName);

        return property;
    }

    static Func<ScriptEntry, bool> ScriptFilter(String name)
    {
        return (ScriptEntry s) => EqualsIgnoreCase(name, s?.Name);
    }

    static Func<ScriptProperty, bool> PropertyFilter(String name)
    {
        return (ScriptProperty s) => EqualsIgnoreCase(name, s?.Name);
    }

    static bool EqualsIgnoreCase(String? s1, String? s2)
    {
        if (s1 == s2) return true;
        else if (s1 == null || s2 == null) return false;
        else return s1.ToLower().Equals(s2.ToLower());
    }


    /// <summary>
    /// Scans a plugin for all records of a given type and outputs named FormLink definitions for them.
    /// 
    /// They take the general form:
    /// static readonly public ModKey MY_MOD = new ModKey(FILENAME, ModType.Plugin);
    /// static readonly public FormLink<IMiscItemGetter> EDITORID = new (new FormKey(MY_MOD, 0x000000));
    /// 
    /// </summary>
    /// <typeparam name="T">The type of record to scan and make FormLink definitions for.</typeparam>
    /// <param name="filename">The name of the mod to scan.</param>

    public static void PrintFormKeysDefinitions<T>(String filename, IPatcherState<ISkyrimMod, ISkyrimModGetter> state) where T : IMajorRecordGetter
    {
        state.LoadOrder.TryGetIfEnabledAndExists(new ModKey(filename, ModType.Plugin), out var mod);
        var group = mod?.GetTopLevelGroup<T>();
        if (mod == null || group == null || group.Count == 0) return;

        String modname = $"{Regex.Replace(filename.ToUpper(), "[^a-zA-Z0-9_]", "")}";
        String typeName = typeof(T).FullName ?? "TYPENAME";

        System.Console.WriteLine($"static readonly public ModKey {modname} = new ModKey(\"{filename}\"), ModType.Plugin);");

        group.Where(rec => rec.EditorID != null).ForEach(rec => {
            var edid = rec.EditorID;
            var formID = rec.FormKey.ID.ToString("x");
            Console.WriteLine($"static readonly public FormLink<I{typeName}Getter> {edid} = new (new FormKey({modname}, 0x{formID}));");
        });

    }

    /// <summary>
    /// Convenience method for making entries for a LeveledItem.
    /// </summary>
    /// 
    static LeveledItemEntry CreateLeveledItemEntry(IFormLink<IItemGetter> item, int level, int count)
    {
        return new LeveledItemEntry
        {
            Data = new LeveledItemEntryData
            {
                Reference = item,
                Level = (short)level,
                Count = (short)count
            }
        };
    }

    readonly static private Dictionary<string, string> NameSubstitutions = new() {
        { "BearCave", "Bear, Cave" },
        { "BearSnow", "Bear, Snow" },
        { "CharusHunter", "Chaurus, Hunter"  },
        { "ElkFemale", "Elk, Female"  },
        { "ElkMale", "Elk, Male"  },
        { "FoxIce", "Fox, Snow"  },
        { "MudCrab01", "MudCrab, Small" },
        { "MudCrab02", "MudCrab, Large" },
        { "MudCrab03", "MudCrab, Giant" },
        { "SabrecatSnow", "Sabrecat, Snow" },
        { "FrostbiteSpider", "Spider, Frostbite" },
        { "FrostbiteSpiderGiant", "Spider, Giant Frostbite" },
        { "SprigganBurnt", "Spriggan, Burnt" },
        { "DeerVale", "Deer, Vale" },
        { "SabrecatVale", "Sabrecat, Vale" },
        { "WolfIce", "Wolf, Ice" },
        { "TrollFrost", "Troll, Frost" }
    };

    readonly static private List<String> DeathItemNameMatches = new(new String[] {
        "Werebear",
        "Bear",
        "BearCave",
        "BearSnow",
        "Bristleback",
        "Chaurus",
        "CharusHunter",
        "Chicken",
        "Cow",
        "DeerVale",
        "Deer",
        "Dog",
        "Dragon",
        "ElkFemale",
        "ElkMale",
        "FoxIce",
        "Fox",
        "FrostbiteSpiderGiant",
        "FrostbiteSpider",
        "Goat",
        "Hare",
        "Horker",
        "Horse",
        "Mammoth",
        "MudCrab01",
        "MudCrab02",
        "MudCrab03",
        "SabrecatSnow",
        "SabrecatVale",
        "Sabrecat",
        "Skeever",
        "Slaughterfish",
        "Spriggan",
        "SprigganBurnt",
        "TrollFrost",
        "Troll",
        "Werewolf",
        "WolfIce",
        "Wolf"
    });


    sealed class NoDeathItemException : Exception
    {
        public NoDeathItemException(FormKey form) : base($"No DeathItem: {form}") { }
    }

    sealed class DeathItemAlreadyAddedException : Exception
    {
        public DeathItemAlreadyAddedException(FormKey form) : base($"DeathItem already processed: {form}") { }
    }

    sealed class CoreRecordMissing : Exception
    {
        public CoreRecordMissing(IFormLinkGetter<ISkyrimMajorRecordGetter> form) : base($"Missing core record: {form}") { }
    }

    sealed class AddonRecordMissing : Exception
    {
        public AddonRecordMissing(FormKey form) : base($"Missing addon record: {form}") { }
    }

    sealed class ScriptMissing : Exception    {
        public ScriptMissing(String questname, String scriptName) : base($"Missing script: {questname}.{scriptName}") { }

    }
    sealed class PropertyMissing : Exception
    {
        public PropertyMissing(String questname, String scriptName, String propertyName) : base($"Missing property: {questname}.{scriptName}.{propertyName}") { }

    }
}