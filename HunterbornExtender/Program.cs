namespace HunterbornExtender;
using DynamicData;
using System;
using System.Threading.Tasks;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Microsoft.CodeAnalysis;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Aspects;
using Noggog;
using HunterbornExtender.Settings;
using static HunterbornExtender.FormKeys;
using DeathItemGetter = Mutagen.Bethesda.Skyrim.ILeveledItemGetter;
using System.Net;


#pragma warning disable IDE1006 // Naming Styles

sealed internal class Program
{

    record CreatureData(DeathItemGetter DeathItem, String InternalName, PluginEntry Prototype, bool IsAnimal, bool IsMonster);
    static readonly Dictionary<PluginEntry, IMiscItemGetter> KnownCarcasses = new();
    static readonly Dictionary<PluginEntry, IFormLinkGetter<IConstructibleGetter>[]> KnownPelts = new();
    static readonly Dictionary<DeathItemGetter, PluginEntry> KnownDeathItems = new();
    private static Lazy<Settings.Settings> _settings = null!;


    public static Task<int> Main(string[] args)
    {
        return SynthesisPipeline.Instance
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch, new PatcherPreferences()
            {
                ExclusionMods = new List<ModKey>() {
                    new ModKey("HunterbornExtenderPatch.esp", ModType.Plugin),
                },
            })
            .SetTypicalOpen(GameRelease.SkyrimSE, "HunterbornExtenderPatch.esp")
            .SetAutogeneratedSettings("settings", "settings.json", out _settings)
            .Run(args);
    }


    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        /*
        PatcherSettings jsonData;
        try
        {
            WriteLog("Trying to load stored DeathItem selections.");
            jsonData = JSONhandler<PatcherSettings>.LoadJSONFile("settings.json") ?? new();
            WriteLog(1, true, $"Read {jsonData.DeathItems.Count} selections and {jsonData.Plugins.Count} plugins.");
            else throw new InvalidOperationException("No data.");
        }
        catch (Exception ex)
        {
            WriteLog(0, false, "Failed to load stored DeathItem selections.");
            Console.WriteLine("=================================");
            Console.WriteLine(ex);
            Console.WriteLine("=================================");
            return;
        }*/

        //
        // However we do it, this is where we get a List<PluginEntry> from the addon jsons.
        //
        var settings = _settings.Value;
        
        Write.Divider(0);
        Write.Action(0, "Importing plugins.");
        var addonPlugins = LegacyConverter.ImportAndConvert(state);
        Write.Success(0, $"{addonPlugins.Count} creature types imported.");

        //
        // Resolve and locate all the FormLists and ScriptProperties that need patching.
        // 
        StandardRecords std;
        try
        {
            Write.Divider(0);
            Write.Action(0, "Trying to resolve required forms from Hunterborn.esp, and preparing the patch structure.");
            std = CreateStandardRecords(state, settings);
            Write.Success(0, $"Success: {std.PatchMod}");
        }
        catch (RecordException ex)
        {
            Write.Fail(0, $"Failed to resolve required forms because of unresolved reference [{ex.FormKey} {ex.EditorID}].");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            Write.Fail(0, "Failed to resolve required forms.");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        //
        // Create a List<PluginEntry> for the hard-coded creatures.
        // Merge it into the previous list.
        //
        List<InternalPluginEntry> internalPlugins;
        
        try
        {
            Write.Divider(0);
            Write.Action(0, "Trying to recreate the hard-coded core plugin from Hunterborn.esp.");
            internalPlugins = RecreateCorePlugins(std /*, CreateParentRecords(state)*/);

            if (internalPlugins.Count > 0)
            {
                Write.Success(0, $"Success: {internalPlugins.Count} hard-coded creature types found.");
            } 
            else
            {
                Write.Fail(0, $"No hard-coded creature types found. Check your Hunterborn installation.");
                return;
            }
        }
        catch (RecordException ex)
        {
            Write.Fail(0, $"Failed to recreate core plugin because of unresolved reference [{ex.FormKey} {ex.EditorID}].");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            Write.Fail(0, "Failed to recreate core plugin.");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        List<PluginEntry> plugins = new();
        plugins.AddRange(internalPlugins);
        plugins.AddRange(addonPlugins);
        settings.Plugins = plugins;
        Write.Success(0, $"Add-on creatures and hard-coded creatures merged; {plugins.Count} total.");

        // 
        // Import allowed and forbidden values from plugins.
        //
        foreach (var plugin in plugins)
        {
            if (!plugin.Voice.IsNull) AllowedVoices.Add(plugin.Voice);
        }

        //
        // Populates the KnownDeathItem, KnownCarcass, and KnownPelts structures.
        //
        try
        {
            PopulateKnown(plugins, std);
        }
        catch (RecordException ex)
        {
            Write.Fail(0, $"Failed to crossreference Hunterborn.esp with the Internal plugins because of reference [{ex.FormKey} {ex.EditorID}].");
            Write.Fail(0, $"THIS MAY INDICATE THAT YOU NEED TO CHECK THE HUNTERBORNEXTENDER SETTINGS.");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            Write.Fail(0, $"Failed to crossreference Hunterborn.esp with the Internal plugins.");
            Write.Fail(0, $"THIS MAY INDICATE THAT YOU NEED TO CHECK THE HUNTERBORNEXTENDER SETTINGS.");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        //
        // Link death entryItem selection to corresponding creature entry
        //
        foreach (var deathItem in settings.DeathItemSelections)
        {
            deathItem.Selection = plugins.Where(x => x.Name == deathItem.CreatureEntryName).FirstOrDefault();
        }

        Write.Success(0, $"Imported death plugin support for {plugins.Count} creatures");
        Write.Success(0, $"Imported {settings.DeathItemSelections.Length} death item selections");

        // Heuristic matching and user selections should already be done.
        //
        // Scan the load order and update the selections.
        // 
        try
        {
            Write.Action(0, $"Running heuristics.");
            var npcs = state.LoadOrder.PriorityOrder.Npc().WinningOverrides();
            int heuristics = MakeHeuristicSelections(plugins, npcs, std);
            Write.Success(0, $"Heuristics assigned {heuristics} creatures.");
        }
        catch (RecordException ex)
        {
            Write.Fail(0, $"Missing reference during heuristic: [{ex.FormKey} {ex.EditorID}].");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            Write.Fail(0, $"Error during heuristics.");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        //
        //================
        //================

        foreach (var selection in settings.DeathItemSelections)
        {
            var name = selection.CreatureEntryName;
            //WriteTitle(0, CreateTitle(internalName));

            PluginEntry? prototype = selection.Selection;

            // null is used to indicate "SKIP".
            if (prototype == null)
            {
                if (settings.DebuggingMode) Write.Title(0, $"(SKIPPED) {name}");
                continue;
            }

            Write.Title(0, $"{name} -> {prototype.Name}");

            try
            {
                var deathItem = state.LinkCache.Resolve<DeathItemGetter>(selection.DeathItem);
                var data = CreateCreatureData(deathItem, prototype, std);
                if (settings.DebuggingMode) Write.Success(1, $"Creating creature Data structure.");

                if (ForbiddenDeathItems.Contains(data.DeathItem.ToLink()))
                {
                    Write.Fail(1, $"Skipped {name}: DeathItem blacklisted.");
                }
                else if (KnownDeathItems.ContainsKey(data.DeathItem))
                {
                    Write.Fail(1, $"Skipped {name}: DeathItem already processed.");
                } 
                else
                {
                    KnownDeathItems.Add(data.DeathItem, prototype);
                    AddRecord(data, std);
                }
            }
            catch (RecordException ex)
            {
                Write.Fail(1, $"Skipped {name}: DeathItem [{ex.FormKey} {ex.EditorID}] could not be resolved");
            }
            catch (DeathItemAlreadyAddedException)
            {
                Write.Fail(1, $"Skipped {name}: DeathItem already processed.");
            }
            catch (NoDeathItemException)
            {
                Write.Fail(1, $"Skipped {name}: No DeathItem.");
            }
            catch (Exception ex)
            {
                Write.Fail(1, $"Skipped {name}: {ex.Message}");
                Console.WriteLine(ex.StackTrace);
            }
        }
    }

    /// <summary>
    /// This should be called from the UI to pre-select the choices for each deathitem.
    /// 
    /// If Settings.ReuseSelections is enabled then selections in the settings will be preferred.
    /// Everything still gets scanned anyway in case the loadorder has changed.
    /// 
    /// The selections array in Settings is replaced with a new one.
    /// 
    /// </summary>
    /// 
    static int MakeHeuristicSelections(List<PluginEntry> plugins, IEnumerable<INpcGetter> npcs, StandardRecords std)
    {
        // For each DeathItem, there will be a weighted set of plausible Plugins.
        // HeuristicMatcher assigns the weights.
        Dictionary<DeathItemSelection, Dictionary<PluginEntry, int>> selectionWeights = new();
        Dictionary<DeathItemGetter, DeathItemSelection> indexer = new();

        // Tokenize the names of the plugins.
        foreach (var plugin in plugins) plugin.Tokens = TokenizeNames(plugin.Name, plugin.SortName, plugin.ProperName);
        if (std.Settings.DebuggingMode) 
        {
            Write.Title(1, "Tokenizing plugin names.");
            plugins.ForEach(p => Write.Action(2, $"Plugin: {p.Name} -> {p.Tokens.Pretty()}"));
            Write.Title(1, "Analyzing NPCs.");
        }

        // Scan the list of npcs.
        foreach (var npc in npcs.Where(IsCreature))
        {
            //if (settings.DebuggingMode) Write.Action(2, $"Heuristics examining {npc}");
            if (npc.DeathItem?.IsNull ?? true) continue;
            
            var deathItem = npc.DeathItem.Resolve(std.LinkCache);
            if (KnownDeathItems.ContainsKey(deathItem)) continue;

            // If there is no DeathItemSelection record for the NPC's DeathItem, create it.
            // Try as hard as possible to give the DeathItemSelection a internalName. Fallbacks on fallbacks.
            if (!indexer.ContainsKey(deathItem))
            {
                indexer[deathItem] = new DeathItemSelection()
                {
                    DeathItem = deathItem.FormKey,
                    CreatureEntryName = deathItem.EditorID ?? npc.EditorID ?? npc.Name?.ToString() ?? Guid.NewGuid().ToString()
                };
                selectionWeights[indexer[deathItem]] = new();
            }

            // Add the NPC to the assigned NPCs of the DeathItemSelection.
            var deathItemSelection = indexer[deathItem];
            deathItemSelection.AssignedNPCs.Add(npc);

            // Run the heuristic matcher.
            var npcWeights = HeuristicNpcMatcher(npc, plugins, std);
            var itemWeights = selectionWeights[deathItemSelection];

            foreach (PluginEntry plugin in npcWeights.Keys)
                itemWeights[plugin] = itemWeights.GetValueOrDefault(plugin, 0) + npcWeights[plugin];
        }

        DeathItemSelection[] selections = selectionWeights.Keys.ToArray();
        Dictionary<FormKey, PluginEntry?> savedSelections = std.Settings.DeathItemSelections.ToDictionary(v => v.DeathItem, v => v.Selection);
        int modifiedCount = 0;

        foreach (var selection in selections)
        {
            if (std.Settings.ReuseSelections && savedSelections.ContainsKey(selection.DeathItem))
            {
                selection.Selection = savedSelections[selection.DeathItem];
                if (std.Settings.DebuggingMode) Write.Action(3, $"Previously selected {selection.Selection?.ProperName}.");
            }
            else
            {
                var itemWeights = selectionWeights[selection];
                List<PluginEntry> options = new(itemWeights.Keys);
                if (options.Count == 0) continue;

                options.Sort((a, b) => itemWeights[b].CompareTo(itemWeights[a]));
                selection.Selection = options.First();
                if (std.Settings.DebuggingMode && !selection.DeathItem.IsNull)
                {
                    selection.DeathItem.ToLink<DeathItemGetter>().TryResolve(std.LinkCache, out var deathItem);
                    Write.Action(2, $"{deathItem?.EditorID ?? deathItem?.ToString() ?? "NO DEATH ITEM"}: heuristic selected {selection.Selection?.SortName}.");
                    Write.Action(3, $"From: {itemWeights.Pretty()}");

                    var npcNames = selection.AssignedNPCs.Take(6).Select(n => NpcNamerFallback(n, std.LinkCache)).ToArray().Pretty();
                    Write.Action(3, $"Archetypes: {npcNames}");
                }
                modifiedCount = 0;
            }
        }

        std.Settings.DeathItemSelections = selections;
        return modifiedCount;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    static Dictionary<PluginEntry, int> HeuristicNpcMatcher(INpcGetter npc, List<PluginEntry> plugins, StandardRecords std)
    {
        Dictionary<PluginEntry, int> candidates = new();
        String name = NpcNamerFallback(npc, std.LinkCache);

        var clicker = DictionaryIncrementer(candidates);

        // Try to match the voice.
        if (!npc.Voice.IsNull)
        {
            plugins
                .Where(plugin => !plugin.Voice.IsNull)
                .Where(plugin => plugin.Voice.Equals(npc.Voice))
                .ForEach(clicker(10));
        }

        // Match the creature's editorId, internalName, and race internalName to the names of plugins.
        var nameMatches = new HashSet<PluginEntry>();
        var race = npc.Race.Resolve(std.LinkCache);

        if (npc.EditorID is string npcEditorId) plugins.Where(PluginNameMatch(npcEditorId)).ForEach(clicker(1));
        if (npc.Name?.ToString() is string npcName) plugins.Where(PluginNameMatch(npcName)).ForEach(clicker(1));
        if (race.EditorID is string raceEditorId) plugins.Where(PluginNameMatch(raceEditorId)).ForEach(clicker(1));
        if (race.Name?.ToString() is string raceName) plugins.Where(PluginNameMatch(raceName)).ForEach(clicker(1));

        // Try this tokenizing matcher to break ties.
        var npcTokens = TokenizeNames(new List<string?>() { NpcNamer(npc), RaceNamer(race), NpcDeathItemNamer(npc, std.LinkCache) });
        if (std.Settings.DebuggingMode) Write.Action(2, $"Tokens for {name}: {npcTokens.Pretty()}");

        foreach (var plugin in plugins)
        {
            int intersection = plugin.Tokens.Intersect(npcTokens).Count();
            if (intersection > 0) clicker(intersection)(plugin);
        }

        // @TODO Add matching for distinctive keywords?
        // @TODO Add exclusion terms?

        if (std.Settings.DebuggingMode)
        {
            Write.Success(2, $"Candidates for {name}:");
            Write.Success(3, candidates.Pretty());
        }

        return candidates;
    }

    /// <summary>
    /// Matcher for plugin names. 
    /// A match occurs if the plugin internalName is contained in the target string.
    /// Case-insensitive.
    /// 
    /// </summary>
    /// <param internalName="str">The string against which to match the plugin names.</param>
    /// <returns>The matcher.</returns>
    /// 
    static Func<PluginEntry,bool> PluginNameMatch(String str) => plugin => str.ContainsInsensitive(plugin.Name);

    /// <summary>
    /// This thing is ridiculous but convenient. Can you say "Currying"?
    /// 
    /// </summary>
    /// 
    static Func<int, Action<T>> DictionaryIncrementer<T>(Dictionary<T, int> dict) where T : notnull
        => val => plugin => { if (val > 0) dict[plugin] = dict.GetValueOrDefault(plugin, 0) + val; };

    /// <summary>
    /// Populate the KnownDeathItems, KnownCarcasses, and KnownPelts.
    /// Having these means that when new Pelts, DeathItems, and Carcasses get created, they
    /// can copy the models and keywords from existing ones.
    /// 
    /// </summary>
    /// 
    /// <param internalName="plugins"></param>
    /// <param internalName="std"></param>
    /// <exception cref="CoreRecordMissing"></exception>
    /// <exception cref="InvalidOperationException"></exception>
    /// 
    static void PopulateKnown(List<PluginEntry> plugins, StandardRecords std)
    {

        Dictionary<FormKey, InternalPluginEntry> internalPlugins = new();
        foreach (var plugin in plugins)
        {
            if (plugin is InternalPluginEntry p) internalPlugins[p.KnownDeathItem] = p;
            //if (plugin is InternalPluginEntry p2) Console.WriteLine($"Recreating FormKey->Plugin:  {p2.KnownDeathItem,-12} -> {p2.ProperName}");
            //else Console.WriteLine($"Recreating FormKeys: not internal {plugin.ProperName}");
        }


        foreach (EntryType type in Enum.GetValues(typeof(EntryType)))
        {
            int count = std.GetCCFor(type).RaceIndex.Data.Count;
            Write.Action(1, $"Populating data structures for {count} {type} types.");

            // This basically comes down to going through the FormList of deathitems (once for animals and once for monsters),
            // determining which InternalPlugin each DeathItem corresponds to, and then
            // * Put the DeathItem->Plugin entry into KnownDeathItems.
            // * Put the corresponding entry from the Pelts formlist into KnownPelts.
            // * Put the corresponding entry from the Carcasses entry into KnownCarcasses.
            // * @TODO Same for materials?
            for (int index = 0; index < count; index++)
            {
                try
                {
                    var name = std.GetCCFor(type).RaceIndex.Data[index];

                    // Get the DeathItem link from the formlist and resolve it.
                    std.GetCCFor(type)._DS_FL_DeathItems.Items[index].TryResolve<DeathItemGetter>(std.LinkCache, out var deathItem);

                    if (deathItem == null) throw new DataConsistencyError(type, name, index, "No DeathItem.");
                    if (KnownDeathItems.ContainsKey(deathItem)) continue;

                        // Match the DeathItem to the plugin it came from.
                        // Fatal error if it's not found.
                        if (!internalPlugins.ContainsKey(deathItem.FormKey))
                    {
                        Console.WriteLine($"Fatal error: internalPlugin for {deathItem} is missing.");
                        throw new CoreRecordMissing(deathItem.ToLink());
                    }

                    // Finally, put the DeathItem in KnownDeathItems.
                    var plugin = internalPlugins[deathItem.FormKey];
                    KnownDeathItems.Add(deathItem, plugin);

                    // Get the Carcass link from the formlist, resolve it, and put it in KnownCarcasses.
                    // Only animals have carcasses. I guess you can't carry monster corpses around.
                    if (type == EntryType.Animal)
                    {
                        if (std.Animals._DS_FL_CarcassObjects.Items[index].Resolve(std.LinkCache) is not IMiscItemGetter carcass)
                            throw new CoreRecordMissing(std.Animals._DS_FL_CarcassObjects.Items[index]);
                        KnownCarcasses.Add(plugin, carcass);
                    }

                    // Get the Pelts link from the formlist, resolve it, transform it into an array, and put it in KnownPelts.
                    if (std.GetCCFor(plugin.Type)._DS_FL_PeltLists.Items[index].Resolve(std.LinkCache) is not IFormListGetter pelts)
                        throw new CoreRecordMissing(std.GetCCFor(plugin.Type)._DS_FL_PeltLists.Items[index]);

                    IFormLinkGetter<IConstructibleGetter>[] peltsArray = pelts.Items.Select(item => item.FormKey.ToLinkGetter<IConstructibleGetter>()).ToArray();
                    if (peltsArray.Length != 0 && peltsArray.Length != 4)
                        throw new InvalidOperationException($"Wrong length for pelts: {plugin.Name} -- {std.GetCCFor(plugin.Type)._DS_FL_PeltLists.Items[index]}");
                    KnownPelts.Add(plugin, peltsArray);
                } 
                catch (DataConsistencyError ex)
                {
                    Write.Fail(0, "WARNING: inconsistent data detected. This may be the result of some other mod patching Hunterborn.");
                    Write.Fail(0, ex.Message);
                }
            }
        }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param internalName="std"></param>
    /// <returns></returns>
    static List<InternalPluginEntry> RecreateCorePlugins(StandardRecords std)
    {
        List<InternalPluginEntry> plugins = new();

        foreach (EntryType type in Enum.GetValues(typeof(EntryType)))
        {
            int count = std.GetCCFor(type).RaceIndex.Data.Count;
            Write.Action(1, $"Recreating {count} {type} plugin entries.");

            if (std.Settings.DebuggingMode)
            {
                if (type == EntryType.Animal) Console.WriteLine($"\tChecks: names={std.GetCCFor(type)._DS_FL_DeathItems.Items.Count}, pelts={std.GetCCFor(type)._DS_FL_PeltLists.Items.Count}, carcasses={std.Animals._DS_FL_CarcassObjects.Items.Count}");
                else Write.Action(1, $"Checks: names={std.GetCCFor(type)._DS_FL_DeathItems.Items.Count}, pelts={std.GetCCFor(type)._DS_FL_PeltLists.Items.Count}");
            }

            for (int index = 0; index < count; index++)
            {
                try
                {
                    InternalPluginEntry entry = RecreateCorePluginEntry(type, index, std);
                    plugins.Add(entry);
                }
                catch (DataConsistencyError ex)
                {
                    Write.Fail(0, "WARNING: inconsistent data detected. This may be the result of some other mod patching Hunterborn.");
                    Write.Fail(0, ex.Message);
                }
            }
        }

        return plugins;
    }

    static InternalPluginEntry RecreateCorePluginEntry(EntryType type, int index, StandardRecords std)
    {
        String internalName = std.GetCCFor(type).RaceIndex.Data[index];
        if (internalName.IsNullOrWhitespace()) throw new DataConsistencyError(type, internalName, index, "No name.");

        try
        {
            var deathItemLink = std.GetCCFor(type)._DS_FL_DeathItems.Items[index];
            if (deathItemLink.IsNull) throw new DataConsistencyError(type, internalName, index, "No DeathItem.");

            deathItemLink.TryResolve<DeathItemGetter>(std.LinkCache, out var deathItem);
            if (deathItem == null) throw new DataConsistencyError(type, internalName, index, "DeathItem could not be resolved.");
            if (deathItem.EditorID == null) throw new DataConsistencyError(type, internalName, index, $"DeathItem {deathItem.FormKey} has no editor id.");

            InternalPluginEntry plugin = new(type, internalName, deathItem.FormKey);
            var renaming = RecreatePluginName(plugin, deathItem);

            if (!renaming.Equals(NoRename)) (internalName, plugin.ProperName, plugin.SortName) = renaming;
            if (std.Settings.DebuggingMode) Write.Action(2, $"Recreating {plugin.Name} from {DeathItemNamerFallback(deathItem)} (proper name '{plugin.ProperName}', sort name '{plugin.SortName}')");

            var toggle = std.GetCCFor(type).Switches.Objects[index].Object;
            if (toggle.IsNull) plugin.Toggle = new FormLink<IGlobalGetter>();
            else plugin.Toggle = toggle.Resolve<IGlobalGetter>(std.LinkCache).ToLink();

            var meat = std.GetCCFor(type).MeatType.Objects[index].Object;
            if (meat.IsNull) plugin.Meat = new FormLink<IItemGetter>();
            else plugin.Meat = meat.Resolve<IItemGetter>(std.LinkCache).ToLink();

            var shared = std.GetCCFor(type).SharedDeathItems.Objects[index].Object;
            if (shared.IsNull) plugin.SharedDeathItems = new FormLink<IFormListGetter>();
            else plugin.SharedDeathItems = shared.Resolve<IFormListGetter>(std.LinkCache).ToLink();

            plugin.CarcassSize = std.GetCCFor(type).CarcassSizes.Data[index];

            if (type == EntryType.Monster)
            {
                var venom = std.Monsters.VenomItems.Objects[index].Object;
                if (venom.IsNull) plugin.Venom = new FormLink<IIngestibleGetter>();
                else plugin.Venom = venom.Resolve<IIngestibleGetter>(std.LinkCache).ToLink();

                var blood = std.Monsters.BloodItems.Objects[index].Object;
                if (blood.IsNull) plugin.BloodType = new FormLink<IItemGetter>();
                else plugin.BloodType = blood.Resolve<IItemGetter>(std.LinkCache).ToLink();

                plugin.CarcassWeight = 0;
                plugin.CarcassValue = 0;
            }
            else if (type == EntryType.Animal)
            {
                var msg = std.Animals.CarcassMessages.Objects[index].Object;
                if (msg.IsNull) plugin.CarcassMessageBox = new FormLink<IMessageGetter>();
                else plugin.CarcassMessageBox = msg.Resolve<IMessageGetter>(std.LinkCache).ToLink();

                plugin.Venom = new FormLink<IIngestibleGetter>();
                plugin.BloodType = new FormLink<IItemGetter>();

                var carcass = std.Animals._DS_FL_CarcassObjects.Items[index].Resolve<IMiscItemGetter>(std.LinkCache);
                plugin.CarcassWeight = (int)carcass.Weight;
                plugin.CarcassValue = (int)carcass.Value;
            }

            plugin.Discard = type != EntryType.Monster
                ? new()
                : std.Monsters.Discards.Objects[index].Object
                .Resolve<IFormListGetter>(std.LinkCache).Items
                .Select(item => item as IFormLinkGetter<IItemGetter>)
                .Where(item => item is not null)
                .Select(item => item!).ToList();

            var mats = std.GetCCFor(type)._DS_FL_Mats__Lists.Items[index].Resolve<IFormListGetter>(std.LinkCache);
            plugin.Materials = RecreateMaterials(mats, std);
            // Console.WriteLine($"===RECREATED MATS FOR {plugin.ProperName}: {plugin.Materials.Pretty()}");

            plugin.PeltCount = Array.Empty<int>();
            plugin.FurPlateCount = Array.Empty<int>();

            // The voice field is unnecessary because the core voices are hard-coded.
            // But it's nice to have it just in case.
            // 
            // We could scan through all NPCs looking for the matching DeathItem and grab the voice of
            // the first match.
            //
            // BUT
            // 
            // Vanilla voices are named very predictably, so just use that.
            //
            string voiceEdid = $"Cr{plugin.Name}Voice";
            std.LinkCache.TryResolve<IVoiceTypeGetter>(voiceEdid, out var voice);
            plugin.Voice = voice == null ? new FormLink<IVoiceTypeGetter>() : voice.ToLink();
            //if (std.Settings.DebuggingMode) Write.Action(2, $"Internal plugin {plugin.Name} searching for voice {voiceEdid}: found {plugin.Voice}.");

            FindRecipes(plugin, internalName, deathItem, std);

            // @TODO Find jerky and charred recipes.
            return plugin;

        } 
        catch(RecordException ex)
        {
            Write.Title(0, $"Problem with {type} {internalName} {ex.FormKey} {ex.EditorID}");
            Write.Fail(1, $"Problem with {type} {internalName} {ex.FormKey} {ex.EditorID}");
            Write.Fail(1, ex.Message);
            Console.WriteLine(ex.StackTrace);
            throw ex;
        }
    }

    /// <summary>
    /// Fill in recipe-related data for the internal plugins.
    /// 
    /// </summary>
    /// 
    static private void FindRecipes(PluginEntry plugin, string internalName, DeathItemGetter deathItem, StandardRecords std)
    {
        // Search for the standard recipes using naming conventions in the order of
        // CACO->CCOR->Campfire->Hunterborn->Vanilla.
        // If nothing is found, try again using the plugin name instead of the internal name.

        List<List<string>> patterns = new() {
            new() { "_DS_Recipe_Pelt_{0}_00" },
            new() { "_DS_Recipe_Pelt_{0}_01", "RecipeLeather{0}Hide" },
            new() { "_DS_Recipe_Pelt_{0}_02" },
            new() { "_DS_Recipe_Pelt_{0}_03" },
            new() { "HB_Recipe_FurPlate_{0}_00" },
            new() { "CCOR_RecipeFurPlate{0}Hide", "_Camp_RecipeTanningLeather{0}Hide", "HB_Recipe_FurPlate_{0}_01" },
            new() { "HB_Recipe_FurPlate_{0}_02" },
            new() { "CACO_RecipeFood{0}Cooked", "CACO_RecipeFoodMeatFoxCooked", "_DS_Recipe_Food_CharredMeat_{0}" },
            new() { "CACO_RecipeFood{0}Cooked_Campfire", "HB_Recipe_FireFood_CharredMeat_{0}" },
            new() { "HB_CACO_RecipeFood{0}Cooked_PrimCook", "_DS_Recipe_Food_Primitive_CharredMeat_{0}" },
            new() { "CACO_RecipeJerky{0}", "_DS_Food_{0}Jerky", "_DS_Recipe_Food_{0}Jerky"}};

        // Some corrections for vanilla and hunterborn recipes with non-standard names.
        List<string> names = new() { internalName, plugin.Name };
        if (plugin.Name.EqualsIgnoreCase("Cow")) names.Add("Beef");
        if (plugin.Name.EqualsIgnoreCase("Deer")) names.Add("Venison");
        if (plugin.Name.ContainsInsensitive("Elk")) names.Add("Venison");
        if (plugin.Name.EqualsIgnoreCase("Dog")) names.Add("DogCookedWhole");
        if (plugin.Name.ContainsInsensitive("Mudcrab")) names.Add("Mudcrab");
        if (plugin.Name.ContainsInsensitive("Bristleback")) names.Add("Boar");

        var recipes = Edid_Lookups_Fallbacks(names, patterns, std);

        // Extract the results to nicely named variables.
        var pelts0 = recipes[0];
        var pelts1 = recipes[1];
        var pelts2 = recipes[2];
        var pelts3 = recipes[3];
        var furs0 = recipes[4];
        var furs1 = recipes[5];
        var furs2 = recipes[6];
        var meatCooked = recipes[7];
        var meatCampfire = recipes[8];
        var meatPrimitive = recipes[9];
        var meatJerky = recipes[10];

        // If a standard pelt recipe is found, there must be a default pelt.
        // Try to get it. Use the result of the GetDefaultPelt function otherwise, which 
        // searches the creature's inventory.
        if (pelts1 is not null && pelts1.Items is IReadOnlyList<IContainerEntryGetter> containerEntries
            && containerEntries.Count > 0 && containerEntries[0] is IContainerEntryGetter containerEntry
            && containerEntry.Item is IContainerItemGetter containerItem
            && containerItem.Item is IFormLink<IItemGetter> foundPelt)
        {
            if (foundPelt is not null && !foundPelt.IsNull)
            {
                if (std.Settings.DebuggingMode) Write.Success(3, $"Found default pelt from tanning recipe {pelts1.EditorID}.");
                plugin.DefaultPelt = foundPelt.FormKey.ToLink<IMiscItemGetter>();
            }
        }
        else
        {
            var defaultPelt = GetDefaultPelt(deathItem, std);
            if (defaultPelt is not null)
            {
                if (std.Settings.DebuggingMode) Write.Success(3, $"Found default pelt from DeathItem {deathItem.EditorID}.");
                plugin.DefaultPelt = defaultPelt.ToLink();
            }
        }

        // Pack it all up and finish filling in the Plugin's properties.
        // Print debugging messages about what was found.

        if (pelts0 is not null && pelts1 is not null && pelts2 is not null && pelts3 is not null)
        {
            if (std.Settings.DebuggingMode) Write.Success(2, "Found a full set of leather-making recipes.");
            plugin.Recipes.PeltRecipes = (pelts0, pelts1, pelts2, pelts3);
            plugin.PeltCount = new int[] { pelts0.CreatedObjectCount ?? 2, pelts1.CreatedObjectCount ?? 2, pelts2.CreatedObjectCount ?? 2, pelts3.CreatedObjectCount ?? 2 };
        }
        else if (pelts0 is not null || pelts1 is not null || pelts2 is not null || pelts3 is not null)
        {
            if (std.Settings.DebuggingMode) Write.Fail(2, "Found inconsistent set of leather-making recipes.");
        }

        if (furs0 is not null && furs1 is not null && furs2 is not null)
        {
            if (std.Settings.DebuggingMode) Write.Success(2, "Found a full set of fur-plating recipes.");
            plugin.Recipes.FurPlateRecipes = (furs0, furs1, furs2);
            plugin.FurPlateCount = new int[] { furs0.CreatedObjectCount ?? 1, furs1.CreatedObjectCount ?? 2, furs2.CreatedObjectCount ?? 4 };
        }
        else if (furs0 is not null || furs1 is not null || furs2 is not null)
        {
            if (std.Settings.DebuggingMode) Write.Fail(2, "Found inconsistent set of fur-plating recipes.");
        }

        if (std.Settings.DebuggingMode)
        {
            if (!plugin.DefaultPelt.IsNull) Write.Success(2, $"Found standard pelt: {plugin.DefaultPelt}");
            else if (plugin.PeltCount.Length > 0) Write.Fail(2, $"No pelt found but pelt counts are specified.");
        }

        if (meatCooked is not null || meatCampfire is not null || meatPrimitive is not null || meatJerky is not null)
        {
            plugin.Recipes.MeatRecipes = (meatCooked, meatCooked, meatPrimitive, meatJerky);
            if (std.Settings.DebuggingMode) Write.Success(2, $"Found meat recipes: {plugin.Recipes.MeatRecipes.Pretty()}");
        }
        else if (!plugin.Meat.IsNull && std.Settings.DebuggingMode) Write.Fail(2, $"No meat recipes found.");

    }

    static private List<IConstructibleObjectGetter?> Edid_Lookups_Fallbacks(List<string> names, List<List<string>> patterns, StandardRecords std)
    {
        List<IConstructibleObjectGetter?> results = new();

        foreach (var group in patterns) 
        {
            IConstructibleObjectGetter? result = null;
            foreach (var name in names)
            {
                foreach (var pattern in group)
                {
                    std.LinkCache.TryResolve<IConstructibleObjectGetter>(String.Format(pattern, name), out result);

                    /*if (std.Settings.DebuggingMode)
                    {
                        if (names.Contains("Fox"))
                        {
                            if (result is not null) Write.Success(3, $"Found Recipe {String.Format(pattern, name)}");
                            else Write.Fail(3, $"No recipe {String.Format(pattern, name)}");
                        }
                    }*/
                    if (result is not null) break;
                }
                if (result is not null) break;
            }
            results.Add(result);
        }

        return results;
    }

    static private T? EdidLookupFallback<T>(string template, string name1, string name2, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache) where T : SkyrimMajorRecord
    {
        linkCache.TryResolve<T>(String.Format(template, name1), out var result);
        if (result == null) linkCache.TryResolve<T>(String.Format(template, name2), out result);
        return result;
    }

    /// <summary>
    /// Attempts to recreate the useful names for the plugin.
    /// </summary>
    /// <returns>A tuple of (deathItemName, ProperName, SortName)</returns>
    static private (string, string, string) RecreatePluginName(PluginEntry plugin, DeathItemGetter deathItem)
    {
        if (deathItem.EditorID is string deathItemEdid && DeathItemPrefix.IsMatch(deathItemEdid))
        {
            string deathItemName = DeathItemPrefix.Replace(deathItemEdid, "");
            if (Substitutions.EditorToNames.ContainsKey(deathItemName) && Substitutions.EditorToNames[deathItemName].Count > 0)
            {
                var parts = Substitutions.EditorToNames[deathItemName];

                if (parts.Count == 1) return (deathItemName, parts[0], parts[0]);
                else if (parts.Count == 2) return (deathItemName, $"{parts[1]} {parts[0]}", $"{parts[0]} - {parts[1]}");
                else if (parts.Count == 3) return (deathItemName, $"{parts[2]} {parts[1]} {parts[0]}", $"{parts[0]} - {parts[1]}, {parts[2]}");
            }
            else if (!deathItemName.EqualsIgnoreCase(plugin.Name))
            {
                string subtype = deathItemName.Replace(plugin.Name, "", StringComparison.InvariantCultureIgnoreCase);
                if (!subtype.IsNullOrWhitespace())
                    return (deathItemName, TextInfo.ToTitleCase($"{subtype} {plugin.Name}"), TextInfo.ToTitleCase($"{plugin.Name} - {subtype}"));
            }
        }

        return NoRename;
    }

    /// <summary>
    /// Regular expression used to turn the names of vanilla DeathItems into useful names.
    /// </summary>
    static private readonly Regex DeathItemPrefix = new(".*DeathItem", RegexOptions.IgnoreCase);

    /// <summary>
    /// Used to make nice names.
    /// </summary>
    static private readonly TextInfo TextInfo = CultureInfo.CurrentCulture.TextInfo;

    /// <summary>
    /// Flag object indicating that RecreatePluginName did not have a result.
    /// </summary>
    static private (string, string, string) NoRename = ("", "", "");

    /// <summary>
    /// Things that have to be done for each race:
    /// 
    /// 
    /// ==NEW RECORDS==
    /// Create a token MiscItem that identifies the creature as being Hunterborn-enabled.
    /// Create a carcass MiscItem that can go in the player's inventory.
    /// 
    /// Create a materials FormList containing 4 leveled lists of stuff, for the four levels of harvesting skill.
    /// 
    /// Create either 3 or 4 pelt MiscItems (3 if there's a default one the creature already).
    /// Create Leather and Fur Plate recipes for the pelts.
    /// 
    /// Add the creature's DeathItem to the DeathItems formlist.
    /// 
    /// Creature a new CustomDeathItem that contains tokens for the actions supported by the creature.
    /// 
    /// 
    /// ==HUNTERBORN QUEST SCRIPT==
    /// Add the carcass size to its array property.
    /// Add the carcass custom message (if any) to its array property.
    /// Add the CustomDeathItem to its array property.
    /// Add the meat type (if any) to its array property.
    /// Add the meat weight (if any) to its array property.
    /// Add the default pelt value (if any) to its array property.
    /// Add the shared death entryItem (if any) to its array property.
    /// Add the proper internalName to its array property.
    /// 
    /// For monsters:
    /// Add the venom (if any) to its array property.
    /// Add the blood (if any) to its array property.
    /// Add the "negative treasure" (if any) to its array property.
    /// 
    /// </summary>
    /// 
    static void AddRecord(CreatureData data, StandardRecords std)
    {
        var token = CreateToken(data, std);
        var mats = CreateMaterials(data, std);
        var pelts = CreatePelts(data, std);
        var deathDescriptor = CreateDeathDescriptor(data, std, pelts, mats);
        if (data.IsAnimal) CreateCarcass(data, std);
        if (data.IsMonster) CreateDiscards(data, std);

        std.GetCCFor(data).RaceIndex.Data.Add(data.InternalName);
        std.GetCCFor(data).CarcassSizes.Data.Add(data.Prototype.CarcassWeight);
        std.GetCCFor(data).Switches.Objects.Add(CreateProperty(data.Prototype.Toggle));
        std.GetCCFor(data).SharedDeathItems.Objects.Add(CreateProperty(data.Prototype.SharedDeathItems));

        if (GetDefaultMeat(data, std) is IItemGetter meat)
        {
            meat = std.ItemSubstitution(meat);
            std.GetCCFor(data).MeatType.Objects.Add(CreateProperty(meat.ToLink()));
            std.GetCCFor(data).MeatWeights.Data.Add(meat is IWeightValueGetter w ? w.Weight : 0.0f);
        }
        else
        {
            std.GetCCFor(data).MeatType.Objects.Add(CreateProperty(new FormLink<Ingestible>()));
            std.GetCCFor(data).MeatWeights.Data.Add(0.0f);
        }

        if (data.IsMonster)
        {
            std.Monsters.BloodItems.Objects.Add(CreateProperty(data.Prototype.BloodType));
            std.Monsters.VenomItems.Objects.Add(CreateProperty(data.Prototype.Venom));
        } 
        else
        {
            std.Animals.CarcassMessages.Objects.Add(CreateProperty(data.Prototype.CarcassMessageBox));
        }

        if (std.Settings.DebuggingMode)
        {
            Write.Success(1, $"Created new forms:");
            Write.Success(2, $"ID Token: {token}");
            Write.Success(2, $"Materials: {mats}");
            Write.Success(2, $"Pelts: {pelts.Pretty()}");
            Write.Success(2, $"Descriptor: {deathDescriptor}");
            Write.Success(2, $"Updated quest script properties.");
        }
    }

    static CreatureData CreateCreatureData(DeathItemGetter deathItem, PluginEntry prototype, StandardRecords std)
    {
        CreatureData data = new(deathItem, CreateInternalName(deathItem), prototype, prototype.Type == EntryType.Animal, prototype.Type == EntryType.Monster);
        return data;
    }

    /// <summary>
    /// Creates a unique internal internalName for the specified DeathItem. 
    /// This is used to derive the editorIds for the new forms that will be created 
    /// for the specified DeathItem.
    /// </summary>
    /// <param internalName="deathItem">The DeathItem to create a reasonably unique internalName for.</param>
    /// <returns>A reasonably unique internalName.</returns>
    /// 
    static string CreateInternalName(DeathItemGetter deathItem) 
    {
        if (deathItem.EditorID.IsNullOrWhitespace()) return INTERNAL_NAME_FILTER.Replace(deathItem.FormKey.ToString(), "");
        else return INTERNAL_NAME_FILTER.Replace(deathItem.EditorID, "");
    }
    readonly static private Regex INTERNAL_NAME_FILTER = new("[^a-zA-Z0-9_]", RegexOptions.IgnoreCase);

    /// <summary>
    /// Creates the Misc deathtoken for a creature.
    /// 
    /// The new deathtoken is appended to the deathtoken formlist for animals or monsters.
    /// 
    /// The deathtoken will be derived from the prototype's token (if it exists) or derived from the COW's deathtoken.
    /// 
    /// Naming is done heuristically. 
    /// </summary>
    /// 
    static private MiscItem CreateToken(CreatureData data, StandardRecords std)
    {
        // Get a pre-existing token that already has the keywords and model set.
        // That way all that needs to be done is to change the internalName and editor ID.
        var existingTokenLink = data.IsAnimal ? DEFAULT_TOKEN_ANIMAL : DEFAULT_TOKEN_MONSTER;
        existingTokenLink.TryResolve(std.LinkCache, out var existingToken);
        if (existingToken == null) throw new CoreRecordMissing(existingTokenLink);

        // Add the token to the patch.
        var token = std.PatchMod.MiscItems.DuplicateInAsNewRecord(existingToken);
        if (token == null) throw new InvalidOperationException();

        // Set the EditorID.
        token.EditorID = $"_DS_DI{data.InternalName}";
        token.Name = $"{data.InternalName} Token";

        // Put the token in the correct formlist.
        std.GetCCFor(data)._DS_FL_DeathItemTokens.Items.Add(token);

        return token;
    }

    static MiscItem CreateCarcass(CreatureData data, StandardRecords std)
    {
        // Get a pre-existing carcass that already has the keywords set.
        DEFAULT_CARCASS.TryResolve(std.LinkCache, out var existingCarcass);
        if (existingCarcass == null) throw new CoreRecordMissing(DEFAULT_CARCASS);

        // Add the carcass to the patch.
        var carcass = std.PatchMod.MiscItems.DuplicateInAsNewRecord(existingCarcass);
        if (carcass == null) throw new InvalidOperationException();

        var oldName = carcass.Name?.String;
        if (oldName.IsNullOrEmpty()) oldName = "Cow Carcass";

        carcass.EditorID = $"_DS_Carcass{data.InternalName}";
        carcass.Name = oldName.Replace("Cow", $"{data.Prototype.ProperName}");

        carcass.Value = (uint)data.Prototype.CarcassValue;
        carcass.Weight = data.Prototype.CarcassWeight;

        carcass.Model = KnownCarcasses.ContainsKey(data.Prototype)
            ? KnownCarcasses[data.Prototype].Model?.DeepCopy() ?? CreateDefaultCarcassModel()
            : CreateDefaultCarcassModel();

        // Put the carcass in the correct formlist.
        std.Animals._DS_FL_CarcassObjects.Items.Add(carcass);

        return carcass;
    }

    static Model CreateDefaultCarcassModel()
    {
        return new Model { File = "Clutter\\Containers\\MiscSackLarge.nif", AlternateTextures = null };
    }

    /// <summary>
    /// Creates a FormList of LeveledItems from a list of MaterialLevels in a prototype.
    /// </summary>
    /// 
    static FormList CreateMaterials(CreatureData data, StandardRecords std)
    {
        //DEFAULT_MATS.TryResolve(state.LinkCache, out var existingMaterials);
        //if (existingMaterials == null) throw new CoreRecordMissing(DEFAULT_MATS.FormKey);

        var matsFormList = std.PatchMod.FormLists.AddNew();
        if (matsFormList == null) throw new InvalidOperationException();

        var matsPerfectLvld = std.PatchMod.LeveledItems.AddNew();
        if (matsPerfectLvld == null) throw new InvalidOperationException();

        matsFormList.EditorID = $"_DS_FL_Mats_{data.InternalName}";
        matsPerfectLvld.EditorID = $"_DS_FL_Mats_Perfect_{data.InternalName}";

        for (int index = 0; index < data.Prototype.Materials.Count; index++)
        {
            var skillLevel = data.Prototype.Materials[index];
            var mat = std.PatchMod.LeveledItems.AddNew();
            if (mat == null) throw new InvalidOperationException();

            mat.EditorID = $"{matsFormList.EditorID}{index:D2}";
            var entries = mat.Entries = new();

            foreach (var itemEntry in skillLevel.Items) {
                IFormLinkGetter<IItemGetter> item = new FormLink<IItemGetter>(itemEntry.Key.FormKey);
                item = std.FormLinkSubstitution(item);
                entries.Add(CreateLeveledItemEntry(item, 1, itemEntry.Value));
            }

            matsFormList.Items.Add(mat);
        }

        // Put the materials formlist in the correct formlist.
        std.GetCCFor(data)._DS_FL_Mats__Lists.Items.Add(matsFormList);
        std.GetCCFor(data)._DS_FL_Mats__Perfect.Items.Add(matsPerfectLvld);

        return matsFormList;
    }

    /// <summary>
    /// Turns a FormList of LeveledItems into a list of MaterialLevels.
    /// The inverse of CreateMaterials.
    /// </summary>
    /// 
    static List<MaterialLevel> RecreateMaterials(IFormListGetter matsFormList, StandardRecords std)
    {
        List<MaterialLevel> materials = new();
        //Console.WriteLine($"===Recreating materials from {matsFormList}, {matsFormList.Items.Count} in formlist.===");
        //Console.WriteLine("======" + matsFormList.Items.ToArray().Pretty());

        foreach (var level in matsFormList.Items)
        {
            var asLeveled = level.FormKey.ToLinkGetter<ILeveledItemGetter>().Resolve(std.LinkCache);

            MaterialLevel skillLevel = new();
            materials.Add(skillLevel);

            var entries = asLeveled.Entries;
            //Console.WriteLine($"======Recreating materials from {level}, {entries?.Count} in leveledlist.===");

            if (entries is not null)
            {
                foreach (var entry in entries)
                {
                    if (entry.Data is not null && entry.Data.Reference is not null)
                        skillLevel.Items[entry.Data.Reference] = entry.Data.Count;
                }
            }
        }

        return materials;
    }


    static IFormListGetter CreatePelts(CreatureData data, StandardRecords std)
    {
        var pelts = std.PatchMod.FormLists.AddNew();
        if (pelts == null) throw new InvalidOperationException();
        pelts.EditorID = $"_DS_FL_Pelts{data.InternalName}";

        if (!KnownPelts.ContainsKey(data.Prototype))
        {
            var standard = GetDefaultPelt(data, std);
            bool createdDefaultPelt = standard is not null;
            if (standard == null) standard = CreateDefaultPelt(data, std);
 
            if (std.Settings.DebuggingMode) Write.Action(3, "Creating new Pelt records in Misc.");

            var poor = std.PatchMod.MiscItems.DuplicateInAsNewRecord(standard);
            var fine = std.PatchMod.MiscItems.DuplicateInAsNewRecord(standard);
            var flawless = std.PatchMod.MiscItems.DuplicateInAsNewRecord(standard);

            if (std.Settings.DebuggingMode) Write.Success(3, "Created \"poor\".");
            if (std.Settings.DebuggingMode) Write.Success(3, "Created \"standard\".");
            if (std.Settings.DebuggingMode) Write.Success(3, "Created \"flawless\".");

            String edid = $"_DS_Pelt_{data.InternalName ?? data.InternalName}";
            poor.EditorID = $"{edid}_00";
            fine.EditorID = $"{edid}_02";
            flawless.EditorID = $"{edid}_03";

            poor.Name = $"{standard.Name} (poor)";
            fine.Name = $"{standard.Name} (fine)";
            flawless.Name = $"{standard.Name} (flawless)";

            // Store the pelt value to the Hunterborn quest script.
            std.GetCCFor(data).PeltValues.Data.Add((int)poor.Value);

            // Adjust the values of the non-standard pelts.
            poor.Value /= 2;
            fine.Value *= 2;
            flawless.Value *= 20;
            KnownPelts[data.Prototype] = new IFormLinkGetter<IMiscItemGetter>[4] { poor.ToLink(), standard.ToLink(), fine.ToLink(), flawless.ToLink() };

            if (createdDefaultPelt) CreatePeltRecipes(data, (poor, standard, fine, flawless), createdDefaultPelt, std);
        }

        // Add the pelts to the pelts formlist.
        pelts.Items.AddRange(KnownPelts[data.Prototype]);

        // Put the pelts formlist in the correct formlist.
        std.GetCCFor(data)._DS_FL_PeltLists.Items.Add(pelts);
        return pelts;
    }

    /// <summary>
    /// Checks the creature's DeathItem for anything whose internalName or editorID contains a string-match
    /// that indicates it's probably a pelt. Returns the pelt.
    /// 
    /// </summary>
    /// <returns>A pair consisting of the pelt Item and a flag indicating whether it was created.</returns>
    /// 
    static IMiscItemGetter? GetDefaultPelt(CreatureData data, StandardRecords std)
    {
        if (!data.Prototype.DefaultPelt.IsNull) return data.Prototype.DefaultPelt.Resolve(std.LinkCache);
        var defaultPelt = GetDefaultPelt(data.DeathItem, std);
        if (defaultPelt is IMiscItemGetter pelt) return pelt;
        else return null;
    }

    /// <summary>
    /// Checks the creature's DeathItem for anything whose internalName or editorID contains a string-match
    /// that indicates it's probably a pelt. Returns the pelt.
    /// 
    /// If no default pelt was found, one will be created and added to the patch.
    /// 
    /// </summary>
    /// 
    static IMiscItemGetter? GetDefaultPelt(ILeveledItemGetter data, StandardRecords std)
    {
        var entries = data.Entries;
        if (entries == null) return null;

        foreach (var entry in entries)
        {
            var entryItem = entry.Data?.Reference.TryResolve(std.LinkCache);
            var edid = entryItem?.EditorID ?? "";
            if (entryItem == null || edid == null) continue;

            if (DefaultPeltRegex.Matches(edid).Any())
            {
                if (entryItem is ILeveledItemGetter lvld)
                {
                    if (std.Settings.DebuggingMode) Write.Action(4, $"Pelt search recursing into {DeathItemNamerFallback(lvld)}");
                    if (lvld.Entries is not null && lvld.Entries.Count == 1 && GetDefaultPelt(lvld, std) is IMiscItemGetter subItem)
                        return subItem;
                }
                else if (entryItem is IMiscItemGetter item)
                {
                    if (std.Settings.DebuggingMode) Write.Action(4, $"Pelt search found {ItemNamerFallback(item)}");
                    return item;
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Matcher for pre-existing pelts items.
    /// </summary>
    static readonly Regex DefaultPeltRegex = new("Pelt|Hide|Skin|Fur|Wool|Leather", RegexOptions.IgnoreCase);

    /// <summary>
    /// Create a new default pelt for a creature using a pre-existing pelt as a template.
    /// 
    /// </summary>
    /// <param internalName="data"></param>
    /// <param internalName="std"></param>
    /// <returns></returns>
    /// <exception cref="CoreRecordMissing"></exception>
    /// <exception cref="InvalidOperationException"></exception>
    static MiscItem CreateDefaultPelt(CreatureData data, StandardRecords std)
    {
        if (std.Settings.DebuggingMode) Write.Action(3, $"Creating new pelt for {data.InternalName}");

        DEFAULT_PELT.TryResolve(std.LinkCache, out var existingPelt);
        if (existingPelt == null) throw new CoreRecordMissing(DEFAULT_PELT);

        var newPelt = std.PatchMod.MiscItems.DuplicateInAsNewRecord(DEFAULT_PELT.Resolve(std.LinkCache));
        if (newPelt == null) throw new InvalidOperationException();

        newPelt.EditorID = $"_DS_Pelt_{data.InternalName}_01";
        newPelt.Name = $"{data.Prototype.ProperName} Pelt";

        // @TODO Fill this in with something better.
        newPelt.Value = (uint)data.Prototype.CarcassValue / 2;
        
        if (std.Settings.DebuggingMode) Write.Success(3, $"Created new default Pelt {newPelt}");

        return newPelt;
    }

    /// <summary>
    /// Checks the creature's DeathItem for anything whose internalName or editorID contains a string-match
    /// that indicates it's probably meat. Returns the meat.
    /// 
    /// If no meat was found, one will be created and added to the patch.
    /// 
    /// </summary>
    /// 
    static IItemGetter? GetDefaultMeat(CreatureData data, StandardRecords std)
    {
        if (!data.Prototype.Meat.IsNull) return data.Prototype.Meat.Resolve(std.LinkCache);
        else
        {
            var defaultMeat = GetDefaultMeat(data.DeathItem, std);
            if (defaultMeat is IItemGetter meat) return meat;
            else if (data.Prototype.CreateDefaultMeat) return CreateDefaultMeat(data, std);
            else return null;
        }
    }

    /// <summary>
    /// Checks the creature's DeathItem for anything whose internalName or editorID contains a string-match
    /// that indicates it's probably a meat. Returns the meat.
    /// 
    /// If no meat was found, one will be created and added to the patch.
    /// 
    /// </summary>
    /// 
    static IItemGetter? GetDefaultMeat(ILeveledItemGetter data, StandardRecords std)
    {
        var entries = data.Entries;
        if (entries == null) return null;

        foreach (var entry in entries)
        {
            var entryItem = entry.Data?.Reference.TryResolve(std.LinkCache);
            var edid = entryItem?.EditorID ?? "";
            if (entryItem == null || edid == null) continue;

            if (DefaultMeatRegex.Matches(edid).Any())
            {
                if (entryItem is ILeveledItemGetter lvld)
                {
                    if (std.Settings.DebuggingMode) Write.Action(4, $"Meat search recursing into {DeathItemNamerFallback(lvld)}");
                    if (lvld.Entries is not null && lvld.Entries.Count == 1 && GetDefaultMeat(lvld, std) is IItemGetter subItem)
                        return subItem;
                }
                else if (entryItem is IItemGetter item)
                {
                    if (std.Settings.DebuggingMode) Write.Action(4, $"Meat search found {ItemNamerFallback(item)}");
                    return item;
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Matcher for pre-existing meat items.
    /// </summary>
    static readonly Regex DefaultMeatRegex = new("Meat|Flesh", RegexOptions.IgnoreCase);

    /// <summary>
    /// Create a new default meat for a creature using a pre-existing meat as a template.
    /// Also creates cooked meat and jerky but they are not returned.
    /// 
    /// </summary>
    /// <param internalName="data"></param>
    /// <param internalName="std"></param>
    /// <returns></returns>
    /// <exception cref="CoreRecordMissing"></exception>
    /// <exception cref="InvalidOperationException"></exception>
    static IItemGetter CreateDefaultMeat(CreatureData data, StandardRecords std)
    {
        if (std.Settings.DebuggingMode) Write.Action(3, $"Creating new meats for {data.InternalName}");

        DEFAULT_MEAT.TryResolve(std.LinkCache, out var existingMeat);
        if (existingMeat == null) throw new CoreRecordMissing(DEFAULT_MEAT);

        var newMeat = std.PatchMod.Ingestibles.DuplicateInAsNewRecord(existingMeat);
        var newCooked = std.PatchMod.Ingestibles.DuplicateInAsNewRecord(existingMeat);
        var newJerky = std.PatchMod.Ingestibles.DuplicateInAsNewRecord(existingMeat);

        if (newMeat == null) throw new InvalidOperationException();
        if (newCooked == null) throw new InvalidOperationException();
        if (newJerky == null) throw new InvalidOperationException();

        newMeat.EditorID = $"_DS_Meat_{data.InternalName}";
        newCooked.EditorID = $"_DS_Meat_{data.InternalName}";
        newJerky.EditorID = $"_DS_Meat_{data.InternalName}";

        newMeat.Name = $"{data.Prototype.ProperName} Meat (raw)";
        newCooked.Name = $"{data.Prototype.ProperName} Meat (cooked)";
        newJerky.Name = $"{data.Prototype.ProperName} Jerky";

        if (newMeat.Keywords == null) newMeat.Keywords = new ();
        if (newCooked.Keywords == null) newCooked.Keywords = new();
        if (newJerky.Keywords == null) newJerky.Keywords = new();

        if (!newMeat.HasKeyword(_DS_KW_Food_Raw)) newMeat.Keywords.Add(_DS_KW_Food_Raw);
        if (!newMeat.HasKeyword(Skyrim.Keyword.VendorItemFoodRaw)) newMeat.Keywords.Add(Skyrim.Keyword.VendorItemFoodRaw);

        if (std.CacoInstalled)
        {
            if (!newMeat.HasKeyword(VendorItemFoodMeat)) newMeat.Keywords.Add(VendorItemFoodMeat);
            if (!newMeat.HasKeyword(VendorItemFoodUncooked)) newMeat.Keywords.Add(VendorItemFoodUncooked);
            if (!newMeat.HasKeyword(LastSeedEnableKeywordSpoil)) newMeat.Keywords.Add(LastSeedEnableKeywordSpoil);
            if (!newCooked.HasKeyword(VendorItemFoodMeat)) newCooked.Keywords.Add(VendorItemFoodMeat);
            if (!newCooked.HasKeyword(VendorItemFoodCooked)) newCooked.Keywords.Add(VendorItemFoodCooked);
            if (!newJerky.HasKeyword(VendorItemFoodMeat)) newJerky.Keywords.Add(VendorItemFoodMeat);
            if (!newJerky.HasKeyword(VendorItemFoodPreserved)) newJerky.Keywords.Add(VendorItemFoodPreserved);
        }

        if (std.LastSeedInstalled)
        {
            if (!newMeat.HasKeyword(VendorItemFoodMeat)) newMeat.Keywords.Add(VendorItemFoodMeat);
            if (!newMeat.HasKeyword(_Seed_PO3_Detection_MeatRaw)) newMeat.Keywords.Add(_Seed_PO3_Detection_MeatRaw);
            if (!newCooked.HasKeyword(VendorItemFoodMeat)) newCooked.Keywords.Add(VendorItemFoodMeat);
            if (!newCooked.HasKeyword(_Seed_PO3_Detection_MeatCooked)) newCooked.Keywords.Add(_Seed_PO3_Detection_MeatCooked);
            if (!newJerky.HasKeyword(VendorItemFoodMeat)) newJerky.Keywords.Add(VendorItemFoodMeat);
            if (!newJerky.HasKeyword(_Seed_PO3_Detection_Preserved)) newJerky.Keywords.Add(_Seed_PO3_Detection_Preserved);
            if (!newJerky.HasKeyword(_Seed_PO3_Detection_Salted)) newJerky.Keywords.Add(_Seed_PO3_Detection_Salted);
            if (!newJerky.HasKeyword(VendorItemFoodPreserved)) newJerky.Keywords.Add(VendorItemFoodPreserved);
            if (!newJerky.HasKeyword(VendorItemFoodSalted)) newJerky.Keywords.Add(VendorItemFoodSalted);
        }

        // @TODO Fill this in with something better.
        newMeat.Value = (uint)data.Prototype.CarcassValue / 5;

        // Make recipes.
        CreateMeatRecipes(data, (newMeat, newCooked, newJerky), std);

        if (std.Settings.DebuggingMode) Write.Success(3, $"Created new meats: {newMeat}, {newCooked}, {newJerky}");

        return newMeat;
    }

    /// <summary>
    /// Create a new discards formlist for a monster.
    /// Dicards are also called "negativetreasure" internally.
    /// </summary>
    /// 
    static void CreateDiscards(CreatureData data, StandardRecords std)
    {
        var discards = std.PatchMod.FormLists.AddNew();
        if (discards == null) throw new InvalidOperationException();

        discards.EditorID = $"_DS_FL_Discard{data.InternalName}_01";
        discards.Items.AddRange(data.Prototype.Discard);
        std.Monsters.Discards.Objects.Add(CreateProperty(discards.ToLink()));
    }

    /// <summary>
    /// Create a new DeathDescriptor for a creature.
    /// This is a LeveledItem that gets added to a carcass's inventory when the
    /// player interacts with the carcass for the first time.
    /// 
    /// The Tokens it adds are what determine which actions the player can take.
    /// 
    /// </summary>
    /// 
    static ILeveledItemGetter CreateDeathDescriptor(CreatureData data, StandardRecords std, IFormListGetter pelts, FormList mats)
    {
        // Create the new descriptor.
        LeveledItem deathDescriptor = std.PatchMod.LeveledItems.AddNew();
        deathDescriptor.EditorID = $"_DS_DeathItem_{data.InternalName}";
        deathDescriptor.Entries = new();

        // If the pelts FormList isn't empty, then harvesting pelts is enabled.
        if (pelts.Items is not null && pelts.Items.Count > 0)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Pelt, 1, 1));

        // If the materials FormList isn't empty, then harvesting materials is enabled.
        if (mats.Items is not null && mats.Items.Count > 0)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Mat, 1, 1));

        // Animals need to be cleaned. Monsters apparently not?
        if (data.IsAnimal)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Carcass_Clean, 1, 1));

        // If the Meat field in the PluginEntry isn't null then harvesting meat is enabled.
        if (!data.Prototype.Meat.IsNull)
        {
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Meat, 1, 1));
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Meat_Fresh, 1, 1));
        }

        // If the Venom or Blood fields in the PluginEntry aren't null then harvesting venom and/or blood is enabled.
        if (data.IsMonster)
        {
            if (!data.Prototype.Venom.IsNull)
                deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Venom, 1, 1));
            if (!data.Prototype.BloodType.IsNull)
                deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Venom, 1, 1));
        }

        // Add the creature's actual DeathItem to the appropriate FormList.
        // When hunterborn starts up, the creature's Token will be added to this formlist.
        // THIS IS HOW HUNTERBORN RECOGNIZES HARVESTABLE CREATURES.
        std.GetCCFor(data)._DS_FL_DeathItems.Items.Add(data.DeathItem);

        // Add the DeathDescriptor to the quest array property.
        std.GetCCFor(data).DeathDescriptors.Objects.Add(new() { Object = deathDescriptor.ToLink() });

        return deathDescriptor;
    }

    /// <summary>
    /// Creates leather and pelt recipes for created leathers.
    /// </summary>
    /// 
    static void CreatePeltRecipes(CreatureData data, (IMiscItemGetter, IMiscItemGetter, IMiscItemGetter, IMiscItemGetter) pelts, bool createdStandardPelt, StandardRecords std)
    {
        if (data.Prototype.FurPlateCount.Length >= 3)
        {
            if (createdStandardPelt)
            {
                var standard = std.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_PELT_STD_RECIPE.Resolve(std.LinkCache));
                standard.CreatedObjectCount = (ushort)data.Prototype.PeltCount[1];
                if (standard.Items?[0].Item is ContainerItem containerItem2) containerItem2.Item = pelts.Item2.ToLink();
                if (standard.Conditions?[4].Data is ConditionData data2) data2.Reference = pelts.Item2.ToLink();
                standard.EditorID = $"_DS_Recipe_Pelt_{data.InternalName}_01";
            }

            var poor = std.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_PELT_POOR_RECIPE.Resolve(std.LinkCache));
            var fine = std.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_PELT_FINE_RECIPE.Resolve(std.LinkCache));
            var flawless = std.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_PELT_FLAWLESS_RECIPE.Resolve(std.LinkCache));

            poor.EditorID = $"_DS_Recipe_Pelt_{data.InternalName}_00";
            fine.EditorID = $"_DS_Recipe_Pelt_{data.InternalName}_02";
            flawless.EditorID = $"_DS_Recipe_Pelt_{data.InternalName}_03";

            poor.CreatedObjectCount = (ushort)data.Prototype.PeltCount[0];
            fine.CreatedObjectCount = (ushort)data.Prototype.PeltCount[2];
            flawless.CreatedObjectCount = (ushort)data.Prototype.PeltCount[2];

            if (poor.Items?[0].Item is ContainerItem containerItem1) containerItem1.Item = pelts.Item1.ToLink();
            if (fine.Items?[0].Item is ContainerItem containerItem3) containerItem3.Item = pelts.Item3.ToLink();
            if (flawless.Items?[0].Item is ContainerItem containerItem4) containerItem4.Item = pelts.Item4.ToLink();

            if (poor.Conditions?[4].Data is ConditionData data1) data1.Reference = pelts.Item1.ToLink();
            if (fine.Conditions?[4].Data is ConditionData data3) data3.Reference = pelts.Item3.ToLink();
            if (flawless.Conditions?[4].Data is ConditionData data4) data4. Reference = pelts.Item4.ToLink();

            fine.CreatedObject = pelts.Item1.ToNullableLink();
            flawless.CreatedObject = pelts.Item2.ToNullableLink();

            if (std.Settings.DebuggingMode) Write.Success(3, $"Created new tanning recipes.");
        }

        if (data.Prototype.FurPlateCount.Length >= 3)
        {
            var poor = std.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_FURS_POOR_RECIPE.Resolve(std.LinkCache));
            var standard = std.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_FURS_STD_RECIPE.Resolve(std.LinkCache));
            var fine = std.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_FURS_FINE_RECIPE.Resolve(std.LinkCache));

            poor.EditorID = $"HB_Recipe_FurPlate_{data.InternalName}_00";
            standard.EditorID = $"HB_Recipe_FurPlate_{data.InternalName}_01";
            fine.EditorID = $"HB_Recipe_FurPlate_{data.InternalName}_02";

            poor.CreatedObjectCount = (ushort) data.Prototype.FurPlateCount[0];
            standard.CreatedObjectCount = (ushort) data.Prototype.FurPlateCount[1];
            fine.CreatedObjectCount = (ushort) data.Prototype.FurPlateCount[2];

            if (poor.Items?[0].Item is ContainerItem containerItem1) containerItem1.Item = pelts.Item1.ToLink();
            if (standard.Items?[0].Item is ContainerItem containerItem2) containerItem2.Item = pelts.Item2.ToLink();
            if (fine.Items?[0].Item is ContainerItem containerItem3) containerItem3.Item = pelts.Item3.ToLink();

            if (poor.Conditions?[4].Data is ConditionData data1) data1.Reference = pelts.Item1.ToLink();
            if (standard.Conditions?[4].Data is ConditionData data2) data2.Reference = pelts.Item2.ToLink();
            if (fine.Conditions?[4].Data is ConditionData data3) data3.Reference = pelts.Item3.ToLink();

            if (std.Settings.DebuggingMode) Write.Success(3, $"Created new fur-plate recipes.");
        }
    }

    /// <summary>
    /// Creates standard, campfire, primitive cooking, and jerky recipes for created meats.
    /// </summary>
    /// 
    static void CreateMeatRecipes(CreatureData data, (IItemGetter, IConstructibleGetter, IConstructibleGetter) meats, StandardRecords std)
    {
        var recipeCooked = std.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_CHARRED_RECIPE.Resolve(std.LinkCache));
        var recipeCampfire = std.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_CAMPFIRE_RECIPE.Resolve(std.LinkCache));
        var recipePrimitive = std.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_PRIMITIVE_RECIPE.Resolve(std.LinkCache));
        var recipeJerky = std.PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_JERKY_RECIPE.Resolve(std.LinkCache));

        (var meat, var cooked, var jerky) = meats;

        recipeCooked.EditorID = $"_DS_Recipe_Food_CharredMeat_{data.InternalName}";
        recipeCampfire.EditorID = $"HB_Recipe_FireFood_CharredMeat_{data.InternalName}";
        recipePrimitive.EditorID = $"_DS_Recipe_Food_Primitive_CharredMeat_{data.InternalName}";
        recipeJerky.EditorID = $"_DS_Recipe_Food_{data.InternalName}Jerky";

        if (recipeCooked.Items?[0].Item is ContainerItem containerItem0) containerItem0.Item = meat.ToLink();
        if (recipeCampfire.Items?[0].Item is ContainerItem containerItem1) containerItem1.Item = meat.ToLink();
        if (recipePrimitive.Items?[0].Item is ContainerItem containerItem2) containerItem2.Item = meat.ToLink();
        if (recipeJerky.Items?[1].Item is ContainerItem containerItem3) containerItem3.Item = meat.ToLink();

        if (recipeCooked.Conditions?[1].Data is ConditionData data0) data0.Reference = meat.ToLink();
        if (recipeJerky.Conditions?[3].Data is ConditionData data3) data3.Reference = meat.ToLink();

        recipeCooked.CreatedObject = cooked.ToNullableLink();
        recipeJerky.CreatedObject = jerky.ToNullableLink();

        if (std.Settings.DebuggingMode) Write.Success(3, $"Created new meat recipes.");
    }

    /// <summary>
    /// To be recognized as a creature by the patcher, an Npc must not belong to any of these factions.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    readonly static private HashSet<FormLink<IFactionGetter>> ForbiddenFactions = new() {
        Dawnguard.Faction.DLC1VampireFaction,
        Dragonborn.Faction.DLC2AshSpawnFaction,
        Skyrim.Faction.DragonPriestFaction,
        Skyrim.Faction.DraugrFaction,
        Skyrim.Faction.DwarvenAutomatonFaction,
        Skyrim.Faction.IceWraithFaction,
        Dawnguard.Faction.SoulCairnFaction,
        Skyrim.Faction.VampireFaction,
        Skyrim.Faction.WispFaction
    };

    /// <summary>
    /// To be recognized as a creature by the patcher, an Npc must not have any of these keywords.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    readonly static private HashSet<FormLink<IKeywordGetter>> ForbiddenKeywords = new() {
        Skyrim.Keyword.ActorTypeGhost,
        Skyrim.Keyword.ActorTypeNPC
    };

    /// <summary>
    /// Voices of creatures. To be recognized as a creature by the patcher, an Npc must have a voiceType from
    /// this list.
    /// 
    /// VoiceTypes from addons will get added to this list at runtime.
    /// Isn't that forward thinking? Why don't the other Forbidden/Allowed lists get
    /// populated from addons?
    /// 
    /// </summary>
    readonly static private HashSet<IFormLinkGetter<IVoiceTypeGetter>> AllowedVoices = new() {
        Skyrim.VoiceType.CrBearVoice,
        Skyrim.VoiceType.CrChickenVoice,
        Skyrim.VoiceType.CrCowVoice,
        Skyrim.VoiceType.CrDeerVoice,
        Skyrim.VoiceType.CrDogVoice,
        Dawnguard.VoiceType.CrDogHusky,
        Skyrim.VoiceType.CrFoxVoice,
        Skyrim.VoiceType.CrGoatVoice,
        Skyrim.VoiceType.CrHareVoice,
        Skyrim.VoiceType.CrHorkerVoice,
        Skyrim.VoiceType.CrHorseVoice,
        Skyrim.VoiceType.CrMammothVoice,
        Skyrim.VoiceType.CrMudcrabVoice,
        Skyrim.VoiceType.CrSabreCatVoice,
        Skyrim.VoiceType.CrSkeeverVoice,
        Skyrim.VoiceType.CrSlaughterfishVoice,
        Skyrim.VoiceType.CrWolfVoice,
        Dragonborn.VoiceType.DLC2CrBristlebackVoice,
        Skyrim.VoiceType.CrChaurusVoice,
        Skyrim.VoiceType.CrFrostbiteSpiderVoice,
        Skyrim.VoiceType.CrFrostbiteSpiderGiantVoice,
        Skyrim.VoiceType.CrSprigganVoice,
        Skyrim.VoiceType.CrTrollVoice,
        Skyrim.VoiceType.CrWerewolfVoice,
        Skyrim.VoiceType.CrDragonVoice,
        Dawnguard.VoiceType.CrChaurusInsectVoice
    };

    /// <summary>
    /// A list of EditorIDs of creatures that should never be processed.
    /// I wish this was explained.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    static readonly private List<String> ForbiddenNpcEditorIds = new() { "HISLCBlackWolf", "BSKEncRat" };

    /// <summary>
    /// A list of DeathItems that should never be processed. 
    /// Creatures with one of these DeathItems should be ignored by Hunterborn and by this patcher.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    private static readonly List<FormLink<ILeveledItemGetter>> ForbiddenDeathItems = new() {
        Skyrim.LeveledItem.DeathItemDragonBonesOnly,
        Skyrim.LeveledItem.DeathItemVampire,
        Skyrim.LeveledItem.DeathItemForsworn,
        Dawnguard.LeveledItem.DLC1DeathItemDragon06,
        Dawnguard.LeveledItem.DLC1DeathItemDragon07,
        new(new FormKey(new("Skyrim Immersive Creatures Special Edition", type : ModType.Plugin), 0x11B217))
    };

    static private bool IsCreature(INpcGetter npc) {
        var deathItem = npc.DeathItem;
        var edid = npc.EditorID;

        //var edidLink = edid is not null ? new EDIDLink<IRaceGetter>(edid) : null;

        if (edid is not null && HasForbiddenEditorId(edid)) return false;
        else if (deathItem == null) return false;
        else if (HasForbiddenDeathItem(deathItem)) return false;
        else if (HasForbiddenKeyword(npc)) return false;
        else if (HasForbiddenFaction(npc)) return false;
        else if (!HasAllowedVoice(npc)) return false;
        else return true;
    }

    static private bool HasForbiddenEditorId(String editorId) => ForbiddenNpcEditorIds.Any(edid => edid.EqualsIgnoreCase(editorId));

    static private bool HasForbiddenFaction(INpcGetter creature) =>
        creature.Factions.Any(placement => ForbiddenFactions.Contains(placement.Faction));

    static private bool HasForbiddenKeyword(INpcGetter creature) =>
        creature.Keywords?.Any(keyword => ForbiddenKeywords.Contains(keyword)) ?? false;

    static private bool HasAllowedVoice(INpcGetter creature) => AllowedVoices.Contains(creature.Voice);

    static private bool HasForbiddenDeathItem(IFormLinkGetter<ILeveledItemGetter> deathItem) => ForbiddenDeathItems.Contains(deathItem);

    /// <summary>
    /// The quest and formlists needed by the patching methods, resolved and ready.
    /// </summary>
    readonly record struct StandardRecords(
        Settings.Settings Settings,
        bool CacoInstalled,
        bool LastSeedInstalled,
        Func<IFormLinkGetter<IItemGetter>, IFormLinkGetter<IItemGetter>> FormLinkSubstitution,
        Func<IItemGetter, IItemGetter> ItemSubstitution,
        Quest _DS_Hunterborn,
        ILinkCache<ISkyrimMod, ISkyrimModGetter> LinkCache,
        ISkyrimMod PatchMod,
        AnimalClass<FormList> Animals,
        MonsterClass<FormList> Monsters,
        List<CreatureClass<FormList>> CreatureClasses)
    {

        /// <summary>
        /// Retrieves the CreatureClass for a specified Plugins.
        /// </summary>
        /// <param internalName="d">The Plugins whose CreatureClass should be returned.</param>
        /// <returns>The CreatureClass.</returns>
        public CreatureClass<FormList> GetCCFor(CreatureData d) => GetCCFor(d.Prototype.Type);

        /// <summary>
        /// Retrieves the CreatureClass for a specified EntryType.
        /// </summary>
        /// <param internalName="d">The EntryType whose CreatureClass should be returned.</param>
        /// <returns>The CreatureClass.</returns>
        public CreatureClass<FormList> GetCCFor(EntryType t) => t switch
        {
            EntryType.Animal => Animals,
            EntryType.Monster => Monsters,
            _ => throw new InvalidOperationException("Unknown CreatureClass requested."),
        };
    }

    /// <summary>
    /// The quest and formlists from the parent plugin, resolved and ready to go.
    /// </summary>
    readonly record struct ParentRecords(
        IQuestGetter _DS_Hunterborn,
        AnimalClass<IFormListGetter> Animals,
        MonsterClass<IFormListGetter> Monsters,
        List<CreatureClass<IFormListGetter>> CreatureClasses)
    {

        /// <summary>
        /// Retrieves the CreatureClass for a specified Plugins.
        /// </summary>
        /// <param internalName="d">The Plugins whose CreatureClass should be returned.</param>
        /// <returns>The CreatureClass.</returns>
        public CreatureClass<IFormListGetter> GetCCFor(CreatureData d) => GetCCFor(d.Prototype.Type);

        /// <summary>
        /// Retrieves the CreatureClass for a specified EntryType.
        /// </summary>
        /// <param internalName="d">The EntryType whose CreatureClass should be returned.</param>
        /// <returns>The CreatureClass.</returns>
        public CreatureClass<IFormListGetter> GetCCFor(EntryType t) => t switch
        {
            EntryType.Animal => Animals,
            EntryType.Monster => Monsters,
            _ => throw new InvalidOperationException("Unknown CreatureClass requested."),
        };
    }

    /// <summary>
    /// FormLists and script properties needed for patching creatures.
    /// Parameterized by whether it contains FormLists (for patching) or IFormListGetter 
    /// (for examining the parent plugin's records).
    /// </summary>
    record CreatureClass<T>(
        T _DS_FL_Mats__Lists,
        T _DS_FL_Mats__Perfect,
        T _DS_FL_PeltLists,
        T _DS_FL_DeathItems,
        T _DS_FL_DeathItemTokens,
        ScriptObjectListProperty Switches,
        ScriptObjectListProperty DeathDescriptors,
        ScriptObjectListProperty MeatType,
        ScriptObjectListProperty SharedDeathItems,
        ScriptStringListProperty RaceIndex,
        ScriptFloatListProperty MeatWeights,
        ScriptIntListProperty PeltValues,
        ScriptIntListProperty CarcassSizes
        ) where T : IFormListGetter;

    /// <summary>
    /// FormLists and script properties needed for patching Animals,
    /// which is just the FormList of carcasses.
    /// </summary>
    record AnimalClass<T>(
        CreatureClass<T> proto,
        ScriptObjectListProperty CarcassMessages,
        T _DS_FL_CarcassObjects) : CreatureClass<T>(proto) where T : IFormListGetter;

    /// <summary>
    /// FormLists and script properties needed for patching Monsters,
    /// which includes blood, venom, and discards.
    /// </summary>
    record MonsterClass<T>(
        CreatureClass<T> proto, 
        ScriptObjectListProperty BloodItems, 
        ScriptObjectListProperty VenomItems, 
        ScriptObjectListProperty Discards) : CreatureClass<T>(proto) where T : IFormListGetter;

    /// <summary>
    /// Some of the methods in this class require the resolved Hunterborn Quest and resolved FormLists.
    /// This resolves them, adds them to the patch, and packs them into a Record.
    /// 
    /// Stores the Settings object too.
    /// </summary>
    static StandardRecords CreateStandardRecords(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, Settings.Settings settings)
    {
        Quest hunterbornQuest = state.PatchMod.Quests.GetOrAddAsOverride(_DS_Hunterborn.Resolve(state.LinkCache));
        //if (settings.DebuggingMode) QueryImportantProperties(hunterbornQuest);

        var animals = new AnimalClass<FormList>(new(
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Lists.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Lists)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Perfect.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Perfect)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_PeltLists.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_PeltLists)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItems.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItems)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItemTokens.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItemTokens)),

                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "ActiveAnimalSwitches"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "DeathItemLI"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "MeatTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "SharedDeathItems"),
                    GetProperty<ScriptStringListProperty>(hunterbornQuest, "_DS_HB_Animals", "AnimalIndex"),
                    GetProperty<ScriptFloatListProperty>(hunterbornQuest, "_DS_HB_Animals", "AllMeatWeights"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Animals", "DefaultPeltValues"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Animals", "CarcassSizes")),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_MAIN", "FreshCarcassMsgBoxes"),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_CarcassObjects.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_CarcassObjects)));

        var monsters = new MonsterClass<FormList>(new(
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Lists_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Lists_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Perfect_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Perfect_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_PeltLists_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_PeltLists_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItems_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItems_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItemTokens_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItemTokens_Monsters)),

                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "ActiveMonsterSwitches"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "DeathItemLI"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "MeatTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "SharedDeathItems"),
                    GetProperty<ScriptStringListProperty>(hunterbornQuest, "_DS_HB_Monsters", "MonsterIndex"),
                    GetProperty<ScriptFloatListProperty>(hunterbornQuest, "_DS_HB_Animals", "AllMeatWeights"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Monsters", "DefaultPeltValues"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Monsters", "CarcassSizes")),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "BloodTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "VenomTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "NegativeTreasure"));


        StandardRecords std = new(
            settings,
            state.LoadOrder.ContainsKey(CACO_MODKEY),
            state.LoadOrder.ContainsKey(LASTSEED_MODKEY),
            Substitutions.GetCACOSub(state.LoadOrder.ContainsKey(CACO_MODKEY)),
            Substitutions.GetCACOSubResolved(state.LoadOrder.ContainsKey(CACO_MODKEY), state.LinkCache),
            hunterbornQuest,
            state.LinkCache,
            state.PatchMod,
            animals,
            monsters,
            new() { animals, monsters });

        return std;
    }

    /// <summary>
    /// Some of the methods in this class require the resolved Hunterborn Quest and resolved FormLists.
    /// This resolves them from the parent plugin.
    /// </summary>
    static ParentRecords CreateParentRecords(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        IQuestGetter hunterbornQuest = _DS_Hunterborn.ResolveAll(state.LinkCache).Last();

        var animals = new AnimalClass<IFormListGetter>(new(
                    _DS_FL_Mats__Lists.ResolveAll(state.LinkCache).Last(),
                    _DS_FL_Mats__Perfect.ResolveAll(state.LinkCache).Last(),
                    _DS_FL_PeltLists.ResolveAll(state.LinkCache).Last(),
                    _DS_FL_DeathItems.ResolveAll(state.LinkCache).Last(),
                    _DS_FL_DeathItemTokens.ResolveAll(state.LinkCache).Last(),

                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "ActiveAnimalSwitches"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "DeathItemLI"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "MeatTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "SharedDeathItems"),
                    GetProperty<ScriptStringListProperty>(hunterbornQuest, "_DS_HB_Animals", "AnimalIndex"),
                    GetProperty<ScriptFloatListProperty>(hunterbornQuest, "_DS_HB_Animals", "AllMeatWeights"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Animals", "DefaultPeltValues"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Animals", "CarcassSizes")),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_MAIN", "FreshCarcassMsgBoxes"),
                    _DS_FL_CarcassObjects.ResolveAll(state.LinkCache).Last());

        var monsters = new MonsterClass<IFormListGetter>(new(
                    _DS_FL_Mats__Lists_Monsters.ResolveAll(state.LinkCache).Last(),
                    _DS_FL_Mats__Perfect_Monsters.ResolveAll(state.LinkCache).Last(),
                    _DS_FL_PeltLists_Monsters.ResolveAll(state.LinkCache).Last(),
                    _DS_FL_DeathItems_Monsters.ResolveAll(state.LinkCache).Last(),
                    _DS_FL_DeathItemTokens_Monsters.ResolveAll(state.LinkCache).Last(),

                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "ActiveMonsterSwitches"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "DeathItemLI"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "MeatTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "SharedDeathItems"),
                    GetProperty<ScriptStringListProperty>(hunterbornQuest, "_DS_HB_Monsters", "MonsterIndex"),
                    GetProperty<ScriptFloatListProperty>(hunterbornQuest, "_DS_HB_Animals", "AllMeatWeights"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Monsters", "DefaultPeltValues"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Monsters", "CarcassSizes")),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "BloodTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "VenomTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "NegativeTreasure"));


        ParentRecords std = new(
            hunterbornQuest,
            animals,
            monsters,
            new() { animals, monsters });

        return std;
    }

    static ScriptTProperty GetProperty<ScriptTProperty>(IQuestGetter quest, String scriptName, String propertyName) where ScriptTProperty : ScriptProperty
    {
        String questName = quest.Name?.ToString() ?? quest.EditorID ?? "Quest";

        var scriptFilter = ScriptFilter(scriptName);
        var propertyFilter = PropertyFilter(propertyName);

        var script = quest.VirtualMachineAdapter?.Scripts.Where(scriptFilter).FirstOrDefault();
        if (script == null) throw new ScriptMissing(questName, scriptName);

        if (script.Properties.Where(propertyFilter).FirstOrDefault() is not ScriptTProperty property) 
            throw new PropertyMissing(questName, scriptName, propertyName);

        return property;
    }

    /// <summary>
    /// A predicate for matching scripts by internalName.
    /// </summary>
    /// <param internalName="name">The internalName to match.</param>
    /// <returns>A predicate that matches the specified internalName.</returns>
    /// 
    static Func<IScriptEntryGetter, bool> ScriptFilter(String name) => (IScriptEntryGetter s) => name.EqualsIgnoreCase(s?.Name);

    /// <summary>
    /// A predicate for matching script properties by internalName.
    /// </summary>
    /// <param internalName="name">The internalName to match.</param>
    /// <returns>A predicate that matches the specified internalName.</returns>
    /// 
    static Func<IScriptPropertyGetter, bool> PropertyFilter(String name) => (IScriptPropertyGetter s) => name.EqualsIgnoreCase(s?.Name);

    /// <summary>
    /// Convenience method for creating new LeveledItemEntry.
    /// No extra data is added.
    /// </summary>
    /// <param internalName="item">The entryItem.</param>
    /// <param internalName="level">The player level.</param>
    /// <param internalName="count">The entryItem count.</param>
    /// <returns></returns>
    static LeveledItemEntry CreateLeveledItemEntry(IFormLinkGetter<IItemGetter> item, int level, int count) =>
        new() { Data = new LeveledItemEntryData { Reference = (IFormLink<IItemGetter>) item, Level = (short)level, Count = (short)count }};

    /// <summary>
    /// Convenience method for creating new ScriptObjectProperty wrapping a FormLink.
    /// It has to turn the Getter into a Setter internally.
    /// </summary>
    /// <param internalName="item">The FormLinkGetter.</param>
    /// <returns>The ScriptObjectProperty.</returns>
    static ScriptObjectProperty CreateProperty<T>(IFormLinkGetter<T> item) where T : class, ISkyrimMajorRecordGetter
    {
        var link = item.FormKey.ToLink<ISkyrimMajorRecordGetter>();
        return new() { Object = link };
    }

    /// <summary>
    /// Breaks a set of names into parts based on capital letters, spaces, underlines, and dashes.
    /// They are returned as a single set.
    /// 
    /// </summary>
    /// 
    static public HashSet<string> TokenizeNames(IEnumerable<string?> names) => names.Where(n => !n.IsNullOrWhitespace()).SelectMany(TokenizeName).ToHashSet();
    static public HashSet<string> TokenizeNames(params string?[] names) => names.Where(n => !n.IsNullOrWhitespace()).SelectMany(TokenizeName).ToHashSet();


    /// <summary>
    /// Breaks a internalName into parts based on capital letters, spaces, underlines, and dashes.
    /// 
    /// </summary>
    /// 
    static public HashSet<string> TokenizeName(string? name)
    {
        if (name.IsNullOrWhitespace()) return new();

        var filtered = TOKENIZER_FILTER.Replace(name, "");
        var tokens = TOKENIZER_BREAK_SPLITTER.Split(filtered);
        if (tokens == null || tokens.Count() == 0) return new();

        return tokens.SelectMany(t => TOKENIZER_CAMEL_SPLITTER.Split(t)).Where(t => !t.IsNullOrWhitespace()).ToHashSet();
    }

    readonly static private Regex TOKENIZER_FILTER = new("[^A-Za-z0-9 _-]");
    readonly static private Regex TOKENIZER_BREAK_SPLITTER = new("[ _-]");
    readonly static private Regex TOKENIZER_CAMEL_SPLITTER = new("([A-Z]+[a-z0-9]*)");

    static private string NpcNamerFallback(INpcGetter npc, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache) 
        => NpcNamer(npc) ?? NpcRaceNamer(npc, linkCache) ?? FormIDNamer(npc);
    static private string DeathItemNamerFallback(DeathItemGetter deathItem)
        => DeathItemNamer(deathItem) ?? FormIDNamer(deathItem);
    static private string ItemNamerFallback(IItemGetter item)
        => item.EditorID ?? FormIDNamer(item);
    static private string? NpcNamer(INpcGetter npc) => BasicNamer(npc);
    static private string? NpcRaceNamer(INpcGetter npc, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache) => RaceNamer(npc.Race.Resolve(linkCache));
    static private string? NpcDeathItemNamer(INpcGetter npc, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache) => DeathItemNamer(npc.DeathItem?.Resolve(linkCache));
    static private string? RaceNamer(IRaceGetter? race) => BasicNamer(race);
    static private string? DeathItemNamer(DeathItemGetter? deathItem) => deathItem?.EditorID;
    static private string FormIDNamer(ISkyrimMajorRecordGetter? thing) => thing?.FormKey.IDString() ?? "NULL";
    static private string? BasicNamer<T>(T? thing) where T : ISkyrimMajorRecordGetter, INamedGetter  => thing?.Name?.ToString() ?? thing?.EditorID;

}

