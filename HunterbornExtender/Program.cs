namespace HunterbornExtender;
using DynamicData;
using HunterbornExtender.Settings;
using Microsoft.CodeAnalysis;
using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Order;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using static HunterbornExtender.FormKeys;
using DeathItemGetter = Mutagen.Bethesda.Skyrim.ILeveledItemGetter;
using MeatSet = ValueTuple<Mutagen.Bethesda.Skyrim.IItemGetter, Mutagen.Bethesda.Skyrim.IConstructibleGetter, Mutagen.Bethesda.Skyrim.IConstructibleGetter>;
using PatchingRecords = StandardRecords<Mutagen.Bethesda.Skyrim.ISkyrimMod, Mutagen.Bethesda.Skyrim.FormList>;
using PeltSet = ValueTuple<Mutagen.Bethesda.Skyrim.IMiscItemGetter, Mutagen.Bethesda.Skyrim.IMiscItemGetter, Mutagen.Bethesda.Skyrim.IMiscItemGetter, Mutagen.Bethesda.Skyrim.IMiscItemGetter>;
using ViewingRecords = StandardRecords<Mutagen.Bethesda.Skyrim.ISkyrimModGetter, Mutagen.Bethesda.Skyrim.IFormListGetter>;

sealed public class Program
{

    public static Task<int> Main(string[] args)
    {
        return SynthesisPipeline.Instance
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch, new PatcherPreferences()
            {
                ExclusionMods = new List<ModKey>() {
                    new ModKey("HunterbornExtenderPatch.esp", ModType.Plugin),
                },
            })
            .SetTypicalOpen(GameRelease.SkyrimSE, "HunterbornExtenderPatch.esp")
            .SetAutogeneratedSettings("settings", "settings.json", out _settings)
            .Run(args);
    }


    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        /*
        PatcherSettings jsonData;
        try
        {
            WriteLog("Trying to load stored DeathItem selections.");
            jsonData = JSONhandler<PatcherSettings>.LoadJSONFile("settings.json") ?? new();
            WriteLog(1, true, $"Read {jsonData.DeathItems.Count} selections and {jsonData.Plugins.Count} plugins.");
            else throw new InvalidOperationException("No data.");
        }
        catch (Exception ex)
        {
            WriteLog(0, false, "Failed to load stored DeathItem selections.");
            Console.WriteLine("=================================");
            Console.WriteLine(ex);
            Console.WriteLine("=================================");
            return;
        }*/

        //
        // However we do it, this is where we get a List<PluginEntry> from the addon jsons.
        //
        var settings = _settings.Value;
        Program program = new(settings, state);
        program.Initialize();
        program.Patch();
    }

    /// <summary>
    /// Creates a new instance of Program.
    /// </summary>
    /// <param name="settings"></param>
    /// <param name="state"></param>
    public Program(Settings.Settings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state) : this(settings, state.PatchMod, state.LoadOrder, state.LinkCache) { }

    /// <summary>
    /// Creates a new instance of Program.
    /// </summary>
    /// <param name="settings"></param>
    /// <param name="state"></param>
    public Program(Settings.Settings settings, ISkyrimMod patchMod, ILoadOrder<IModListing<ISkyrimModGetter>> loadOrder, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        Settings = settings;
        LinkCache = linkCache;
        LoadOrder = loadOrder;
        PatchMod = patchMod;
        FormLinkSubstitution = SpecialCases.GetCACOSub(LoadOrder.ContainsKey(CACO_MODKEY));
        ItemSubstitution = SpecialCases.GetCACOSubResolved(LoadOrder.ContainsKey(CACO_MODKEY), LinkCache);
    }

    public void Initialize()
    {
        Write.Divider(0);
        Write.Action(0, "Importing plugins.");
        var addonPlugins = LegacyConverter.ImportAndConvert(LinkCache);
        Write.Success(0, $"{addonPlugins.Count} creature types imported.");

        //
        // Resolve and locate all the FormLists and ScriptProperties that need patching.
        // 
        //PatchingRecords std;
        ViewingRecords std_readonly;

        try
        {
            Write.Divider(0);
            Write.Action(0, "Trying to resolve required forms from Hunterborn.esp, and preparing the patch structure.");
            std_readonly = ViewingRecords.CreateViewingInstance(LinkCache);
            Write.Success(0, $"Success.");
        }
        catch (RecordException ex)
        {
            Write.Fail(0, $"Failed to resolve required forms because of unresolved reference [{ex.FormKey} {ex.EditorID}].");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            Write.Fail(0, "Failed to resolve required forms.");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        //
        // Create a List<PluginEntry> for the hard-coded creatures.
        // Merge it into the previous list.
        //
        List<InternalPluginEntry> internalPlugins;

        try
        {
            Write.Divider(0);
            Write.Action(0, "Trying to recreate the hard-coded core plugin from Hunterborn.esp.");
            internalPlugins = RecreateCorePlugins(std_readonly);

            if (internalPlugins.Count > 0)
            {
                Write.Success(0, $"Success: {internalPlugins.Count} hard-coded creature types found.");
            }
            else
            {
                Write.Fail(0, $"No hard-coded creature types found. Check your Hunterborn installation.");
                return;
            }
        }
        catch (RecordException ex)
        {
            Write.Fail(0, $"Failed to recreate core plugin because of unresolved reference [{ex.FormKey} {ex.EditorID}].");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            Write.Fail(0, "Failed to recreate core plugin.");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        List<PluginEntry> plugins = new();
        plugins.AddRange(internalPlugins);
        plugins.AddRange(addonPlugins);
        Settings.Plugins = plugins;
        Write.Success(0, $"Add-on creatures and hard-coded creatures merged; {plugins.Count} total.");

        // 
        // Import allowed and forbidden values from plugins.
        //
        foreach (var plugin in plugins)
        {
            if (!plugin.Voice.IsNull) AllowedVoices.Add(plugin.Voice);
        }

        //
        // Populates the KnownDeathItem, KnownCarcass, and KnownPelts structures.
        //
        /*try
        {
            PopulateKnown(plugins, std_readonly);
        }
        catch (RecordException ex)
        {
            Write.Fail(0, $"Failed to crossreference Hunterborn.esp with the Internal plugins because of reference [{ex.FormKey} {ex.EditorID}].");
            Write.Fail(0, $"THIS MAY INDICATE THAT YOU NEED TO CHECK THE HUNTERBORNEXTENDER SETTINGS.");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            Write.Fail(0, $"Failed to crossreference Hunterborn.esp with the Internal plugins.");
            Write.Fail(0, $"THIS MAY INDICATE THAT YOU NEED TO CHECK THE HUNTERBORNEXTENDER SETTINGS.");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }*/

        //
        // Link death entryItem selection to corresponding creature entry
        //
        foreach (var deathItem in Settings.DeathItemSelections)
        {
            deathItem.Selection = plugins.Where(x => x.Name == deathItem.CreatureEntryName).FirstOrDefault(PluginEntry.SKIP);
        }

        Write.Success(0, $"Imported death plugin support for {plugins.Count} creatures");
        Write.Success(0, $"Imported {Settings.DeathItemSelections.Length} death item selections");

        // Heuristic matching and user selections should already be done.
        //
        // Scan the load order and update the selections.
        // 
        try
        {
            Write.Action(0, $"Running heuristics.");
            var npcs = LoadOrder.PriorityOrder.Npc().WinningOverrides();
            int heuristics = MakeHeuristicSelections(plugins, npcs);
            Write.Success(0, $"Heuristics assigned {heuristics} creatures.");
        }
        catch (RecordException ex)
        {
            Write.Fail(0, $"Missing reference during heuristic: [{ex.FormKey} {ex.EditorID}].");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            Write.Fail(0, $"Error during heuristics.");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
    }

    public void Patch()
    {
        //
        // Resolve and locate all the FormLists and ScriptProperties that need patching.
        // 
        PatchingRecords std;

        try
        {
            Write.Divider(0);
            Write.Action(0, "Trying to resolve required forms from Hunterborn.esp, and preparing the patch structure.");
            std = PatchingRecords.CreatePatchingInstance(PatchMod, LoadOrder, LinkCache);
            Write.Success(0, $"Success.");
        }
        catch (RecordException ex)
        {
            Write.Fail(0, $"Failed to resolve required forms because of unresolved reference [{ex.FormKey} {ex.EditorID}].");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            Write.Fail(0, "Failed to resolve required forms.");
            Write.Fail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        foreach (var selection in Settings.DeathItemSelections)
        {
            var name = selection.CreatureEntryName;
            PluginEntry? prototype = selection.Selection;

            // null is used to indicate "SKIP".
            if (prototype == null)
            {
                if (Settings.DebuggingMode) Write.Title(0, $"(SKIPPED) {name}");
                continue;
            }

            Write.Title(0, $"{name} -> {prototype.Name}");

            try
            {
                var deathItem = LinkCache.Resolve<DeathItemGetter>(selection.DeathItem);
                var data = CreateCreatureData(deathItem, prototype);
                if (Settings.DebuggingMode) Write.Success(1, $"Creating creature Data structure.");

                if (ForbiddenDeathItems.Contains(data.DeathItem.ToLink()))
                {
                    Write.Fail(1, $"Skipped {name}: DeathItem blacklisted.");
                }
                else if (KnownDeathItems.ContainsKey(data.DeathItem))
                {
                    Write.Fail(1, $"Skipped {name}: DeathItem already processed.");
                }
                else
                {
                    KnownDeathItems.Add(data.DeathItem, prototype);
                    AddRecordFor(data, std);
                }
            }
            catch (RecordException ex)
            {
                Write.Fail(1, $"Skipped {name}: DeathItem [{ex.FormKey} {ex.EditorID}] could not be resolved");
            }
            catch (DeathItemAlreadyAddedException)
            {
                Write.Fail(1, $"Skipped {name}: DeathItem already processed.");
            }
            catch (NoDeathItemException)
            {
                Write.Fail(1, $"Skipped {name}: No DeathItem.");
            }
            catch (Exception ex)
            {
                Write.Fail(1, $"Skipped {name}: {ex.Message}");
                Console.WriteLine(ex.StackTrace);
            }
        }
    }

    /// <summary>
    /// This should be called from the UI to pre-select the choices for each deathitem.
    /// 
    /// If Settings.ReuseSelections is enabled then selections in the settings will be preferred.
    /// Everything still gets scanned anyway in case the loadorder has changed.
    /// 
    /// The selections array in Settings is replaced with a new one.
    /// 
    /// </summary>
    /// 
    private int MakeHeuristicSelections(List<PluginEntry> plugins, IEnumerable<INpcGetter> npcs)
    {
        // For each DeathItem, there will be a weighted set of plausible Plugins.
        // HeuristicMatcher assigns the weights.
        Dictionary<DeathItemSelection, Dictionary<PluginEntry, int>> selectionWeights = new();
        Dictionary<DeathItemGetter, DeathItemSelection> indexer = new();

        // Tokenize the names of the plugins.
        foreach (var plugin in plugins) plugin.Tokens = TokenizeNames(plugin.Name, plugin.SortName, plugin.ProperName);
        if (DebuggingMode)
        {
            Write.Title(1, "Tokenizing plugin names.");
            plugins.ForEach(p => Write.Action(2, $"Plugin: {p.Name} -> {p.Tokens.Pretty()}"));
            Write.Title(1, "Analyzing NPCs.");
        }

        // Scan the list of npcs.
        foreach (var npc in npcs.Where(IsCreature))
        {
            //if (settings.DebuggingMode) Write.Action(2, $"Heuristics examining {npc}");
            if (npc.DeathItem?.IsNull ?? true) continue;

            var deathItem = npc.DeathItem.Resolve(LinkCache);
            if (KnownDeathItems.ContainsKey(deathItem)) continue;

            // If there is no DeathItemSelection record for the NPC's DeathItem, create it.
            // Try as hard as possible to give the DeathItemSelection a internalName. Fallbacks on fallbacks.
            if (!indexer.ContainsKey(deathItem))
            {
                indexer[deathItem] = new DeathItemSelection()
                {
                    DeathItem = deathItem.FormKey,
                    CreatureEntryName = deathItem.EditorID ?? npc.EditorID ?? npc.Name?.ToString() ?? Guid.NewGuid().ToString()
                };
                selectionWeights[indexer[deathItem]] = new();
            }

            // Add the NPC to the assigned NPCs of the DeathItemSelection.
            var deathItemSelection = indexer[deathItem];
            deathItemSelection.AssignedNPCs.Add(npc);

            // Run the heuristic matcher.
            var npcWeights = HeuristicNpcMatcher(npc);
            var itemWeights = selectionWeights[deathItemSelection];

            foreach (PluginEntry plugin in npcWeights.Keys)
                itemWeights[plugin] = itemWeights.GetValueOrDefault(plugin, 0) + npcWeights[plugin];
        }

        DeathItemSelection[] selections = selectionWeights.Keys.ToArray();
        Dictionary<FormKey, PluginEntry> savedSelections = Settings.DeathItemSelections.ToDictionary(v => v.DeathItem, v => v.Selection ?? PluginEntry.SKIP);
        int modifiedCount = 0;

        foreach (var selection in selections)
        {
            if (Settings.ReuseSelections && savedSelections.ContainsKey(selection.DeathItem))
            {
                selection.Selection = savedSelections[selection.DeathItem];
                if (DebuggingMode) Write.Action(3, $"Previously selected {selection.Selection?.ProperName}.");
            }
            else
            {
                var itemWeights = selectionWeights[selection];
                List<PluginEntry> options = new(itemWeights.Keys);
                if (options.Count == 0) continue;

                options.Sort((a, b) => itemWeights[b].CompareTo(itemWeights[a]));
                selection.Selection = options.First();
                if (DebuggingMode && !selection.DeathItem.IsNull)
                {
                    selection.DeathItem.ToLink<DeathItemGetter>().TryResolve(LinkCache, out var deathItem);
                    Write.Action(2, $"{deathItem?.EditorID ?? deathItem?.ToString() ?? "NO DEATH ITEM"}: heuristic selected {selection.Selection?.SortName}.");
                    Write.Action(3, $"From: {itemWeights.Pretty()}");

                    var npcNames = selection.AssignedNPCs.Take(6).Select(n => NpcNamer(n)).ToArray().Pretty();
                    Write.Action(3, $"Archetypes: {npcNames}");
                }
                modifiedCount = 0;
            }
        }

        Settings.DeathItemSelections = selections;
        return modifiedCount;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    private Dictionary<PluginEntry, int> HeuristicNpcMatcher(INpcGetter npc)
    {
        Dictionary<PluginEntry, int> candidates = new();
        string name = NpcNamer(npc);

        var clicker = DictionaryIncrementer(candidates);

        // Try to match the voice.
        if (!npc.Voice.IsNull)
        {
            Settings.Plugins
                .Where(plugin => !plugin.Voice.IsNull)
                .Where(plugin => plugin.Voice.Equals(npc.Voice))
                .ForEach(clicker(10));
        }

        // Match the creature's editorId, internalName, and race internalName to the names of plugins.
        var nameMatches = new HashSet<PluginEntry>();
        var race = npc.Race.Resolve(LinkCache);
        npc.DeathItem.TryResolve(LinkCache, out var deathItem);

        if (npc.EditorID is string npcEditorId) Settings.Plugins.Where(PluginNameMatch(npcEditorId)).ForEach(clicker(1));
        if (npc.Name?.ToString() is string npcName) Settings.Plugins.Where(PluginNameMatch(npcName)).ForEach(clicker(1));
        if (race.EditorID is string raceEditorId) Settings.Plugins.Where(PluginNameMatch(raceEditorId)).ForEach(clicker(1));
        if (race.Name?.ToString() is string raceName) Settings.Plugins.Where(PluginNameMatch(raceName)).ForEach(clicker(1));

        // Try this tokenizing matcher to break ties.
        var npcTokens = TokenizeNames(new List<string?>() { npc.Name?.ToString(), npc.EditorID, race.Name?.ToString(), race.EditorID, deathItem?.EditorID });
        if (DebuggingMode) Write.Action(2, $"Tokens for {name}: {npcTokens.Pretty()}");

        foreach (var plugin in Settings.Plugins)
        {
            int intersection = plugin.Tokens.Intersect(npcTokens).Count();
            if (intersection > 0) clicker(intersection)(plugin);
        }

        // @TODO Add matching for distinctive keywords?
        // @TODO Add exclusion terms?

        if (DebuggingMode)
        {
            Write.Success(2, $"Candidates for {name}:");
            Write.Success(3, candidates.Pretty());
        }

        return candidates;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param internalName="std"></param>
    /// <returns></returns>
    private List<InternalPluginEntry> RecreateCorePlugins(ViewingRecords std)
    {
        List<InternalPluginEntry> plugins = new();

        foreach (EntryType type in Enum.GetValues(typeof(EntryType)))
        {
            int count = std.GetCCFor(type).RaceIndex.Data.Count;
            Write.Action(1, $"Recreating {count} {type} plugin entries.");

            if (DebuggingMode)
            {
                if (type == EntryType.Animal) Console.WriteLine($"\tChecks: names={std.GetCCFor(type)._DS_FL_DeathItems.Items.Count}, pelts={std.GetCCFor(type)._DS_FL_PeltLists.Items.Count}, carcasses={std.Animals._DS_FL_CarcassObjects.Items.Count}");
                else Write.Action(1, $"Checks: names={std.GetCCFor(type)._DS_FL_DeathItems.Items.Count}, pelts={std.GetCCFor(type)._DS_FL_PeltLists.Items.Count}");
            }

            for (int index = 0; index < count; index++)
            {
                try
                {
                    InternalPluginEntry entry = RecreateCorePluginEntry(type, index, std);
                    plugins.Add(entry);
                }
                catch (DataConsistencyError ex)
                {
                    Write.Fail(0, "WARNING: inconsistent data detected. This may be the result of some other mod patching Hunterborn.");
                    Write.Fail(0, ex.Message);
                }
            }
        }

        return plugins;
    }

    private InternalPluginEntry RecreateCorePluginEntry(EntryType type, int index, ViewingRecords std)
    {
        string internalName = std.GetCCFor(type).RaceIndex.Data[index];
        if (internalName.IsNullOrWhitespace()) throw new DataConsistencyError(type, internalName, index, "No name.");

        try
        {
            var deathItemLink = std.GetCCFor(type)._DS_FL_DeathItems.Items[index];
            if (deathItemLink.IsNull) throw new DataConsistencyError(type, internalName, index, "No DeathItem.");

            deathItemLink.TryResolve<DeathItemGetter>(LinkCache, out var deathItem);
            if (deathItem == null) throw new DataConsistencyError(type, internalName, index, "DeathItem could not be resolved.");
            if (deathItem.EditorID == null) throw new DataConsistencyError(type, internalName, index, $"DeathItem {deathItem.FormKey} has no editor id.");

            InternalPluginEntry plugin = new(type, internalName, deathItem.FormKey);
            KnownDeathItems.Add(deathItem, plugin);

            var renaming = RecreatePluginName(plugin, deathItem);

            if (!renaming.Equals(NoRename)) (internalName, plugin.ProperName, plugin.SortName) = renaming;
            if (DebuggingMode) Write.Action(2, $"Recreating {plugin.Name} from {DeathItemNamer(deathItem)} (proper name '{plugin.ProperName}', sort name '{plugin.SortName}')");

            var toggle = std.GetCCFor(type).Switches.Objects[index].Object;
            if (toggle.IsNull) plugin.Toggle = new FormLink<IGlobalGetter>();
            else plugin.Toggle = toggle.Resolve<IGlobalGetter>(LinkCache).ToLink();

            var meat = std.GetCCFor(type).MeatType.Objects[index].Object;
            if (meat.IsNull) plugin.Meat = new FormLink<IItemGetter>();
            else plugin.Meat = meat.Resolve<IItemGetter>(LinkCache).ToLink();

            var shared = std.GetCCFor(type).SharedDeathItems.Objects[index].Object;
            if (shared.IsNull) plugin.SharedDeathItems = new FormLink<IFormListGetter>();
            else plugin.SharedDeathItems = shared.Resolve<IFormListGetter>(LinkCache).ToLink();

            plugin.CarcassSize = std.GetCCFor(type).CarcassSizes.Data[index];

            if (type == EntryType.Monster)
            {
                var venom = std.Monsters.VenomItems.Objects[index].Object;
                if (venom.IsNull) plugin.Venom = new FormLink<IIngestibleGetter>();
                else plugin.Venom = venom.Resolve<IIngestibleGetter>(LinkCache).ToLink();

                var blood = std.Monsters.BloodItems.Objects[index].Object;
                if (blood.IsNull) plugin.BloodType = new FormLink<IItemGetter>();
                else plugin.BloodType = blood.Resolve<IItemGetter>(LinkCache).ToLink();

                plugin.CarcassWeight = 0;
                plugin.CarcassValue = 0;
            }
            else if (type == EntryType.Animal)
            {
                var msg = std.Animals.CarcassMessages.Objects[index].Object;
                if (msg.IsNull) plugin.CarcassMessageBox = new FormLink<IMessageGetter>();
                else plugin.CarcassMessageBox = msg.Resolve<IMessageGetter>(LinkCache).ToLink();

                plugin.Venom = new FormLink<IIngestibleGetter>();
                plugin.BloodType = new FormLink<IItemGetter>();

                var carcass = std.Animals._DS_FL_CarcassObjects.Items[index].Resolve<IMiscItemGetter>(LinkCache);
                plugin.CarcassWeight = (int)carcass.Weight;
                plugin.CarcassValue = (int)carcass.Value;
                KnownCarcasses.Add(plugin, carcass);
            }

            plugin.Discard = type != EntryType.Monster
                ? new()
                : std.Monsters.Discards.Objects[index].Object
                .Resolve<IFormListGetter>(LinkCache).Items
                .Select(item => item as IFormLinkGetter<IItemGetter>)
                .Where(item => item is not null)
                .Select(item => item!).ToList();

            var mats = std.GetCCFor(type)._DS_FL_Mats__Lists.Items[index].Resolve<IFormListGetter>(LinkCache);
            plugin.Materials = RecreateMaterials(mats);
            // Console.WriteLine($"===RECREATED MATS FOR {plugin.ProperName}: {plugin.Materials.Pretty()}");

            plugin.PeltCount = Array.Empty<int>();
            plugin.FurPlateCount = Array.Empty<int>();

            IFormListGetter peltList = std.GetCCFor(type)._DS_FL_PeltLists.Items[index].Resolve<IFormListGetter>(LinkCache);
            if (peltList.Items.Count == 4)
            {
                PeltSet pelts = (
                    peltList.Items[0].Resolve<IMiscItemGetter>(LinkCache),
                    peltList.Items[1].Resolve<IMiscItemGetter>(LinkCache),
                    peltList.Items[2].Resolve<IMiscItemGetter>(LinkCache),
                    peltList.Items[3].Resolve<IMiscItemGetter>(LinkCache));
                KnownPelts[plugin] = pelts;
            }

            // The voice field is unnecessary because the core voices are hard-coded.
            // But it's nice to have it just in case.
            // 
            // We could scan through all NPCs looking for the matching DeathItem and grab the voice of
            // the first match.
            //
            // BUT
            // 
            // Vanilla voices are named very predictably, so just use that.
            //
            string voiceEdid = $"Cr{plugin.Name}Voice";
            LinkCache.TryResolve<IVoiceTypeGetter>(voiceEdid, out var voice);
            plugin.Voice = voice == null ? new FormLink<IVoiceTypeGetter>() : voice.ToLink();
            //if (DebuggingMode) Write.Action(2, $"Internal plugin {plugin.Name} searching for voice {voiceEdid}: found {plugin.Voice}.");

            FindRecipes(plugin, internalName, deathItem);

            // @TODO Find jerky and charred recipes.
            return plugin;

        }
        catch (RecordException ex)
        {
            Write.Title(0, $"Problem with {type} {internalName} {ex.FormKey} {ex.EditorID}");
            Write.Fail(1, $"Problem with {type} {internalName} {ex.FormKey} {ex.EditorID}");
            Write.Fail(1, ex.Message);
            Console.WriteLine(ex.StackTrace);
            throw ex;
        }
    }

    /// <summary>
    /// Fill in recipe-related data for the internal plugins.
    /// 
    /// </summary>
    /// 
    private void FindRecipes(PluginEntry plugin, string internalName, DeathItemGetter deathItem)
    {
        // Search for the standard recipes using naming conventions in the order of
        // CACO->CCOR->Campfire->Hunterborn->Vanilla.
        // If nothing is found, try again using the plugin name instead of the internal name.

        List<List<string>> patterns = new() {
            new() { "_DS_Recipe_Pelt_{0}_00" },
            new() { "_DS_Recipe_Pelt_{0}_01", "RecipeLeather{0}Hide" },
            new() { "_DS_Recipe_Pelt_{0}_02" },
            new() { "_DS_Recipe_Pelt_{0}_03" },
            new() { "HB_Recipe_FurPlate_{0}_00" },
            new() { "CCOR_RecipeFurPlate{0}Hide", "_Camp_RecipeTanningLeather{0}Hide", "HB_Recipe_FurPlate_{0}_01" },
            new() { "HB_Recipe_FurPlate_{0}_02" },
            new() { "CACO_RecipeFood{0}Cooked", "CACO_RecipeFoodMeatFoxCooked", "_DS_Recipe_Food_CharredMeat_{0}" },
            new() { "CACO_RecipeFood{0}Cooked_Campfire", "HB_Recipe_FireFood_CharredMeat_{0}" },
            new() { "HB_CACO_RecipeFood{0}Cooked_PrimCook", "_DS_Recipe_Food_Primitive_CharredMeat_{0}" },
            new() { "CACO_RecipeJerky{0}", "_DS_Food_{0}Jerky", "_DS_Recipe_Food_{0}Jerky"}};

        // Some corrections for vanilla and hunterborn recipes with non-standard names.
        List<string> names = new() { internalName, plugin.Name };
        if (plugin.Name.EqualsIgnoreCase("Cow")) names.Add("Beef");
        if (plugin.Name.EqualsIgnoreCase("Deer")) names.Add("Venison");
        if (plugin.Name.ContainsInsensitive("Elk")) names.Add("Venison");
        if (plugin.Name.EqualsIgnoreCase("Dog")) names.Add("DogCookedWhole");
        if (plugin.Name.ContainsInsensitive("Mudcrab")) names.Add("Mudcrab");
        if (plugin.Name.ContainsInsensitive("Bristleback")) names.Add("Boar");

        var recipes = Edid_Lookups_Fallbacks(names, patterns);

        // Extract the results to nicely named variables.
        var peltRecipe0 = recipes[0];
        var peltRecipe1 = recipes[1];
        var peltRecipe2 = recipes[2];
        var peltRecipe3 = recipes[3];
        var furRecipe0 = recipes[4];
        var furRecipe1 = recipes[5];
        var furRecipe2 = recipes[6];
        var meatCooked = recipes[7];
        var meatCampfire = recipes[8];
        var meatPrimitive = recipes[9];
        var meatJerky = recipes[10];

        // If a standard pelt recipe is found, there must be a default pelt.
        // Try to get it. Use the result of the GetDefaultPelt function otherwise, which 
        // searches the creature's inventory.
        if (peltRecipe1 is not null && peltRecipe1.Items is IReadOnlyList<IContainerEntryGetter> containerEntries
            && containerEntries.Count > 0 && containerEntries[0] is IContainerEntryGetter containerEntry
            && containerEntry.Item is IContainerItemGetter containerItem
            && containerItem.Item is IFormLink<IItemGetter> foundPelt)
        {
            if (foundPelt is not null && !foundPelt.IsNull)
            {
                if (DebuggingMode) Write.Success(3, $"Found default pelt from tanning recipe {peltRecipe1.EditorID}.");
                plugin.DefaultPelt = foundPelt.FormKey.ToLink<IMiscItemGetter>();
            }
        }
        else
        {
            var defaultPelt = GetDefaultPelt(deathItem);
            if (defaultPelt is not null)
            {
                if (DebuggingMode) Write.Success(3, $"Found default pelt from DeathItem {deathItem.EditorID}.");
                plugin.DefaultPelt = defaultPelt.ToLink();
            }
        }

        // Pack it all up and finish filling in the Plugin's properties.
        // Print debugging messages about what was found.

        if (peltRecipe0 is not null && peltRecipe1 is not null && peltRecipe2 is not null && peltRecipe3 is not null)
        {
            if (DebuggingMode) Write.Success(2, "Found a full set of leather-making recipes.");
            //var peltRecipeSet = (peltRecipe0, peltRecipe1, peltRecipe2, peltRecipe3);
            //plugin.Recipes.PeltRecipes = peltRecipeSet;

            plugin.PeltCount = new int[] { peltRecipe0.CreatedObjectCount ?? 2, peltRecipe1.CreatedObjectCount ?? 2, peltRecipe2.CreatedObjectCount ?? 2, peltRecipe3.CreatedObjectCount ?? 2 };

            peltRecipe0.CreatedObject.TryResolve<IMiscItemGetter>(LinkCache, out var pelt0);
            peltRecipe1.CreatedObject.TryResolve<IMiscItemGetter>(LinkCache, out var pelt1);
            peltRecipe2.CreatedObject.TryResolve<IMiscItemGetter>(LinkCache, out var pelt2);
            peltRecipe3.CreatedObject.TryResolve<IMiscItemGetter>(LinkCache, out var pelt3);

            if (pelt0 is not null && pelt1 is not null && pelt2 is not null && pelt3 is not null)
            {
                var found = (pelt0, pelt1, pelt2, pelt3);

                if (KnownPelts.ContainsKey(plugin))
                {
                    var known = KnownPelts[plugin];
                    if (found.Equals(known)) Write.Success(2, "RECIPE AND PELTS MATCH PEFECTLY.");
                    else Write.Fail(2, "RECIPE AND PELTS DO NOT MATCH, WHICH IS WEIRD BUT NOT DISASTROUS.");
                }
                else
                {
                    KnownPelts[plugin] = (pelt0, pelt1, pelt2, pelt3);
                    Write.Fail(2, "HOW CAN THIS EVEN HAPPEN?");
                }
                //FullGeneratedPelts.Add(pelt1.ToLink());
            }

        }
        else if (peltRecipe0 is not null || peltRecipe1 is not null || peltRecipe2 is not null || peltRecipe3 is not null)
        {
            if (DebuggingMode) Write.Fail(2, "Found inconsistent set of leather-making recipes.");
        }

        if (furRecipe0 is not null && furRecipe1 is not null && furRecipe2 is not null)
        {
            if (DebuggingMode) Write.Success(2, "Found a full set of fur-plating recipes.");
            plugin.FurPlateCount = new int[] { furRecipe0.CreatedObjectCount ?? 1, furRecipe1.CreatedObjectCount ?? 2, furRecipe2.CreatedObjectCount ?? 4 };
        }
        else if (furRecipe0 is not null || furRecipe1 is not null || furRecipe2 is not null)
        {
            if (DebuggingMode) Write.Fail(2, "Found inconsistent set of fur-plating recipes.");
        }

        if (DebuggingMode)
        {
            if (!plugin.DefaultPelt.IsNull) Write.Success(2, $"Found standard pelt: {plugin.DefaultPelt}");
            else if (plugin.PeltCount.Length > 0) Write.Fail(2, $"No pelt found but pelt counts are specified.");
        }

        if (meatCooked is not null || meatCampfire is not null || meatPrimitive is not null || meatJerky is not null)
        {
            var meatRecipes = (meatCooked, meatCooked, meatPrimitive, meatJerky);
            if (DebuggingMode) Write.Success(2, $"Found meat recipes: {meatRecipes}");
        }
        else if (!plugin.Meat.IsNull && DebuggingMode) Write.Fail(2, $"No meat recipes found.");

    }

    private List<IConstructibleObjectGetter?> Edid_Lookups_Fallbacks(List<string> names, List<List<string>> patterns)
    {
        List<IConstructibleObjectGetter?> results = new();

        foreach (var group in patterns)
        {
            IConstructibleObjectGetter? result = null;
            foreach (var name in names)
            {
                foreach (var pattern in group)
                {
                    LinkCache.TryResolve<IConstructibleObjectGetter>(string.Format(pattern, name), out result);
                    if (result is not null) break;
                }
                if (result is not null) break;
            }
            results.Add(result);
        }

        return results;
    }

    /// <summary>
    /// Attempts to recreate the useful names for the plugin.
    /// </summary>
    /// <returns>A tuple of (deathItemName, ProperName, SortName)</returns>
    static private (string, string, string) RecreatePluginName(PluginEntry plugin, DeathItemGetter deathItem)
    {
        if (deathItem.EditorID is string deathItemEdid && DeathItemPrefix.IsMatch(deathItemEdid))
        {
            string deathItemName = DeathItemPrefix.Replace(deathItemEdid, "");
            if (SpecialCases.EditorToNames.ContainsKey(deathItemName) && SpecialCases.EditorToNames[deathItemName].Count > 0)
            {
                var parts = SpecialCases.EditorToNames[deathItemName];

                if (parts.Count == 1) return (deathItemName, parts[0], parts[0]);
                else if (parts.Count == 2) return (deathItemName, $"{parts[1]} {parts[0]}", $"{parts[0]} - {parts[1]}");
                else if (parts.Count == 3) return (deathItemName, $"{parts[2]} {parts[1]} {parts[0]}", $"{parts[0]} - {parts[1]}, {parts[2]}");
            }
            else if (!deathItemName.EqualsIgnoreCase(plugin.Name))
            {
                string subtype = deathItemName.Replace(plugin.Name, "", StringComparison.InvariantCultureIgnoreCase);
                if (!subtype.IsNullOrWhitespace())
                    return (deathItemName, TextInfo.ToTitleCase($"{subtype} {plugin.Name}"), TextInfo.ToTitleCase($"{plugin.Name} - {subtype}"));
            }
        }

        return NoRename;
    }

    /// <summary>
    /// Regular expression used to turn the names of vanilla DeathItems into useful names.
    /// </summary>
    static private readonly Regex DeathItemPrefix = new(".*DeathItem", RegexOptions.IgnoreCase);

    /// <summary>
    /// Used to make nice names.
    /// </summary>
    static private readonly TextInfo TextInfo = CultureInfo.CurrentCulture.TextInfo;

    /// <summary>
    /// Flag object indicating that RecreatePluginName did not have a result.
    /// </summary>
    static private (string, string, string) NoRename = ("", "", "");

    /// <summary>
    /// Things that have to be done for each race:
    /// 
    /// 
    /// ==NEW RECORDS==
    /// Create a token MiscItem that identifies the creature as being Hunterborn-enabled.
    /// Create a carcass MiscItem that can go in the player's inventory.
    /// 
    /// Create a materials FormList containing 4 leveled lists of stuff, for the four levels of harvesting skill.
    /// 
    /// Create either 3 or 4 pelt MiscItems (3 if there's a default one the creature already).
    /// Create Leather and Fur Plate recipes for the pelts.
    /// 
    /// Add the creature's DeathItem to the DeathItems formlist.
    /// 
    /// Creature a new CustomDeathItem that contains tokens for the actions supported by the creature.
    /// 
    /// 
    /// ==HUNTERBORN QUEST SCRIPT==
    /// Add the carcass size to its array property.
    /// Add the carcass custom message (if any) to its array property.
    /// Add the CustomDeathItem to its array property.
    /// Add the meat type (if any) to its array property.
    /// Add the meat weight (if any) to its array property.
    /// Add the default pelt value (if any) to its array property.
    /// Add the shared death entryItem (if any) to its array property.
    /// Add the proper internalName to its array property.
    /// 
    /// For monsters:
    /// Add the venom (if any) to its array property.
    /// Add the blood (if any) to its array property.
    /// Add the "negative treasure" (if any) to its array property.
    /// 
    /// </summary>
    /// 
    private void AddRecordFor(CreatureData data, PatchingRecords std)
    {
        var token = CreateToken(data, std);
        var mats = CreateMaterials(data, std);
        var pelts = CreatePelts(data, std);
        var deathDescriptor = CreateDeathDescriptor(data, pelts, mats, std);
        if (data.IsAnimal) CreateCarcass(data, std);
        if (data.IsMonster) CreateDiscards(data, std);

        std.GetCCFor(data).RaceIndex.Data.Add(data.InternalName);
        std.GetCCFor(data).CarcassSizes.Data.Add(data.Prototype.CarcassSize);
        std.GetCCFor(data).Switches.Objects.Add(CreateProperty(data.Prototype.Toggle));
        std.GetCCFor(data).SharedDeathItems.Objects.Add(CreateProperty(data.Prototype.SharedDeathItems));

        if (GetDefaultMeat(data, std) is IItemGetter meat)
        {
            meat = ItemSubstitution(meat);
            std.GetCCFor(data).MeatType.Objects.Add(CreateProperty(meat.ToLink()));
            std.GetCCFor(data).MeatWeights.Data.Add(meat is IWeightValueGetter w ? w.Weight : 0.0f);
        }
        else
        {
            std.GetCCFor(data).MeatType.Objects.Add(CreateProperty(new FormLink<Ingestible>()));
            std.GetCCFor(data).MeatWeights.Data.Add(0.0f);
        }

        if (data.IsMonster)
        {
            std.Monsters.BloodItems.Objects.Add(CreateProperty(data.Prototype.BloodType));
            std.Monsters.VenomItems.Objects.Add(CreateProperty(data.Prototype.Venom));
        }
        else
        {
            std.Animals.CarcassMessages.Objects.Add(CreateProperty(data.Prototype.CarcassMessageBox));
        }

        if (DebuggingMode)
        {
            Write.Success(1, $"Created new forms:");
            Write.Success(2, $"ID Token: {token}");
            Write.Success(2, $"Materials: {mats}");
            Write.Success(2, $"Pelts: {pelts.Pretty()}");
            Write.Success(2, $"Descriptor: {deathDescriptor}");
            Write.Success(2, $"Updated quest script properties.");
        }
    }

    /// <summary>
    /// Create a CreatureData record. Convenience class for passing multiple fields of data to methods.
    /// </summary>
    /// <param name="deathItem"></param>
    /// <param name="prototype"></param>
    /// <param name="std"></param>
    /// <returns></returns>
    static CreatureData CreateCreatureData(DeathItemGetter deathItem, PluginEntry prototype)
    {
        CreatureData data = new(deathItem, CreateInternalName(deathItem), prototype, prototype.Type == EntryType.Animal, prototype.Type == EntryType.Monster);
        return data;
    }

    /// <summary>
    /// Creates a unique internal internalName for the specified DeathItem. 
    /// This is used to derive the editorIds for the new forms that will be created 
    /// for the specified DeathItem.
    /// </summary>
    /// <param internalName="deathItem">The DeathItem to create a reasonably unique internalName for.</param>
    /// <returns>A reasonably unique internalName.</returns>
    /// 
    static string CreateInternalName(DeathItemGetter deathItem)
    {
        if (deathItem.EditorID.IsNullOrWhitespace()) return EditorIdFilter.Replace(deathItem.FormKey.ToString(), "");
        else return EditorIdFilter.Replace(deathItem.EditorID, "");
    }

    /// <summary>
    /// Creates the Misc deathtoken for a creature.
    /// 
    /// The new deathtoken is appended to the deathtoken formlist for animals or monsters.
    /// 
    /// The deathtoken will be derived from the prototype's token (if it exists) or derived from the COW's deathtoken.
    /// 
    /// Naming is done heuristically. 
    /// </summary>
    /// 
    private MiscItem CreateToken(CreatureData data, PatchingRecords std)
    {
        // Get a pre-existing token that already has the keywords and model set.
        // That way all that needs to be done is to change the internalName and editor ID.
        var existingTokenLink = data.IsAnimal ? DEFAULT_TOKEN_ANIMAL : DEFAULT_TOKEN_MONSTER;
        existingTokenLink.TryResolve(LinkCache, out var existingToken);
        if (existingToken == null) throw new CoreRecordMissing(existingTokenLink);

        // Add the token to the patch.
        var token = PatchMod.MiscItems.DuplicateInAsNewRecord(existingToken);
        if (token == null) throw new InvalidOperationException();

        // Set the EditorID.
        token.EditorID = $"_DS_DI{data.InternalName}";
        token.Name = $"{data.InternalName} Token";

        // Put the token in the correct formlist.
        std.GetCCFor(data)._DS_FL_DeathItemTokens.Items.Add(token);

        return token;
    }

    private MiscItem CreateCarcass(CreatureData data, PatchingRecords std)
    {
        // Get a pre-existing carcass that already has the keywords set.
        DEFAULT_CARCASS.TryResolve(LinkCache, out var existingCarcass);
        if (existingCarcass == null) throw new CoreRecordMissing(DEFAULT_CARCASS);

        // Add the carcass to the patch.
        var carcass = PatchMod.MiscItems.DuplicateInAsNewRecord(existingCarcass);
        if (carcass == null) throw new InvalidOperationException();

        var oldName = carcass.Name?.String;
        if (oldName.IsNullOrEmpty()) oldName = "Cow Carcass";

        carcass.EditorID = $"_DS_Carcass{data.InternalName}";
        carcass.Name = oldName.Replace("Cow", $"{data.Prototype.ProperName}");

        carcass.Value = (uint)data.Prototype.CarcassValue;
        carcass.Weight = data.Prototype.CarcassWeight;

        carcass.Model = KnownCarcasses.ContainsKey(data.Prototype)
            ? KnownCarcasses[data.Prototype].Model?.DeepCopy() ?? CreateDefaultCarcassModel()
            : CreateDefaultCarcassModel();

        // Put the carcass in the correct formlist.
        std.Animals._DS_FL_CarcassObjects.Items.Add(carcass);

        return carcass;
    }

    static private Model CreateDefaultCarcassModel()
    {
        return new Model { File = "Clutter\\Containers\\MiscSackLarge.nif", AlternateTextures = null };
    }

    /// <summary>
    /// Creates a FormList of LeveledItems from a list of MaterialLevels in a prototype.
    /// </summary>
    /// 
    private FormList CreateMaterials(CreatureData data, PatchingRecords std)
    {
        //DEFAULT_MATS.TryResolve(LinkCache, out var existingMaterials);
        //if (existingMaterials == null) throw new CoreRecordMissing(DEFAULT_MATS.FormKey);

        var matsFormList = PatchMod.FormLists.AddNew();
        if (matsFormList == null) throw new InvalidOperationException();

        var matsPerfectLvld = PatchMod.LeveledItems.AddNew();
        if (matsPerfectLvld == null) throw new InvalidOperationException();

        matsFormList.EditorID = $"_DS_FL_Mats_{data.InternalName}";
        matsPerfectLvld.EditorID = $"_DS_FL_Mats_Perfect_{data.InternalName}";

        for (int index = 0; index < data.Prototype.Materials.Count; index++)
        {
            var skillLevel = data.Prototype.Materials[index];
            var mat = PatchMod.LeveledItems.AddNew();
            if (mat == null) throw new InvalidOperationException();

            mat.EditorID = $"{matsFormList.EditorID}{index:D2}";
            var entries = mat.Entries = new();

            foreach (var itemEntry in skillLevel.Items)
            {
                IFormLinkGetter<IItemGetter> item = new FormLink<IItemGetter>(itemEntry.Key.FormKey);
                item = FormLinkSubstitution(item);
                entries.Add(CreateLeveledItemEntry(item, 1, itemEntry.Value));
            }

            matsFormList.Items.Add(mat);
        }

        // Put the materials formlist in the correct formlist.
        std.GetCCFor(data)._DS_FL_Mats__Lists.Items.Add(matsFormList);
        std.GetCCFor(data)._DS_FL_Mats__Perfect.Items.Add(matsPerfectLvld);

        return matsFormList;
    }

    /// <summary>
    /// Turns a FormList of LeveledItems into a list of MaterialLevels.
    /// The inverse of CreateMaterials.
    /// </summary>
    /// 
    private List<MaterialLevel> RecreateMaterials(IFormListGetter matsFormList)
    {
        List<MaterialLevel> materials = new();
        //Console.WriteLine($"===Recreating materials from {matsFormList}, {matsFormList.Items.Count} in formlist.===");
        //Console.WriteLine("======" + matsFormList.Items.ToArray().Pretty());

        foreach (var level in matsFormList.Items)
        {
            var asLeveled = level.FormKey.ToLinkGetter<ILeveledItemGetter>().Resolve(LinkCache);

            MaterialLevel skillLevel = new();
            materials.Add(skillLevel);

            var entries = asLeveled.Entries;
            //Console.WriteLine($"======Recreating materials from {level}, {entries?.Count} in leveledlist.===");

            if (entries is not null)
            {
                foreach (var entry in entries)
                {
                    if (entry.Data is not null && entry.Data.Reference is not null)
                        skillLevel.Items[entry.Data.Reference] = entry.Data.Count;
                }
            }
        }

        return materials;
    }


    private IFormListGetter CreatePelts(CreatureData data, PatchingRecords std)
    {
        var peltFormList = PatchMod.FormLists.AddNew();
        if (peltFormList == null) throw new InvalidOperationException();
        peltFormList.EditorID = $"_DS_FL_Pelts{data.InternalName}";
        std.GetCCFor(data)._DS_FL_PeltLists.Items.Add(peltFormList);

        // If the pelt counts are absent, don't make any pelts or recipes.
        if (data.Prototype.PeltCount.Length == 0)
        {
            std.GetCCFor(data).PeltValues.Data.Add(0);
            return peltFormList;
        }

        if (!KnownPelts.ContainsKey(data.Prototype))
        {
            var standard = GetDefaultPelt(data);
            bool createdDefaultPelt = standard is not null;
            standard ??= CreateDefaultPelt(data);

            if (DebuggingMode) Write.Action(3, "Creating new Pelt records in Misc.");

            var poor = PatchMod.MiscItems.DuplicateInAsNewRecord(standard);
            var fine = PatchMod.MiscItems.DuplicateInAsNewRecord(standard);
            var flawless = PatchMod.MiscItems.DuplicateInAsNewRecord(standard);

            if (DebuggingMode) Write.Success(3, "Created \"poor\".");
            if (DebuggingMode) Write.Success(3, "Created \"standard\".");
            if (DebuggingMode) Write.Success(3, "Created \"flawless\".");

            string edid = $"_DS_Pelt_{data.InternalName ?? data.InternalName}";
            poor.EditorID = $"{edid}_00";
            fine.EditorID = $"{edid}_02";
            flawless.EditorID = $"{edid}_03";

            poor.Name = $"{standard.Name} (poor)";
            fine.Name = $"{standard.Name} (fine)";
            flawless.Name = $"{standard.Name} (flawless)";

            // Adjust the values of the non-standard pelts.
            poor.Value /= 2;
            fine.Value *= 2;
            flawless.Value *= 20;

            //PeltSet peltSet = (poor, standard, fine, flawless);
            var newPeltSet = (poor, standard, fine, flawless);
            KnownPelts[data.Prototype] = newPeltSet;

            std.GetCCFor(data).PeltValues.Data.Add((int)standard.Value);
            if (createdDefaultPelt) CreatePeltRecipes(data, newPeltSet, createdDefaultPelt);
        }

        // Add the pelts to the pelts formlist.
        var peltSet = KnownPelts[data.Prototype];
        peltFormList.Items.AddRange(new IFormLinkGetter<IMiscItemGetter>[] { peltSet.Item1.ToLink(), peltSet.Item2.ToLink(), peltSet.Item3.ToLink(), peltSet.Item4.ToLink() });

        // Put the pelts formlist in the correct formlist.
        // Add the pelt value.
        //std.GetCCFor(data)._DS_FL_PeltLists.Items.Add(peltFormList);
        std.GetCCFor(data).PeltValues.Data.Add((int)peltSet.Item2.Value);

        return peltFormList;
    }

    /// <summary>
    /// Checks the creature's DeathItem for anything whose internalName or editorID contains a string-match
    /// that indicates it's probably a pelt. Returns the pelt.
    /// 
    /// </summary>
    /// <returns>A pair consisting of the pelt Item and a flag indicating whether it was created.</returns>
    /// 
    private IMiscItemGetter? GetDefaultPelt(CreatureData data)
    {
        if (!data.Prototype.DefaultPelt.IsNull) return data.Prototype.DefaultPelt.Resolve(LinkCache);
        var defaultPelt = GetDefaultPelt(data.DeathItem);
        if (defaultPelt is IMiscItemGetter pelt) return pelt;
        else return null;
    }

    /// <summary>
    /// Checks the creature's DeathItem for anything whose internalName or editorID contains a string-match
    /// that indicates it's probably a pelt. Returns the pelt.
    /// 
    /// If no default pelt was found, one will be created and added to the patch.
    /// 
    /// </summary>
    /// 
    private IMiscItemGetter? GetDefaultPelt(DeathItemGetter data)
    {
        var entries = data.Entries;
        if (entries == null) return null;

        foreach (var entry in entries)
        {
            var entryItem = entry.Data?.Reference.TryResolve(LinkCache);
            var edid = entryItem?.EditorID ?? "";
            if (entryItem == null || edid == null) continue;

            if (DefaultPeltRegex.Matches(edid).Any())
            {
                if (entryItem is ILeveledItemGetter lvld)
                {
                    if (DebuggingMode) Write.Action(4, $"Pelt search recursing into {DeathItemNamer(lvld)}");
                    if (lvld.Entries is not null && lvld.Entries.Count == 1 && GetDefaultPelt(lvld) is IMiscItemGetter subItem)
                        return subItem;
                }
                else if (entryItem is IMiscItemGetter item)
                {
                    if (DebuggingMode) Write.Action(4, $"Pelt search found {ItemNamer(item)}");
                    return item;
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Create a new default pelt for a creature using a pre-existing pelt as a template.
    /// 
    /// </summary>
    private MiscItem CreateDefaultPelt(CreatureData data)
    {
        if (DebuggingMode) Write.Action(3, $"Creating new pelt for {data.InternalName}");

        DEFAULT_PELT.TryResolve(LinkCache, out var existingPelt);
        if (existingPelt == null) throw new CoreRecordMissing(DEFAULT_PELT);

        var newPelt = PatchMod.MiscItems.DuplicateInAsNewRecord(DEFAULT_PELT.Resolve(LinkCache));
        if (newPelt == null) throw new InvalidOperationException();

        newPelt.EditorID = $"_DS_Pelt_{data.InternalName}_01";
        newPelt.Name = $"{data.Prototype.ProperName} Pelt";

        // @TODO Fill this in with something better.
        newPelt.Value = (uint)data.Prototype.CarcassValue / 2;

        if (DebuggingMode) Write.Success(3, $"Created new default Pelt {newPelt}");

        return newPelt;
    }

    /// <summary>
    /// Checks the creature's DeathItem for anything whose internalName or editorID contains a string-match
    /// that indicates it's probably meat. Returns the meat.
    /// 
    /// If no meat was found, one will be created and added to the patch.
    /// 
    /// </summary>
    /// 
    private IItemGetter? GetDefaultMeat(CreatureData data, PatchingRecords std)
    {
        if (!data.Prototype.Meat.IsNull) return data.Prototype.Meat.Resolve(LinkCache);
        else
        {
            var defaultMeat = GetDefaultMeat(data.DeathItem, std);
            if (defaultMeat is IItemGetter meat) return meat;
            else if (data.Prototype.CreateDefaultMeat) return CreateDefaultMeat(data);
            else return null;
        }
    }

    /// <summary>
    /// Checks the creature's DeathItem for anything whose internalName or editorID contains a string-match
    /// that indicates it's probably a meat. Returns the meat.
    /// 
    /// If no meat was found, one will be created and added to the patch.
    /// 
    /// </summary>
    /// 
    private IItemGetter? GetDefaultMeat(DeathItemGetter data, PatchingRecords std)
    {
        var entries = data.Entries;
        if (entries == null) return null;

        foreach (var entry in entries)
        {
            var entryItem = entry.Data?.Reference.TryResolve(LinkCache);
            var edid = entryItem?.EditorID ?? "";
            if (entryItem == null || edid == null) continue;

            if (DefaultMeatRegex.Matches(edid).Any())
            {
                if (entryItem is ILeveledItemGetter lvld)
                {
                    if (DebuggingMode) Write.Action(4, $"Meat search recursing into {DeathItemNamer(lvld)}");
                    if (lvld.Entries is not null && lvld.Entries.Count == 1 && GetDefaultMeat(lvld, std) is IItemGetter subItem)
                        return subItem;
                }
                else if (entryItem is IItemGetter item)
                {
                    if (DebuggingMode) Write.Action(4, $"Meat search found {ItemNamer(item)}");
                    return item;
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Create a new default meat for a creature using a pre-existing meat as a template.
    /// Also creates cooked meat and jerky but they are not returned.
    /// 
    /// </summary>
    /// <param internalName="data"></param>
    /// <param internalName="std"></param>
    /// <returns></returns>
    /// <exception cref="CoreRecordMissing"></exception>
    /// <exception cref="InvalidOperationException"></exception>
    private IItemGetter CreateDefaultMeat(CreatureData data)
    {
        if (DebuggingMode) Write.Action(3, $"Creating new meats for {data.InternalName}");

        DEFAULT_MEAT.TryResolve(LinkCache, out var existingMeat);
        if (existingMeat == null) throw new CoreRecordMissing(DEFAULT_MEAT);

        var newMeat = PatchMod.Ingestibles.DuplicateInAsNewRecord(existingMeat);
        var newCooked = PatchMod.Ingestibles.DuplicateInAsNewRecord(existingMeat);
        var newJerky = PatchMod.Ingestibles.DuplicateInAsNewRecord(existingMeat);

        if (newMeat == null) throw new InvalidOperationException();
        if (newCooked == null) throw new InvalidOperationException();
        if (newJerky == null) throw new InvalidOperationException();

        newMeat.EditorID = $"_DS_Meat_{data.InternalName}";
        newCooked.EditorID = $"_DS_Meat_{data.InternalName}";
        newJerky.EditorID = $"_DS_Meat_{data.InternalName}";

        newMeat.Name = $"{data.Prototype.ProperName} Meat (raw)";
        newCooked.Name = $"{data.Prototype.ProperName} Meat (cooked)";
        newJerky.Name = $"{data.Prototype.ProperName} Jerky";

        newMeat.Keywords ??= new();
        newCooked.Keywords ??= new();
        newJerky.Keywords ??= new();

        if (!newMeat.HasKeyword(_DS_KW_Food_Raw)) newMeat.Keywords.Add(_DS_KW_Food_Raw);
        if (!newMeat.HasKeyword(Skyrim.Keyword.VendorItemFoodRaw)) newMeat.Keywords.Add(Skyrim.Keyword.VendorItemFoodRaw);

        if (IsCacoInstalled())
        {
            if (!newMeat.HasKeyword(VendorItemFoodMeat)) newMeat.Keywords.Add(VendorItemFoodMeat);
            if (!newMeat.HasKeyword(VendorItemFoodUncooked)) newMeat.Keywords.Add(VendorItemFoodUncooked);
            if (!newMeat.HasKeyword(LastSeedEnableKeywordSpoil)) newMeat.Keywords.Add(LastSeedEnableKeywordSpoil);
            if (!newCooked.HasKeyword(VendorItemFoodMeat)) newCooked.Keywords.Add(VendorItemFoodMeat);
            if (!newCooked.HasKeyword(VendorItemFoodCooked)) newCooked.Keywords.Add(VendorItemFoodCooked);
            if (!newJerky.HasKeyword(VendorItemFoodMeat)) newJerky.Keywords.Add(VendorItemFoodMeat);
            if (!newJerky.HasKeyword(VendorItemFoodPreserved)) newJerky.Keywords.Add(VendorItemFoodPreserved);
        }

        if (IsLastSeedInstalled())
        {
            if (!newMeat.HasKeyword(VendorItemFoodMeat)) newMeat.Keywords.Add(VendorItemFoodMeat);
            if (!newMeat.HasKeyword(_Seed_PO3_Detection_MeatRaw)) newMeat.Keywords.Add(_Seed_PO3_Detection_MeatRaw);
            if (!newCooked.HasKeyword(VendorItemFoodMeat)) newCooked.Keywords.Add(VendorItemFoodMeat);
            if (!newCooked.HasKeyword(_Seed_PO3_Detection_MeatCooked)) newCooked.Keywords.Add(_Seed_PO3_Detection_MeatCooked);
            if (!newJerky.HasKeyword(VendorItemFoodMeat)) newJerky.Keywords.Add(VendorItemFoodMeat);
            if (!newJerky.HasKeyword(_Seed_PO3_Detection_Preserved)) newJerky.Keywords.Add(_Seed_PO3_Detection_Preserved);
            if (!newJerky.HasKeyword(_Seed_PO3_Detection_Salted)) newJerky.Keywords.Add(_Seed_PO3_Detection_Salted);
            if (!newJerky.HasKeyword(VendorItemFoodPreserved)) newJerky.Keywords.Add(VendorItemFoodPreserved);
            if (!newJerky.HasKeyword(VendorItemFoodSalted)) newJerky.Keywords.Add(VendorItemFoodSalted);
        }

        // @TODO Fill this in with something better.
        newMeat.Value = (uint)data.Prototype.CarcassValue / 5;

        MeatSet meatSet = (newMeat, newCooked, newJerky);
        // Make recipes.
        CreateMeatRecipes(data, meatSet);

        if (DebuggingMode) Write.Success(3, $"Created new meats: {meatSet}");

        return newMeat;
    }

    /// <summary>
    /// Create a new discards formlist for a monster.
    /// Dicards are also called "negativetreasure" internally.
    /// </summary>
    /// 
    private FormList CreateDiscards(CreatureData data, PatchingRecords std)
    {
        var discards = PatchMod.FormLists.AddNew();
        if (discards == null) throw new InvalidOperationException();

        discards.EditorID = $"_DS_FL_Discard{data.InternalName}_01";
        discards.Items.AddRange(data.Prototype.Discard);
        std.Monsters.Discards.Objects.Add(CreateProperty(discards.ToLink()));

        return discards;
    }

    /// <summary>
    /// Create a new DeathDescriptor for a creature.
    /// This is a LeveledItem that gets added to a carcass's inventory when the
    /// player interacts with the carcass for the first time.
    /// 
    /// The Tokens it adds are what determine which actions the player can take.
    /// 
    /// </summary>
    /// 
    private ILeveledItemGetter CreateDeathDescriptor(CreatureData data, IFormListGetter pelts, FormList mats, PatchingRecords std)
    {
        // Create the new descriptor.
        LeveledItem deathDescriptor = PatchMod.LeveledItems.AddNew();
        deathDescriptor.EditorID = $"_DS_DeathItem_{data.InternalName}";
        deathDescriptor.Entries = new();

        // If the pelts FormList isn't empty, then harvesting pelts is enabled.
        if (pelts.Items is not null && pelts.Items.Count > 0)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Pelt, 1, 1));

        // If the materials FormList isn't empty, then harvesting materials is enabled.
        if (mats.Items is not null && mats.Items.Count > 0)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Mat, 1, 1));

        // Animals need to be cleaned. Monsters apparently not?
        if (data.IsAnimal)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Carcass_Clean, 1, 1));

        // If the Meat field in the PluginEntry isn't null then harvesting meat is enabled.
        if (!data.Prototype.Meat.IsNull)
        {
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Meat, 1, 1));
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Meat_Fresh, 1, 1));
        }

        // If the Venom or Blood fields in the PluginEntry aren't null then harvesting venom and/or blood is enabled.
        if (data.IsMonster)
        {
            if (!data.Prototype.Venom.IsNull)
                deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Venom, 1, 1));
            if (!data.Prototype.BloodType.IsNull)
                deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Venom, 1, 1));
        }

        // Add the creature's actual DeathItem to the appropriate FormList.
        // When hunterborn starts up, the creature's Token will be added to this formlist.
        // THIS IS HOW HUNTERBORN RECOGNIZES HARVESTABLE CREATURES.
        std.GetCCFor(data)._DS_FL_DeathItems.Items.Add(data.DeathItem);

        // Add the DeathDescriptor to the quest array property.
        std.GetCCFor(data).DeathDescriptors.Objects.Add(new() { Object = deathDescriptor.ToLink() });

        return deathDescriptor;
    }

    /// <summary>
    /// Creates leather and pelt recipes for created leathers.
    /// </summary>
    /// 
    private void CreatePeltRecipes(CreatureData data, PeltSet pelts, bool createdStandardPelt)
    {
        if (data.Prototype.FurPlateCount.Length >= 3)
        {
            if (createdStandardPelt)
            {
                var standard = PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_PELT_STD_RECIPE.Resolve(LinkCache));
                standard.CreatedObjectCount = (ushort)data.Prototype.PeltCount[1];
                if (standard.Items?[0].Item is ContainerItem containerItem2) containerItem2.Item = pelts.Item2.ToLink();
                if (standard.Conditions?[4].Data is FunctionConditionData data2) data2.ParameterOneRecord = pelts.Item2.ToLink();
                standard.EditorID = $"_DS_Recipe_Pelt_{data.InternalName}_01";
            }

            var poor = PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_PELT_POOR_RECIPE.Resolve(LinkCache));
            var fine = PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_PELT_FINE_RECIPE.Resolve(LinkCache));
            var flawless = PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_PELT_FLAWLESS_RECIPE.Resolve(LinkCache));

            poor.EditorID = $"_DS_Recipe_Pelt_{data.InternalName}_00";
            fine.EditorID = $"_DS_Recipe_Pelt_{data.InternalName}_02";
            flawless.EditorID = $"_DS_Recipe_Pelt_{data.InternalName}_03";

            poor.CreatedObjectCount = (ushort)data.Prototype.PeltCount[0];
            fine.CreatedObjectCount = (ushort)data.Prototype.PeltCount[2];
            flawless.CreatedObjectCount = (ushort)data.Prototype.PeltCount[2];

            if (poor.Items?[0].Item is ContainerItem containerItem1) containerItem1.Item = pelts.Item1.ToLink();
            if (fine.Items?[0].Item is ContainerItem containerItem3) containerItem3.Item = pelts.Item3.ToLink();
            if (flawless.Items?[0].Item is ContainerItem containerItem4) containerItem4.Item = pelts.Item4.ToLink();

            if (poor.Conditions?[4].Data is FunctionConditionData data1) data1.ParameterOneRecord = pelts.Item1.ToLink();
            if (fine.Conditions?[4].Data is FunctionConditionData data3) data3.ParameterOneRecord = pelts.Item3.ToLink();
            if (flawless.Conditions?[4].Data is FunctionConditionData data4) data4.ParameterOneRecord = pelts.Item4.ToLink();

            fine.CreatedObject = pelts.Item2.ToNullableLink();
            flawless.CreatedObject = pelts.Item3.ToNullableLink();

            if (DebuggingMode) Write.Success(3, $"Created new tanning recipes.");
        }

        if (data.Prototype.FurPlateCount.Length >= 3)
        {
            var poor = PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_FURS_POOR_RECIPE.Resolve(LinkCache));
            var standard = PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_FURS_STD_RECIPE.Resolve(LinkCache));
            var fine = PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_FURS_FINE_RECIPE.Resolve(LinkCache));

            poor.EditorID = $"HB_Recipe_FurPlate_{data.InternalName}_00";
            standard.EditorID = $"HB_Recipe_FurPlate_{data.InternalName}_01";
            fine.EditorID = $"HB_Recipe_FurPlate_{data.InternalName}_02";

            poor.CreatedObjectCount = (ushort)data.Prototype.FurPlateCount[0];
            standard.CreatedObjectCount = (ushort)data.Prototype.FurPlateCount[1];
            fine.CreatedObjectCount = (ushort)data.Prototype.FurPlateCount[2];

            if (poor.Items?[0].Item is ContainerItem containerItem1) containerItem1.Item = pelts.Item1.ToLink();
            if (standard.Items?[0].Item is ContainerItem containerItem2) containerItem2.Item = pelts.Item2.ToLink();
            if (fine.Items?[0].Item is ContainerItem containerItem3) containerItem3.Item = pelts.Item3.ToLink();

            if (poor.Conditions?[4].Data is FunctionConditionData data1) data1.ParameterOneRecord = pelts.Item1.ToLink();
            if (standard.Conditions?[4].Data is FunctionConditionData data2) data2.ParameterOneRecord = pelts.Item2.ToLink();
            if (fine.Conditions?[4].Data is FunctionConditionData data3) data3.ParameterOneRecord = pelts.Item3.ToLink();

            if (DebuggingMode) Write.Success(3, $"Created new fur-plate recipes.");
        }
    }

    /// <summary>
    /// Creates standard, campfire, primitive cooking, and jerky recipes for created meats.
    /// </summary>
    /// 
    private void CreateMeatRecipes(CreatureData data, MeatSet meats)
    {
        var recipeCooked = PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_CHARRED_RECIPE.Resolve(LinkCache));
        var recipeCampfire = PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_CAMPFIRE_RECIPE.Resolve(LinkCache));
        var recipePrimitive = PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_PRIMITIVE_RECIPE.Resolve(LinkCache));
        var recipeJerky = PatchMod.ConstructibleObjects.DuplicateInAsNewRecord(DEFAULT_JERKY_RECIPE.Resolve(LinkCache));

        (var meat, var cooked, var jerky) = meats;

        recipeCooked.EditorID = $"_DS_Recipe_Food_CharredMeat_{data.InternalName}";
        recipeCampfire.EditorID = $"HB_Recipe_FireFood_CharredMeat_{data.InternalName}";
        recipePrimitive.EditorID = $"_DS_Recipe_Food_Primitive_CharredMeat_{data.InternalName}";
        recipeJerky.EditorID = $"_DS_Recipe_Food_{data.InternalName}Jerky";

        if (recipeCooked.Items?[0].Item is ContainerItem containerItem0) containerItem0.Item = meat.ToLink();
        if (recipeCampfire.Items?[0].Item is ContainerItem containerItem1) containerItem1.Item = meat.ToLink();
        if (recipePrimitive.Items?[0].Item is ContainerItem containerItem2) containerItem2.Item = meat.ToLink();
        if (recipeJerky.Items?[1].Item is ContainerItem containerItem3) containerItem3.Item = meat.ToLink();

        if (recipeCooked.Conditions?[1].Data is ConditionData data0) data0.Reference = meat.ToLink();
        if (recipeJerky.Conditions?[3].Data is ConditionData data3) data3.Reference = meat.ToLink();

        recipeCooked.CreatedObject = cooked.ToNullableLink();
        recipeJerky.CreatedObject = jerky.ToNullableLink();

        if (DebuggingMode) Write.Success(3, $"Created new meat recipes.");
    }

    /// <summary>
    /// To be recognized as a creature by the patcher, an Npc must not belong to any of these factions.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    readonly private HashSet<IFormLinkGetter<IFactionGetter>> ForbiddenFactions = new() {
        Dawnguard.Faction.DLC1VampireFaction,
        Dragonborn.Faction.DLC2AshSpawnFaction,
        Skyrim.Faction.DragonPriestFaction,
        Skyrim.Faction.DraugrFaction,
        Skyrim.Faction.DwarvenAutomatonFaction,
        Skyrim.Faction.IceWraithFaction,
        Dawnguard.Faction.SoulCairnFaction,
        Skyrim.Faction.VampireFaction,
        Skyrim.Faction.WispFaction
    };

    /// <summary>
    /// To be recognized as a creature by the patcher, an Npc must not have any of these keywords.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    readonly private HashSet<IFormLinkGetter<IKeywordGetter>> ForbiddenKeywords = new() {
        Skyrim.Keyword.ActorTypeGhost,
        Skyrim.Keyword.ActorTypeNPC
    };

    /// <summary>
    /// Voices of creatures. To be recognized as a creature by the patcher, an Npc must have a voiceType from
    /// this list.
    /// 
    /// VoiceTypes from addons will get added to this list at runtime.
    /// Isn't that forward thinking? Why don't the other Forbidden/Allowed lists get
    /// populated from addons?
    /// 
    /// </summary>
    readonly private HashSet<IFormLinkGetter<IVoiceTypeGetter>> AllowedVoices = new() {
        Skyrim.VoiceType.CrBearVoice,
        Skyrim.VoiceType.CrChickenVoice,
        Skyrim.VoiceType.CrCowVoice,
        Skyrim.VoiceType.CrDeerVoice,
        Skyrim.VoiceType.CrDogVoice,
        Dawnguard.VoiceType.CrDogHusky,
        Skyrim.VoiceType.CrFoxVoice,
        Skyrim.VoiceType.CrGoatVoice,
        Skyrim.VoiceType.CrHareVoice,
        Skyrim.VoiceType.CrHorkerVoice,
        Skyrim.VoiceType.CrHorseVoice,
        Skyrim.VoiceType.CrMammothVoice,
        Skyrim.VoiceType.CrMudcrabVoice,
        Skyrim.VoiceType.CrSabreCatVoice,
        Skyrim.VoiceType.CrSkeeverVoice,
        Skyrim.VoiceType.CrSlaughterfishVoice,
        Skyrim.VoiceType.CrWolfVoice,
        Dragonborn.VoiceType.DLC2CrBristlebackVoice,
        Skyrim.VoiceType.CrChaurusVoice,
        Skyrim.VoiceType.CrFrostbiteSpiderVoice,
        Skyrim.VoiceType.CrFrostbiteSpiderGiantVoice,
        Skyrim.VoiceType.CrSprigganVoice,
        Skyrim.VoiceType.CrTrollVoice,
        Skyrim.VoiceType.CrWerewolfVoice,
        Skyrim.VoiceType.CrDragonVoice,
        Dawnguard.VoiceType.CrChaurusInsectVoice
    };

    /// <summary>
    /// A list of EditorIDs of creatures that should never be processed.
    /// I wish this was explained.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    readonly private List<string> ForbiddenNpcEditorIds = new() { "HISLCBlackWolf", "BSKEncRat" };

    /// <summary>
    /// A list of DeathItems that should never be processed. 
    /// Creatures with one of these DeathItems should be ignored by Hunterborn and by this patcher.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    readonly List<FormLink<DeathItemGetter>> ForbiddenDeathItems = new() {
        Skyrim.LeveledItem.DeathItemDragonBonesOnly,
        Skyrim.LeveledItem.DeathItemVampire,
        Skyrim.LeveledItem.DeathItemForsworn,
        Dawnguard.LeveledItem.DLC1DeathItemDragon06,
        Dawnguard.LeveledItem.DLC1DeathItemDragon07,
        new(new FormKey(new("Skyrim Immersive Creatures Special Edition", type : ModType.Plugin), 0x11B217))
    };

    public bool IsCreature(INpcGetter npc)
    {
        var deathItem = npc.DeathItem;
        var edid = npc.EditorID;

        if (edid is not null && HasForbiddenEditorId(edid)) return false;
        else if (deathItem == null) return false;
        else if (HasForbiddenDeathItem(deathItem)) return false;
        else if (HasForbiddenKeyword(npc)) return false;
        else if (HasForbiddenFaction(npc)) return false;
        else if (!HasAllowedVoice(npc)) return false;
        else return true;
    }

    private bool HasForbiddenEditorId(string editorId) => ForbiddenNpcEditorIds.Any(edid => edid.EqualsIgnoreCase(editorId));

    private bool HasForbiddenFaction(INpcGetter creature) =>
        creature.Factions.Any(placement => ForbiddenFactions.Contains(placement.Faction));

    private bool HasForbiddenKeyword(INpcGetter creature) =>
        creature.Keywords?.Any(keyword => ForbiddenKeywords.Contains(keyword)) ?? false;

    private bool HasAllowedVoice(INpcGetter creature) => AllowedVoices.Contains(creature.Voice);

    private bool HasForbiddenDeathItem(IFormLinkGetter<ILeveledItemGetter> deathItem) => ForbiddenDeathItems.Contains(deathItem);

    /// <summary>
    /// Convenience method for creating new LeveledItemEntry.
    /// No extra data is added.
    /// </summary>
    /// <param internalName="item">The entryItem.</param>
    /// <param internalName="level">The player level.</param>
    /// <param internalName="count">The entryItem count.</param>
    /// <returns></returns>
    static LeveledItemEntry CreateLeveledItemEntry(IFormLinkGetter<IItemGetter> item, int level, int count) =>
        new() { Data = new LeveledItemEntryData { Reference = (IFormLink<IItemGetter>)item, Level = (short)level, Count = (short)count } };

    /// <summary>
    /// Convenience method for creating new ScriptObjectProperty wrapping a FormLink.
    /// It has to turn the Getter into a Setter internally.
    /// </summary>
    /// <param internalName="item">The FormLinkGetter.</param>
    /// <returns>The ScriptObjectProperty.</returns>
    static ScriptObjectProperty CreateProperty<T>(IFormLinkGetter<T> item) where T : class, ISkyrimMajorRecordGetter
    {
        var link = item.FormKey.ToLink<ISkyrimMajorRecordGetter>();
        return new() { Object = link };
    }

    public bool IsCacoInstalled() => LoadOrder.ContainsKey(CACO_MODKEY);
    public bool IsLastSeedInstalled() => LoadOrder.ContainsKey(LASTSEED_MODKEY);

    private Func<IFormLinkGetter<IItemGetter>, IFormLinkGetter<IItemGetter>> FormLinkSubstitution { get; }

    private Func<IItemGetter, IItemGetter> ItemSubstitution { get; }


    /// <summary>
    /// Breaks a set of names into parts based on capital letters, spaces, underlines, and dashes.
    /// They are returned as a single set.
    /// 
    /// </summary>
    /// 
    static public HashSet<string> TokenizeNames(IEnumerable<string?> names) => names.Where(n => !n.IsNullOrWhitespace()).SelectMany(TokenizeName).ToHashSet();
    static public HashSet<string> TokenizeNames(params string?[] names) => names.Where(n => !n.IsNullOrWhitespace()).SelectMany(TokenizeName).ToHashSet();


    /// <summary>
    /// Breaks a internalName into parts based on capital letters, spaces, underlines, and dashes.
    /// 
    /// </summary>
    /// 
    static public HashSet<string> TokenizeName(string? name)
    {
        if (name.IsNullOrWhitespace()) return new();

        var filtered = TOKENIZER_FILTER.Replace(name, "");
        var tokens = TOKENIZER_BREAK_SPLITTER.Split(filtered);
        if (tokens == null || tokens.Length == 0) return new();

        return tokens.SelectMany(t => TOKENIZER_CAMEL_SPLITTER.Split(t)).Where(t => !t.IsNullOrWhitespace()).ToHashSet();
    }

    readonly static private Regex TOKENIZER_FILTER = new("[^A-Za-z0-9 _-]");
    readonly static private Regex TOKENIZER_BREAK_SPLITTER = new("[ _-]");
    readonly static private Regex TOKENIZER_CAMEL_SPLITTER = new("([A-Z]+[a-z0-9]*)");

    private string NpcNamer(INpcGetter npc) => FormNamer(npc, () => LinkNamer(npc.Race, () => FormIDNamer(npc)));
    private static string DeathItemNamer(DeathItemGetter deathItem) => FormNamer(deathItem);
    private static string ItemNamer(IItemGetter item) => FormNamer(item);

    //private string NpcNamerFallback(INpcGetter npc) => NpcNamer(npc) ?? NpcRaceNamer(npc) ?? FormIDNamer(npc);
    //static private string DeathItemNamerFallback(DeathItemGetter deathItem) => DeathItemNamer(deathItem) ?? FormIDNamer(deathItem);
    //static private string ItemNamerFallback(IItemGetter item)
    //=> item.EditorID ?? FormIDNamer(item);
    //private string? NpcRaceNamer(INpcGetter npc) => RaceNamer(npc.Race.Resolve(LinkCache));
    //private string? NpcDeathItemNamer(INpcGetter npc) => DeathItemNamer(npc.DeathItem?.Resolve(LinkCache));

    /// <summary>
    /// Wraps for <code>BasicNamer</code> for <code>INpcGetter</code>.
    /// </summary>
    //static private string? NpcNamer(INpcGetter npc) => FormNamer(npc);

    //static private string? RaceNamer(IRaceGetter? race) => FormNamer(race);
    //static private string? DeathItemNamer(DeathItemGetter? deathItem) => deathItem?.EditorID;
    static private string FormIDNamer(IMajorRecordGetter? thing) => thing?.FormKey.IDString() ?? "NULL";

    /// <summary>
    /// Returns name of <code>thing</code>. 
    /// If no name is available, returns the EditorID of <code>thing</code>.
    /// If no EditorID is available, returns null;
    /// </summary>
    /// 
    private string LinkNamer(IFormLinkGetter<IMajorRecordGetter>? thing, Func<string?>? fallback = null)
    {
        if (thing is null) return "<NULL>";
        thing.TryResolve(LinkCache, out var form);
        return FormNamer(form, fallback);
    }

    /// <summary>
    /// Returns name of <code>thing</code>. 
    /// If no name is available, returns the EditorID of <code>thing</code>.
    /// If no EditorID is available, returns null;
    /// </summary>
    /// 
    static private string FormNamer(IMajorRecordGetter? thing, Func<string?>? fallback = null)
    {
        if (thing is INamedGetter named && named.Name?.ToString() is string name) return name;
        else if (thing is ISkyrimMajorRecordGetter rec && rec.EditorID is string edid) return edid;
        else if (fallback is not null && fallback() is string fallbackName) return fallbackName;
        else return FormIDNamer(thing);
    }

    public record CreatureData(DeathItemGetter DeathItem, string InternalName, PluginEntry Prototype, bool IsAnimal, bool IsMonster);
    private static Lazy<Settings.Settings> _settings = null!;

    /// <summary>
    /// Matcher for pre-existing pelts items.
    /// </summary>
    static readonly private Regex DefaultPeltRegex = new("Pelt|Hide|Skin|Fur|Wool|Leather", RegexOptions.IgnoreCase);

    /// <summary>
    /// Matcher for pre-existing meat items.
    /// </summary>
    static readonly Regex DefaultMeatRegex = new("Meat|Flesh", RegexOptions.IgnoreCase);

    /// <summary>
    /// Used to strip invalid editorID characters from a string.
    /// </summary>
    static readonly private Regex EditorIdFilter = new("[^a-zA-Z0-9_]", RegexOptions.IgnoreCase);

    /// <summary>
    /// Matcher for plugin names. 
    /// A match occurs if the plugin internalName is contained in the target string.
    /// Case-insensitive.
    /// 
    /// </summary>
    /// <param internalName="str">The string against which to match the plugin names.</param>
    /// <returns>The matcher.</returns>
    /// 
    static Func<PluginEntry, bool> PluginNameMatch(string str) => plugin => str.ContainsInsensitive(plugin.Name);

    /// <summary>
    /// This thing is ridiculous but convenient. Can you say "Currying"?
    /// 
    /// </summary>
    /// 
    static Func<int, Action<T>> DictionaryIncrementer<T>(Dictionary<T, int> dict) where T : notnull
        => val => plugin => { if (val > 0) dict[plugin] = dict.GetValueOrDefault(plugin, 0) + val; };


    /// <summary>
    /// Default carcasses for each Plugin, so that they can be copied.
    /// This is useful if the default carcass has an interesting model or keywords.
    /// </summary>
    private Dictionary<PluginEntry, IMiscItemGetter> KnownCarcasses { get; } = new();

    /// <summary>
    /// Contains prototypes for which a full pelt set and recipe set already exist.
    /// </summary>
    private Dictionary<PluginEntry, PeltSet> KnownPelts { get; } = new();

    /// <summary>
    /// Associates DeathItems with plugins. Mainly used to avoid processing a DeathItem more than once.
    /// </summary>
    private OrderedDictionary<DeathItemGetter, PluginEntry> KnownDeathItems { get; } = new();

    private Settings.Settings Settings { get; }
    //private IPatcherState<ISkyrimMod, ISkyrimModGetter> State { get; }
    private ILinkCache<ISkyrimMod, ISkyrimModGetter> LinkCache { get; }
    private ILoadOrder<IModListing<ISkyrimModGetter>> LoadOrder { get; }
    private ISkyrimMod PatchMod { get; }
    private bool DebuggingMode { get { return Settings.DebuggingMode; } }

}

