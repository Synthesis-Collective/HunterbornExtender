namespace HunterbornExtender;
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Noggog;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins.Cache;
using System.Linq;
using System.Text.RegularExpressions;
using Mutagen.Bethesda.Plugins.Records;
using Microsoft.CodeAnalysis;
using DynamicData;
using HunterbornExtender.Settings;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Plugins.Aspects;
using static HunterbornExtender.FormKeys;
using DeathItemGetter = Mutagen.Bethesda.Skyrim.ILeveledItemGetter;
using System.Text.Json;
using System.Globalization;


#pragma warning disable IDE1006 // Naming Styles

sealed internal class Program
{

    record CreatureData(DeathItemGetter DeathItem, String InternalName, PluginEntry Prototype, bool IsAnimal, bool IsMonster);
    static readonly Dictionary<PluginEntry, IMiscItemGetter> KnownCarcasses = new();
    static readonly Dictionary<PluginEntry, IFormLinkGetter<IItemGetter>[]> KnownPelts = new();
    static readonly Dictionary<DeathItemGetter, PluginEntry> KnownDeathItems = new();
    private static Lazy<Settings.Settings> _settings = null!;


    public static Task<int> Main(string[] args)
    {
        return SynthesisPipeline.Instance
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch, new PatcherPreferences()
            {
                ExclusionMods = new List<ModKey>() {
                    new ModKey("HunterbornExtenderPatch.esp", ModType.Plugin),
                },
            })
            .SetTypicalOpen(GameRelease.SkyrimSE, "HunterbornExtenderPatch.esp")
            .SetAutogeneratedSettings("settings", "settings.json", out _settings)
            .Run(args);
    }


    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        /*
        PatcherSettings jsonData;
        try
        {
            WriteLog("Trying to load stored DeathItem selections.");
            jsonData = JSONhandler<PatcherSettings>.LoadJSONFile("settings.json") ?? new();
            WriteLog(1, true, $"Read {jsonData.DeathItems.Count} selections and {jsonData.Plugins.Count} plugins.");
            else throw new InvalidOperationException("No data.");
        }
        catch (Exception ex)
        {
            WriteLog(0, false, "Failed to load stored DeathItem selections.");
            Console.WriteLine("=================================");
            Console.WriteLine(ex);
            Console.WriteLine("=================================");
            return;
        }*/


        //
        // However we do it, this is where we get a List<PluginEntry> from the addon jsons.
        //
        var settings = _settings.Value;

        Console.WriteLine(Divider);
        WriteAction(0, "Importing plugins.");
        var addonPlugins = LegacyConverter.ImportAndConvert(state);
        WriteSuccess(0, $"{addonPlugins.Count} creature types imported.");

        //
        // Resolve and locate all the FormLists and ScriptProperties that need patching.
        // 
        StandardRecords std;
        try
        {
            Console.WriteLine(Divider);
            WriteAction(0, "Trying to resolve required forms from Hunterborn.esp, and preparing the patch structure.");
            std = CreateStandardRecords(state, settings);
            WriteSuccess(0, $"Success: {std.PatchMod}");
        }
        catch (RecordException ex)
        {
            WriteFail(0, $"Failed to resolve required forms because of unresolved reference [{ex.FormKey} {ex.EditorID}].");
            WriteFail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            WriteFail(0, "Failed to resolve required forms.");
            WriteFail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        //
        // Create a List<PluginEntry> for the hard-coded creatures.
        // Merge it into the previous list.
        //
        List<InternalPluginEntry> internalPlugins;
        
        try
        {
            Console.WriteLine(Divider);
            WriteAction(0, "Trying to recreate the hard-coded core plugin from Hunterborn.esp.");
            internalPlugins = RecreateCorePlugins(std);

            if (internalPlugins.Count > 0)
            {
                WriteSuccess(0, $"Success: {internalPlugins.Count} hard-coded creature types found.");
            } 
            else
            {
                WriteFail(0, $"No hard-coded creature types found. Check your Hunterborn installation.");
                return;
            }
        }
        catch (RecordException ex)
        {
            WriteFail(0, $"Failed to recreate core plugin because of unresolved reference [{ex.FormKey} {ex.EditorID}].");
            WriteFail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            WriteFail(0, "Failed to recreate core plugin.");
            WriteFail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        List<PluginEntry> plugins = new();
        plugins.AddRange(internalPlugins);
        plugins.AddRange(addonPlugins);
        settings.Plugins = plugins;
        WriteSuccess(0, $"Add-on creatures and hard-coded creatures merged; {plugins.Count} total.");

        // 
        // Import allowed and forbidden values from plugins.
        //
        foreach (var plugin in plugins)
        {
            if (!plugin.Voice.IsNull) AllowedVoices.Add(plugin.Voice);
        }

        //
        // Populates the KnownDeathItem, KnownCarcass, and KnownPelts structures.
        //
        try
        {
            PopulateKnown(plugins, std);
        }
        catch (RecordException ex)
        {
            WriteFail(0, $"Failed to crossreference Hunterborn.esp with the Internal plugins because of reference [{ex.FormKey} {ex.EditorID}].");
            WriteFail(0, $"THIS MAY INDICATE THAT YOU NEED TO CHECK THE HUNTERBORNEXTENDER SETTINGS.");
            WriteFail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            WriteFail(0, $"Failed to crossreference Hunterborn.esp with the Internal plugins.");
            WriteFail(0, $"THIS MAY INDICATE THAT YOU NEED TO CHECK THE HUNTERBORNEXTENDER SETTINGS.");
            WriteFail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        //
        // Link death item selection to corresponding creature entry
        //
        foreach (var deathItem in settings.DeathItemSelections)
        {
            deathItem.Selection = plugins.Where(x => x.Name == deathItem.CreatureEntryName).FirstOrDefault();
        }

        WriteSuccess(0, $"Imported death plugin support for {plugins.Count} creatures");
        WriteSuccess(0, $"Imported {settings.DeathItemSelections.Length} death item selections");


        // Heuristic matching and user selections should already be done.
        //
        // Scan the load order and update the selections.
        // 
        try
        {
            WriteAction(0, $"Running heuristics.");
            int heuristics = MakeHeuristicSelections(plugins, settings, state);
            WriteSuccess(0, $"Heuristics assigned {heuristics} creatures.");
        }
        catch (RecordException ex)
        {
            WriteFail(0, $"Missing reference during heuristic: [{ex.FormKey} {ex.EditorID}].");
            WriteFail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            WriteFail(0, $"Error during heuristics.");
            WriteFail(0, ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        //
        //================
        //================

        foreach (var selection in settings.DeathItemSelections)
        {
            var name = selection.CreatureEntryName;
            //Console.WriteLine(CreateTitle(name));

            PluginEntry? prototype = selection.Selection;

            // null is used to indicate "SKIP".
            if (prototype == null)
            {
                if (settings.DebuggingMode) Console.WriteLine(CreateTitle($"(SKIPPED) {name}"));
                continue;
            }

            Console.WriteLine(CreateTitle($"{name} -> {prototype.Name}"));

            try
            {
                var deathItem = state.LinkCache.Resolve<DeathItemGetter>(selection.DeathItem);
                var data = CreateCreatureData(deathItem, prototype, std);
                if (settings.DebuggingMode) WriteSuccess(1, $"Creating creature Data structure.");

                if (ForbiddenDeathItems.Contains(data.DeathItem.ToLink()))
                {
                    WriteFail(1, $"Skipped {name}: DeathItem blacklisted.");
                }
                else if (KnownDeathItems.ContainsKey(data.DeathItem))
                {
                    WriteFail(1, $"Skipped {name}: DeathItem already processed.");
                } 
                else
                {
                    KnownDeathItems.Add(data.DeathItem, prototype);
                    AddRecord(data, std);
                }
            }
            catch (RecordException ex)
            {
                WriteFail(1, $"Skipped {name}: DeathItem [{ex.FormKey} {ex.EditorID}] could not be resolved");
            }
            catch (DeathItemAlreadyAddedException)
            {
                WriteFail(1, $"Skipped {name}: DeathItem already processed.");
            }
            catch (NoDeathItemException)
            {
                WriteFail(1, $"Skipped {name}: No DeathItem.");
            }
            catch (Exception ex)
            {
                WriteFail(1, $"Skipped {name}: {ex.Message}");
                Console.WriteLine(ex.StackTrace);
            }
        }
    }

    /// <summary>
    /// This should be called from the UI to pre-select the choices for each deathitem.
    /// 
    /// If Settings.ReuseSelections is enabled then selections in the settings will be preferred.
    /// Everything still gets scanned anyway in case the loadorder has changed.
    /// 
    /// The selections array in Settings is replaced with a new one.
    /// 
    /// </summary>
    /// 
    static int MakeHeuristicSelections(List<PluginEntry> plugins, Settings.Settings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        // For each DeathItem, there will be a weighted set of plausible Plugins.
        // HeuristicMatcher assigns the weights.
        Dictionary<DeathItemSelection, Dictionary<PluginEntry, int>> selectionWeights = new();
        Dictionary<DeathItemGetter, DeathItemSelection> indexer = new();

        foreach (var npc in state.LoadOrder.PriorityOrder.Npc().WinningOverrides().Where(IsCreature))
        {
            //if (settings.DebuggingMode) WriteAction(2, $"Heuristics examining {npc}");
            if (npc.DeathItem?.IsNull ?? true) continue;
            
            var deathItem = npc.DeathItem.Resolve(state.LinkCache);
            if (KnownDeathItems.ContainsKey(deathItem)) continue;

            // If there is no DeathItemSelection record for the NPC's DeathItem, create it.
            // Try as hard as possible to give the DeathItemSelection a name. Fallbacks on fallbacks.
            if (!indexer.ContainsKey(deathItem))
            {
                indexer[deathItem] = new DeathItemSelection()
                {
                    DeathItem = deathItem.FormKey,
                    CreatureEntryName = deathItem.EditorID ?? npc.EditorID ?? npc.Name?.ToString() ?? Guid.NewGuid().ToString()
                };
                selectionWeights[indexer[deathItem]] = new();
            }

            // Add the NPC to the assigned NPCs of the DeathItemSelection.
            var deathItemSelection = indexer[deathItem];
            deathItemSelection.AssignedNPCs.Add(npc);

            // Run the heuristic matcher.
            var npcWeights = HeuristicNpcMatcher(npc, plugins, state.LinkCache);
            var itemWeights = selectionWeights[deathItemSelection];

            foreach (PluginEntry plugin in npcWeights.Keys)
                itemWeights[plugin] = itemWeights.GetValueOrDefault(plugin, 0) + npcWeights[plugin];
        }

        DeathItemSelection[] selections = selectionWeights.Keys.ToArray();
        Dictionary<FormKey, PluginEntry?> savedSelections = settings.DeathItemSelections.ToDictionary(v => v.DeathItem, v => v.Selection);
        int modifiedCount = 0;

        foreach (var selection in selections)
        {
            if (settings.ReuseSelections && savedSelections.ContainsKey(selection.DeathItem))
            {
                selection.Selection = savedSelections[selection.DeathItem];
                if (settings.DebuggingMode) Console.WriteLine($"\t\t\tPreviously selected {selection.Selection?.ProperName}.");
            }
            else
            {
                var itemWeights = selectionWeights[selection];
                List<PluginEntry> options = new(itemWeights.Keys);
                if (options.Count == 0) continue;

                options.Sort((a, b) => itemWeights[b].CompareTo(itemWeights[a]));
                selection.Selection = options.First();
                if (settings.DebuggingMode && selection.DeathItem != null)
                {
                    state.LinkCache.TryResolve<ILeveledItemGetter>(selection.DeathItem, out var deathItem);
                    Console.WriteLine($"\t\t{deathItem?.EditorID ?? deathItem?.ToString() ?? "NO DEATH ITEM"}: heuristic selected {selection.Selection?.ProperName}.");
                    Console.WriteLine($"\t\t\tFrom: {itemWeights.Pretty()}");
                }
                modifiedCount = 0;
            }
        }

        settings.DeathItemSelections = selections;
        return modifiedCount;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    static Dictionary<PluginEntry, int> HeuristicNpcMatcher(INpcGetter npc, List<PluginEntry> plugins, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        Dictionary<PluginEntry, int> candidates = new();
        var clicker = DictionaryIncrementer(candidates);

        // Try to match the voice.
        if (!npc.Voice.IsNull)
        {
            plugins
                .Where(plugin => !plugin.Voice.IsNull)
                .Where(plugin => plugin.Voice.Equals(npc.Voice))
                .ForEach(clicker(10));
        }

        // Match the creature's editorId, name, and race name to the names of plugins.
        var nameMatches = new HashSet<PluginEntry>();
        var race = npc.Race.Resolve(linkCache);

        if (npc.EditorID is string npcEditorId) plugins.Where(PluginNameMatch(npcEditorId)).ForEach(clicker(1));
        if (npc.Name?.ToString() is string npcName) plugins.Where(PluginNameMatch(npcName)).ForEach(clicker(1));
        if (race.EditorID is string raceEditorId) plugins.Where(PluginNameMatch(raceEditorId)).ForEach(clicker(1));
        if (race.Name?.ToString() is string raceName) plugins.Where(PluginNameMatch(raceName)).ForEach(clicker(1));

        // @TODO Add matching for distinctive keywords?
        // @TODO Add exclusion terms?

        return candidates;
    }

    /// <summary>
    /// Matcher for plugin names. 
    /// A match occurs if the plugin name is contained in the target string.
    /// Case-insensitive.
    /// 
    /// </summary>
    /// <param name="str">The string against which to match the plugin names.</param>
    /// <returns>The matcher.</returns>
    /// 
    static Func<PluginEntry,bool> PluginNameMatch(String str) => plugin => str.ContainsInsensitive(plugin.Name);

    /// <summary>
    /// This thing is ridiculous but convenient. Can you say "Currying"?
    /// 
    /// </summary>
    /// 
    static Func<int,Action<T>> DictionaryIncrementer<T>(Dictionary<T,int> dict) where T : notnull 
        => val => plugin => dict[plugin] = dict.GetValueOrDefault(plugin, 0) + val;

    /// <summary>
    /// Populate the KnownDeathItems, KnownCarcasses, and KnownPelts.
    /// Having these means that when new Pelts, DeathItems, and Carcasses get created, they
    /// can copy the models and keywords from existing ones.
    /// 
    /// </summary>
    /// 
    /// <param name="plugins"></param>
    /// <param name="std"></param>
    /// <exception cref="CoreRecordMissing"></exception>
    /// <exception cref="InvalidOperationException"></exception>
    /// 
    static void PopulateKnown(List<PluginEntry> plugins, StandardRecords std)
    {

        Dictionary<FormKey, InternalPluginEntry> internalPlugins = new();
        foreach (var plugin in plugins)
        {
            if (plugin is InternalPluginEntry p) internalPlugins[p.KnownDeathItem] = p;
            //if (plugin is InternalPluginEntry p2) Console.WriteLine($"Recreating FormKey->Plugin:  {p2.KnownDeathItem,-12} -> {p2.ProperName}");
            //else Console.WriteLine($"Recreating FormKeys: not internal {plugin.ProperName}");
        }


        foreach (EntryType type in Enum.GetValues(typeof(EntryType)))
        {
            int count = std.GetCCFor(type).RaceIndex.Data.Count;
            WriteAction(1, $"Populating data structures for {count} {type} types.");

            // This basically comes down to going through the FormList of deathitems (once for animals and once for monsters),
            // determining which InternalPlugin each DeathItem corresponds to, and then
            // * Put the DeathItem->Plugin entry into KnownDeathItems.
            // * Put the corresponding entry from the Pelts formlist into KnownPelts.
            // * Put the corresponding entry from the Carcasses entry into KnownCarcasses.
            // * @TODO Same for materials?
            for (int index = 0; index < count; index++)
            {
                try
                {
                    var name = std.GetCCFor(type).RaceIndex.Data[index];

                    // Get the DeathItem link from the formlist and resolve it.
                    std.LinkCache.TryResolve<DeathItemGetter>(std.GetCCFor(type)._DS_FL_DeathItems.Items[index].FormKey, out var deathItem);
                    if (deathItem == null) throw new DataConsistencyError(type, name, index, "No DeathItem.");
                    if (KnownDeathItems.ContainsKey(deathItem)) continue;

                        // Match the DeathItem to the plugin it came from.
                        // Fatal error if it's not found.
                        if (!internalPlugins.ContainsKey(deathItem.FormKey))
                    {
                        Console.WriteLine($"Fatal error: internalPlugin for {deathItem} is missing.");
                        throw new CoreRecordMissing(deathItem.ToLink());
                    }

                    // Finally, put the DeathItem in KnownDeathItems.
                    var plugin = internalPlugins[deathItem.FormKey];
                    KnownDeathItems.Add(deathItem, plugin);

                    // Get the Carcass link from the formlist, resolve it, and put it in KnownCarcasses.
                    // Only animals have carcasses. I guess you can't carry monster corpses around.
                    if (type == EntryType.Animal)
                    {
                        if (std.Animals._DS_FL_CarcassObjects.Items[index].Resolve(std.LinkCache) is not IMiscItemGetter carcass)
                            throw new CoreRecordMissing(std.Animals._DS_FL_CarcassObjects.Items[index]);
                        KnownCarcasses.Add(plugin, carcass);
                    }

                    // Get the Pelts link from the formlist, resolve it, transform it into an array, and put it in KnownPelts.
                    if (std.GetCCFor(plugin.Type)._DS_FL_PeltLists.Items[index].Resolve(std.LinkCache) is not IFormListGetter pelts)
                        throw new CoreRecordMissing(std.GetCCFor(plugin.Type)._DS_FL_PeltLists.Items[index]);

                    IFormLinkGetter<IItemGetter>[] peltsArray = pelts.Items.Select(item => item.FormKey.ToLinkGetter<IItemGetter>()).ToArray();
                    if (peltsArray.Length != 0 && peltsArray.Length != 4)
                        throw new InvalidOperationException($"Wrong length for pelts: {plugin.Name} -- {std.GetCCFor(plugin.Type)._DS_FL_PeltLists.Items[index]}");
                    KnownPelts.Add(plugin, peltsArray);
                } 
                catch (DataConsistencyError ex)
                {
                    WriteFail(0, "WARNING: inconsistent data detected. This may be the result of some other mod patching Hunterborn.");
                    WriteFail(0, ex.Message);
                }
            }
        }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="std"></param>
    /// <returns></returns>
    static List<InternalPluginEntry> RecreateCorePlugins(StandardRecords std)
    {
        List<InternalPluginEntry> plugins = new();

        foreach (EntryType type in Enum.GetValues(typeof(EntryType)))
        {
            int count = std.GetCCFor(type).RaceIndex.Data.Count;
            WriteAction(1, $"Recreating {count} {type} plugin entries.");

            if (std.Settings.DebuggingMode)
            {
                if (type == EntryType.Animal) Console.WriteLine($"\tChecks: names={std.GetCCFor(type)._DS_FL_DeathItems.Items.Count}, pelts={std.GetCCFor(type)._DS_FL_PeltLists.Items.Count}, carcasses={std.Animals._DS_FL_CarcassObjects.Items.Count}");
                else WriteAction(1, $"Checks: names={std.GetCCFor(type)._DS_FL_DeathItems.Items.Count}, pelts={std.GetCCFor(type)._DS_FL_PeltLists.Items.Count}");
            }

            for (int index = 0; index < count; index++)
            {
                try
                {
                    InternalPluginEntry entry = RecreateCorePluginEntry(type, index, std);
                    plugins.Add(entry);
                }
                catch (DataConsistencyError ex)
                {
                    WriteFail(0, "WARNING: inconsistent data detected. This may be the result of some other mod patching Hunterborn.");
                    WriteFail(0, ex.Message);
                }
            }
        }

        return plugins;
    }

    static InternalPluginEntry RecreateCorePluginEntry(EntryType type, int index, StandardRecords std)
    {
        String name = std.GetCCFor(type).RaceIndex.Data[index];
        if (name.IsNullOrWhitespace()) throw new DataConsistencyError(type, name, index, "No name.");

        try
        {
            var deathItemLink = std.GetCCFor(type)._DS_FL_DeathItems.Items[index];
            if (deathItemLink.IsNull) throw new DataConsistencyError(type, name, index, "No DeathItem.");

            std.LinkCache.TryResolve(deathItemLink, out var deathItem);
            if (deathItem == null) throw new DataConsistencyError(type, name, index, "DeathItem could not be resolved.");

            InternalPluginEntry plugin = new(type, name, deathItem.FormKey);

            if (deathItem.EditorID is string deathItemEdid && DeathItemPrefix.IsMatch(deathItemEdid)) 
            {
                string deathItemName = DeathItemPrefix.Replace(deathItemEdid, "");
                if (!deathItemName.EqualsIgnoreCase(plugin.Name))
                {
                    string subtype = deathItemName.Replace(plugin.Name, "", StringComparison.InvariantCultureIgnoreCase);
                    if (!subtype.IsNullOrWhitespace())
                    {
                        plugin.SortName = TextInfo.ToTitleCase($"{plugin.Name} - {subtype}");
                        plugin.ProperName = TextInfo.ToTitleCase($"{subtype} {plugin.Name}");
                        if (std.Settings.DebuggingMode) WriteAction(2, $"Recreating {plugin.Name} from {deathItemEdid} (proper name {plugin.ProperName}, sort name {plugin.SortName}");
                    }
                    else if (std.Settings.DebuggingMode) WriteAction(2, $"Recreating {plugin.Name} from {deathItemEdid}");
                }
                else if (std.Settings.DebuggingMode) WriteAction(2, $"Recreating {plugin.Name} from {deathItemEdid}");
            }
            else if (std.Settings.DebuggingMode) WriteAction(2, $"Recreating {plugin.Name} from {deathItem}");

            var toggle = std.GetCCFor(type).Switches.Objects[index].Object;
            if (toggle.IsNull) plugin.Toggle = new FormLink<IGlobalGetter>();
            else plugin.Toggle = toggle.Resolve<IGlobalGetter>(std.LinkCache).ToLink();

            var meat = std.GetCCFor(type).MeatType.Objects[index].Object;
            if (meat.IsNull) plugin.Meat = new FormLink<IItemGetter>();
            else plugin.Meat = meat.Resolve<IItemGetter>(std.LinkCache).ToLink();

            var shared = std.GetCCFor(type).SharedDeathItems.Objects[index].Object;
            if (shared.IsNull) plugin.SharedDeathItems = new FormLink<IFormListGetter>();
            else plugin.SharedDeathItems = shared.Resolve<IFormListGetter>(std.LinkCache).ToLink();

            plugin.CarcassSize = std.GetCCFor(type).CarcassSizes.Data[index];

            if (type == EntryType.Monster)
            {
                var venom = std.Monsters.VenomItems.Objects[index].Object;
                if (venom.IsNull) plugin.Venom = new FormLink<IIngestibleGetter>();
                else plugin.Venom = venom.Resolve<IIngestibleGetter>(std.LinkCache).ToLink();

                var blood = std.Monsters.BloodItems.Objects[index].Object;
                if (blood.IsNull) plugin.BloodType = new FormLink<IItemGetter>();
                else plugin.BloodType = blood.Resolve<IItemGetter>(std.LinkCache).ToLink();

                plugin.CarcassWeight = 0;
                plugin.CarcassValue = 0;
            }
            else if (type == EntryType.Animal)
            {
                var msg = std.Animals.CarcassMessages.Objects[index].Object;
                if (msg.IsNull) plugin.CarcassMessageBox = new FormLink<IMessageGetter>();
                else plugin.CarcassMessageBox = msg.Resolve<IMessageGetter>(std.LinkCache).ToLink();

                plugin.Venom = new FormLink<IIngestibleGetter>();
                plugin.BloodType = new FormLink<IItemGetter>();

                var carcass = std.Animals._DS_FL_CarcassObjects.Items[index].Resolve<IMiscItemGetter>(std.LinkCache);
                plugin.CarcassWeight = (int)carcass.Weight;
                plugin.CarcassValue = (int)carcass.Value;
            }

            plugin.Discard = type != EntryType.Monster
                ? new()
                : std.Monsters.Discards.Objects[index].Object
                .Resolve<IFormListGetter>(std.LinkCache).Items
                .Select(item => item as IFormLinkGetter<IItemGetter>)
                .Where(item => item != null)
                .Select(item => item!).ToList();

            var mats = std.GetCCFor(type)._DS_FL_Mats__Lists.Items[index].Resolve<IFormListGetter>(std.LinkCache);
            plugin.Materials = RecreateMaterials(mats, std);
            // Console.WriteLine($"===RECREATED MATS FOR {plugin.ProperName}: {plugin.Materials.Pretty()}");

            plugin.PeltCount = Array.Empty<int>();
            plugin.FurPlateCount = Array.Empty<int>();

            // The voice field is unnecessary because the core voices are hard-coded.
            // But it's nice to have it just in case.
            // 
            // We could scan through all NPCs looking for the matching DeathItem and grab the voice of
            // the first match.
            //
            // BUT
            // 
            // Vanilla voices are named very predictably, so just use that.
            //
            std.LinkCache.TryResolve<VoiceType>($"Cr{plugin.Name}Voice", out var voice);
            plugin.Voice = voice == null ? new FormLink<IVoiceTypeGetter>() : voice.ToLink();


            /*
             * @TODO Finish recreating these from recipes.
            entry.Pelts;
            entry.Mats;
            entry.PeltCount;
            entry.FurPlateCount;
            */

            return plugin;

        } 
        catch(RecordException ex)
        {
            Console.WriteLine(CreateTitle($"Problem with {type} {name} {ex.FormKey} {ex.EditorID}"));
            WriteFail(1, $"Problem with {type} {name} {ex.FormKey} {ex.EditorID}");
            WriteFail(1, ex.Message);
            Console.WriteLine(ex.StackTrace);
            throw ex;
        }
    }

    /// <summary>
    /// Regular expression used to turn the names of vanilla DeathItems into useful names.
    /// </summary>
    static private readonly Regex DeathItemPrefix = new(".*DeathItem", RegexOptions.IgnoreCase);

    /// <summary>
    /// Used to make nice names.
    /// </summary>
    static private readonly TextInfo TextInfo = CultureInfo.CurrentCulture.TextInfo;


    /// <summary>
    /// Things that have to be done for each race:
    /// 
    /// 
    /// ==NEW RECORDS==
    /// Create a token MiscItem that identifies the creature as being Hunterborn-enabled.
    /// Create a carcass MiscItem that can go in the player's inventory.
    /// 
    /// Create a materials FormList containing 4 leveled lists of stuff, for the four levels of harvesting skill.
    /// 
    /// Create either 3 or 4 pelt MiscItems (3 if there's a default one the creature already).
    /// Create Leather and Fur Plate recipes for the pelts.
    /// 
    /// Add the creature's DeathItem to the DeathItems formlist.
    /// 
    /// Creature a new CustomDeathItem that contains tokens for the actions supported by the creature.
    /// 
    /// 
    /// ==HUNTERBORN QUEST SCRIPT==
    /// Add the carcass size to its array property.
    /// Add the carcass custom message (if any) to its array property.
    /// Add the CustomDeathItem to its array property.
    /// Add the meat type (if any) to its array property.
    /// Add the meat weight (if any) to its array property.
    /// Add the default pelt value (if any) to its array property.
    /// Add the shared death item (if any) to its array property.
    /// Add the proper name to its array property.
    /// 
    /// For monsters:
    /// Add the venom (if any) to its array property.
    /// Add the blood (if any) to its array property.
    /// Add the "negative treasure" (if any) to its array property.
    /// 
    /// </summary>
    /// 
    static void AddRecord(CreatureData data, StandardRecords std)
    {
        var token = CreateToken(data, std);
        var mats = CreateMaterials(data, std);
        var pelts = CreatePelts(data, std);
        var deathDescriptor = CreateDeathDescriptor(data, std, pelts, mats);
        if (data.IsAnimal) CreateCarcass(data, std);
        if (data.IsMonster) CreateDiscards(data, std);

        std.GetCCFor(data).RaceIndex.Data.Add(data.InternalName);
        std.GetCCFor(data).CarcassSizes.Data.Add(data.Prototype.CarcassWeight);
        std.GetCCFor(data).Switches.Objects.Add(CreateProperty(data.Prototype.Toggle));
        std.GetCCFor(data).SharedDeathItems.Objects.Add(CreateProperty(data.Prototype.SharedDeathItems));

        std.GetCCFor(data).MeatType.Objects.Add(CreateProperty(data.Prototype.Meat));
        if (!data.Prototype.Meat.IsNull)
            std.GetCCFor(data).MeatWeights.Data.Add(std.LinkCache.Resolve(data.Prototype.Meat) is IWeightValueGetter w ? w.Weight : 0.0f);

        if (data.IsMonster)
        {
            std.Monsters.BloodItems.Objects.Add(CreateProperty(data.Prototype.BloodType));
            std.Monsters.VenomItems.Objects.Add(CreateProperty(data.Prototype.Venom));
        } 
        else
        {
            std.Animals.CarcassMessages.Objects.Add(CreateProperty(data.Prototype.CarcassMessageBox));
        }

        if (std.Settings.DebuggingMode)
        {
            Console.WriteLine($"\tCreated new forms:");
            Console.WriteLine($"\t\t o ID Token: {token}");
            Console.WriteLine($"\t\t o Materials: {mats}");
            Console.WriteLine($"\t\t o Pelts: {pelts}");
            Console.WriteLine($"\t\t o Descriptor: {deathDescriptor}");
            Console.WriteLine($"\t\t o Updated quest script properties.");
        }
    }

    static CreatureData CreateCreatureData(DeathItemGetter deathItem, PluginEntry prototype, StandardRecords std)
    {
        CreatureData data = new(deathItem, CreateInternalName(deathItem), prototype, prototype.Type == EntryType.Animal, prototype.Type == EntryType.Monster);
        return data;
    }

    /// <summary>
    /// Creates a unique internal name for the specified DeathItem. 
    /// This is used to derive the editorIds for the new forms that will be created 
    /// for the specified DeathItem.
    /// </summary>
    /// <param name="deathItem">The DeathItem to create a reasonably unique name for.</param>
    /// <returns>A reasonably unique name.</returns>
    /// 
    static String CreateInternalName(DeathItemGetter deathItem)
    {

        String internalName = $"{deathItem.EditorID ?? deathItem.FormKey.ToString()}";
        return NAME_FILTER.Replace(internalName, "");
    }
    readonly static private Regex NAME_FILTER = new("[^a-zA-Z0-9_]", RegexOptions.IgnoreCase);

    /// <summary>
    /// Creates the Misc deathtoken for a creature.
    /// 
    /// The new deathtoken is appended to the deathtoken formlist for animals or monsters.
    /// 
    /// The deathtoken will be derived from the prototype's token (if it exists) or derived from the COW's deathtoken.
    /// 
    /// Naming is done heuristically. 
    /// </summary>
    /// 
    static private MiscItem CreateToken(CreatureData data, StandardRecords std)
    {
        // Get a pre-existing token that already has the keywords and model set.
        // That way all that needs to be done is to change the name and editor ID.
        var existingTokenLink = data.IsAnimal ? DEFAULT_TOKEN_ANIMAL : DEFAULT_TOKEN_MONSTER;
        existingTokenLink.TryResolve(std.LinkCache, out var existingToken);
        if (existingToken == null) throw new CoreRecordMissing(existingTokenLink);

        // Add the token to the patch.
        var token = std.PatchMod.MiscItems.AddNew();
        if (token == null) throw new InvalidOperationException();
        token.DeepCopyIn(existingToken);

        // Set the EditorID.
        token.EditorID = $"_DS_DI{data.InternalName}";
        token.Name = $"{data.InternalName} Token";

        // Put the token in the correct formlist.
        std.GetCCFor(data)._DS_FL_DeathItemTokens.Items.Add(token);

        return token;
    }

    static MiscItem CreateCarcass(CreatureData data, StandardRecords std)
    {
        // Get a pre-existing carcass that already has the keywords set.
        DEFAULT_CARCASS.TryResolve(std.LinkCache, out var existingCarcass);
        if (existingCarcass == null) throw new CoreRecordMissing(DEFAULT_CARCASS);

        // Add the carcass to the patch.
        var carcass = std.PatchMod.MiscItems.AddNew();
        if (carcass == null) throw new InvalidOperationException();
        carcass.DeepCopyIn(existingCarcass);

        var oldName = carcass.Name?.String;
        if (oldName.IsNullOrEmpty()) oldName = "Cow Carcass";

        carcass.EditorID = $"_DS_Carcass{data.InternalName}";
        carcass.Name = oldName.Replace("Cow", $"{data.Prototype.ProperName}");

        carcass.Value = (uint)data.Prototype.CarcassValue;
        carcass.Weight = data.Prototype.CarcassWeight;

        carcass.Model = KnownCarcasses.ContainsKey(data.Prototype)
            ? KnownCarcasses[data.Prototype].Model?.DeepCopy() ?? CreateDefaultCarcassModel()
            : CreateDefaultCarcassModel();

        // Put the carcass in the correct formlist.
        std.Animals._DS_FL_CarcassObjects.Items.Add(carcass);

        return carcass;
    }

    static Model CreateDefaultCarcassModel()
    {
        return new Model { File = "Clutter\\Containers\\MiscSackLarge.nif", AlternateTextures = null };
    }

    /// <summary>
    /// Creates a FormList of LeveledItems from a list of MaterialLevels in a prototype.
    /// </summary>
    /// 
    static FormList CreateMaterials(CreatureData data, StandardRecords std)
    {
        //DEFAULT_MATS.TryResolve(state.LinkCache, out var existingMaterials);
        //if (existingMaterials == null) throw new CoreRecordMissing(DEFAULT_MATS.FormKey);

        var matsFormList = std.PatchMod.FormLists.AddNew();
        if (matsFormList == null) throw new InvalidOperationException();
        //matsFormList.DeepCopyIn(existingMaterials);
        //matsFormList.Items.RemoveAll();
        matsFormList.EditorID = $"_DS_FL_Mats_{data.InternalName}";


        for (int index = 0; index < data.Prototype.Materials.Count; index++)
        {
            var skillLevel = data.Prototype.Materials[index];
            var mat = std.PatchMod.LeveledItems.AddNew();
            if (mat == null) throw new InvalidOperationException();

            mat.EditorID = $"{matsFormList.EditorID}{index:D2}";
            var entries = mat.Entries = new();

            foreach (var itemEntry in skillLevel.Items) {
                var item = new FormLink<IItemGetter>(itemEntry.Key.FormKey);
                entries.Add(CreateLeveledItemEntry(item, 1, itemEntry.Value));
            }

            matsFormList.Items.Add(mat);
        }

        // Put the materials formlist in the correct formlist.
        std.GetCCFor(data)._DS_FL_Mats__Lists.Items.Add(matsFormList);

        return matsFormList;
    }

    /// <summary>
    /// Turns a FormList of LeveledItems into a list of MaterialLevels.
    /// The inverse of CreateMaterials.
    /// </summary>
    /// 
    static List<MaterialLevel> RecreateMaterials(IFormListGetter matsFormList, StandardRecords std)
    {
        List<MaterialLevel> materials = new();
        //Console.WriteLine($"===Recreating materials from {matsFormList}, {matsFormList.Items.Count} in formlist.===");
        //Console.WriteLine("======" + matsFormList.Items.ToArray().Pretty());

        foreach (var level in matsFormList.Items)
        {
            var asLeveled = level.FormKey.ToLinkGetter<ILeveledItemGetter>().Resolve(std.LinkCache);

            MaterialLevel skillLevel = new();
            materials.Add(skillLevel);

            var entries = asLeveled.Entries;
            //Console.WriteLine($"======Recreating materials from {level}, {entries?.Count} in leveledlist.===");

            if (entries != null)
            {
                foreach (var entry in entries)
                {
                    if (entry.Data != null && entry.Data.Reference != null)
                        skillLevel.Items[entry.Data.Reference] = entry.Data.Count;
                }
            }
        }

        return materials;
    }


    static FormList CreatePelts(CreatureData data, StandardRecords std)
    {
        var pelts = std.PatchMod.FormLists.AddNew();
        if (pelts == null) throw new InvalidOperationException();
        pelts.EditorID = $"_DS_FL_Pelts_{data.InternalName}";

        if (!KnownPelts.ContainsKey(data.Prototype))
        {
            IItemGetter standard = GetDefaultPelt(data, std);
            var poor = std.PatchMod.MiscItems.AddNew();
            var fine = std.PatchMod.MiscItems.AddNew();
            var flawless = std.PatchMod.MiscItems.AddNew();

            poor.DeepCopyIn(standard);
            fine.DeepCopyIn(standard);
            flawless.DeepCopyIn(standard);

            String edid = $"_DS_Pelt_{standard.EditorID ?? data.InternalName}";
            poor.EditorID = $"{edid}_00";
            fine.EditorID = $"{edid}_02";
            flawless.EditorID = $"{edid}_03";

            // Store the pelt value to the Hunterborn quest script.
            std.GetCCFor(data).PeltValues.Data.Add((int) poor.Value);

            // Adjust the values of the non-standard pelts.
            poor.Value /= 2;
            fine.Value *= 2;
            flawless.Value *= 20;
            KnownPelts[data.Prototype] = new IFormLinkGetter<IItemGetter>[4] { poor.ToLink(), standard.ToLink(), fine.ToLink(), flawless.ToLink() };
        }

        // Add the pelts to the pelts formlist.
        pelts.Items.AddRange(KnownPelts[data.Prototype]);

        // Put the pelts formlist in the correct formlist.
        std.GetCCFor(data)._DS_FL_PeltLists.Items.Add(pelts);
        return pelts;
    }

    static readonly Regex DefaultPeltRegex = new("Pelt|Hide|Skin|Fur|Wool|Leather", RegexOptions.IgnoreCase);

    /// <summary>
    /// Checks the creature's DeathItem for anything whose name or editorID contains a string-match
    /// that indicates it's probably a pelt. Returns the pelt.
    /// 
    /// If no default pelt was found, one will be created and added to the patch.
    /// 
    /// </summary>
    /// 
    static IItemGetter GetDefaultPelt(CreatureData data, StandardRecords std)
    {
        var entries = data.DeathItem.Entries;
        if (entries == null) return CreateDefaultPelt(data, std);

        foreach (var entry in entries)
        {
            var item = entry.Data?.Reference.TryResolve(std.LinkCache);
            var edid = item?.EditorID ?? "";
            if (item == null || edid == null) continue;
            if (DefaultPeltRegex.Matches(edid).Any()) return item;
        }

        return CreateDefaultPelt(data, std);
    }

    /// <summary>
    /// Create a new default pelt for a creature using a pre-existing pelt as a template.
    /// 
    /// </summary>
    /// <param name="data"></param>
    /// <param name="std"></param>
    /// <returns></returns>
    /// <exception cref="CoreRecordMissing"></exception>
    /// <exception cref="InvalidOperationException"></exception>
    static IItemGetter CreateDefaultPelt(CreatureData data, StandardRecords std)
    {
        DEFAULT_PELT.TryResolve(std.LinkCache, out var existingPelt);
        if (existingPelt == null) throw new CoreRecordMissing(DEFAULT_PELT);

        var pelt = std.PatchMod.MiscItems.AddNew();
        if (pelt == null) throw new InvalidOperationException();
        pelt.DeepCopyIn(DEFAULT_PELT.Resolve(std.LinkCache));

        pelt.EditorID = $"_DS_Pelt_{data.InternalName}_01";
        pelt.Name = $"{data.Prototype.ProperName} Pelt";

        // @TODO Fill this in with something better.
        pelt.Value = (uint)data.Prototype.CarcassValue / 2;
        return pelt;
    }

    /// <summary>
    /// Create a new discards formlist for a monster.
    /// Dicards are also called "negativetreasure" internally.
    /// </summary>
    /// 
    static void CreateDiscards(CreatureData data, StandardRecords std)
    {
        var discards = std.PatchMod.FormLists.AddNew();
        if (discards == null) throw new InvalidOperationException();
        discards.Items.AddRange(data.Prototype.Discard);
    }

    /// <summary>
    /// Create a new DeathDescriptor for a creature.
    /// This is a LeveledItem that gets added to a carcass's inventory when the
    /// player interacts with the carcass for the first time.
    /// 
    /// The Tokens it adds are what determine which actions the player can take.
    /// 
    /// </summary>
    /// 
    static ILeveledItemGetter CreateDeathDescriptor(CreatureData data, StandardRecords std, FormList pelts, FormList mats)
    {
        // Create the new descriptor.
        LeveledItem deathDescriptor = std.PatchMod.LeveledItems.AddNew();
        deathDescriptor.EditorID = $"_DS_DeathItem_{data.InternalName}";
        deathDescriptor.Entries = new();

        // If the pelts FormList isn't empty, then harvesting pelts is enabled.
        if (pelts.Items != null && pelts.Items.Count > 0)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Pelt, 1, 1));

        // If the materials FormList isn't empty, then harvesting materials is enabled.
        if (mats.Items != null && mats.Items.Count > 0)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Mat, 1, 1));

        // Animals need to be cleaned. Monsters apparently not?
        if (data.IsAnimal)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Carcass_Clean, 1, 1));

        // If the Meat field in the PluginEntry isn't null then harvesting meat is enabled.
        if (!data.Prototype.Meat.IsNull)
        {
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Meat, 1, 1));
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Meat_Fresh, 1, 1));
        }

        // If the Venom or Blood fields in the PluginEntry aren't null then harvesting venom and/or blood is enabled.
        if (data.IsMonster)
        {
            if (!data.Prototype.Venom.IsNull)
                deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Venom, 1, 1));
            if (!data.Prototype.BloodType.IsNull)
                deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Venom, 1, 1));
        }

        // Add the creature's actual DeathItem to the appropriate FormList.
        // When hunterborn starts up, the creature's Token will be added to this formlist.
        // THIS IS HOW HUNTERBORN RECOGNIZES HARVESTABLE CREATURES.
        std.GetCCFor(data)._DS_FL_DeathItems.Items.Add(data.DeathItem);

        // Add the DeathDescriptor to the quest array property.
        std.GetCCFor(data).DeathDescriptors.Objects.Add(new() { Object = deathDescriptor.ToLink() });

        return deathDescriptor;
    }

    /// <summary>
    /// To be recognized as a creature by the patcher, an Npc must not belong to any of these factions.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    readonly static private HashSet<FormLink<IFactionGetter>> ForbiddenFactions = new() {
        Dawnguard.Faction.DLC1VampireFaction,
        Dragonborn.Faction.DLC2AshSpawnFaction,
        Skyrim.Faction.DragonPriestFaction,
        Skyrim.Faction.DraugrFaction,
        Skyrim.Faction.DwarvenAutomatonFaction,
        Skyrim.Faction.IceWraithFaction,
        Dawnguard.Faction.SoulCairnFaction,
        Skyrim.Faction.VampireFaction,
        Skyrim.Faction.WispFaction
    };

    /// <summary>
    /// To be recognized as a creature by the patcher, an Npc must not have any of these keywords.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    readonly static private HashSet<FormLink<IKeywordGetter>> ForbiddenKeywords = new() {
        Skyrim.Keyword.ActorTypeGhost,
        Skyrim.Keyword.ActorTypeNPC
    };

    /// <summary>
    /// Voices of creatures. To be recognized as a creature by the patcher, an Npc must have a voiceType from
    /// this list.
    /// 
    /// VoiceTypes from addons will get added to this list at runtime.
    /// Isn't that forward thinking? Why don't the other Forbidden/Allowed lists get
    /// populated from addons?
    /// 
    /// </summary>
    readonly static private HashSet<IFormLinkGetter<IVoiceTypeGetter>> AllowedVoices = new() {
        Skyrim.VoiceType.CrBearVoice,
        Skyrim.VoiceType.CrChickenVoice,
        Skyrim.VoiceType.CrCowVoice,
        Skyrim.VoiceType.CrDeerVoice,
        Skyrim.VoiceType.CrDogVoice,
        Dawnguard.VoiceType.CrDogHusky,
        Skyrim.VoiceType.CrFoxVoice,
        Skyrim.VoiceType.CrGoatVoice,
        Skyrim.VoiceType.CrHareVoice,
        Skyrim.VoiceType.CrHorkerVoice,
        Skyrim.VoiceType.CrHorseVoice,
        Skyrim.VoiceType.CrMammothVoice,
        Skyrim.VoiceType.CrMudcrabVoice,
        Skyrim.VoiceType.CrSabreCatVoice,
        Skyrim.VoiceType.CrSkeeverVoice,
        Skyrim.VoiceType.CrSlaughterfishVoice,
        Skyrim.VoiceType.CrWolfVoice,
        Dragonborn.VoiceType.DLC2CrBristlebackVoice,
        Skyrim.VoiceType.CrChaurusVoice,
        Skyrim.VoiceType.CrFrostbiteSpiderVoice,
        Skyrim.VoiceType.CrFrostbiteSpiderGiantVoice,
        Skyrim.VoiceType.CrSprigganVoice,
        Skyrim.VoiceType.CrTrollVoice,
        Skyrim.VoiceType.CrWerewolfVoice,
        Skyrim.VoiceType.CrDragonVoice,
        Dawnguard.VoiceType.CrChaurusInsectVoice
    };

    /// <summary>
    /// A list of EditorIDs of creatures that should never be processed.
    /// I wish this was explained.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    static readonly private List<String> ForbiddenNpcEditorIds = new() { "HISLCBlackWolf", "BSKEncRat" };

    /// <summary>
    /// A list of DeathItems that should never be processed. 
    /// Creatures with one of these DeathItems should be ignored by Hunterborn and by this patcher.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    private static readonly List<FormLink<ILeveledItemGetter>> ForbiddenDeathItems = new() {
        Skyrim.LeveledItem.DeathItemDragonBonesOnly,
        Skyrim.LeveledItem.DeathItemVampire,
        Skyrim.LeveledItem.DeathItemForsworn,
        Dawnguard.LeveledItem.DLC1DeathItemDragon06,
        Dawnguard.LeveledItem.DLC1DeathItemDragon07,
        new(new FormKey(new("Skyrim Immersive Creatures Special Edition", type : ModType.Plugin), 0x11B217))
    };

    /// <summary>
    /// Translates known DeathItem editorIDs to proper names and sorting names.
    /// </summary>
    static readonly private Dictionary<string, List<string>> EditorToNames = new() {
        { "BearCave", new() {"Bear", "Cave"} },
        { "BearSnow", new() {"Bear", "Snow"} },
        { "CharusHunter", new() {"Chaurus", "Hunter"} },
        { "ElkFemale", new() {"Elk", "Female"} },
        { "ElkMale", new() {"Elk", "Male"} },
        { "FoxIce", new() {"Fox", "Snow"} },
        { "MudCrab01", new() {"MudCrab", "Small"} },
        { "MudCrab02", new() {"MudCrab", "Large"} },
        { "MudCrab03", new() {"MudCrab", "Giant"} },
        { "SabrecatSnow", new() {"Sabrecat", "Snow"} },
        { "FrostbiteSpider", new() {"Spider", "Frostbite", "Medium"} },
        { "FrostbiteSpiderGiant", new() {"Spider", "Frostbite", "Giant"} },
        { "SprigganBurnt", new() {"Spriggan", "Burnt"} },
        { "DeerVale", new() {"Deer", "Vale"} },
        { "SabrecatVale", new() {"Sabrecat", "Vale"} },
        { "WolfIce", new() {"Wolf", "Ice"} },
        { "TrollFrost", new() {"Troll", "Frost"} },
        { "Boar", new() {"Boar", "Bristleback" } }

    };

    /// <summary>
    /// Item substitutions to use when Complete Alchemy and Cooking Overhaul is installed.
    /// </summary>
    static private Dictionary<FormLink<IItemGetter>, FormLink<IIngestibleGetter>> VanillaToCaco2 = new()
    {
        { new(new FormKey(HUNTERBORN_MODKEY, 0x14795)), new(new FormKey(CACO_MODKEY, 0x190b54)) }, // _DS_Food_Raw_Bear -> CACO_FoodMeatBear
        { new(new FormKey(HUNTERBORN_MODKEY, 0x27783)), new(new FormKey(CACO_MODKEY, 0x190b63)) }, // _DS_Food_Raw_Chaurus -> CACO_FoodMeatChaurusMeat
        { new(new FormKey(HUNTERBORN_MODKEY, 0x14d21)), new(new FormKey(CACO_MODKEY, 0x669a2)) }, // _DS_Food_Raw_Elk -> FoodMeatVenison
        { new(new FormKey(HUNTERBORN_MODKEY, 0x14798)), new(new FormKey(CACO_MODKEY, 0x190b50)) }, // _DS_Food_Raw_Fox -> CACO_FoodMeatFox
        { new(new FormKey(HUNTERBORN_MODKEY, 0x1479a)), new(new FormKey(CACO_MODKEY, 0x49cdc7)) }, // _DS_Food_Raw_Goat -> CACO_FoodMeatGoatPortionRaw
        { new(new FormKey(HUNTERBORN_MODKEY, 0x1479e)), new(new FormKey(CACO_MODKEY, 0x190b56)) }, // _DS_Food_Raw_Mammoth -> CACO_FoodMeatMammoth
        { new(new FormKey(HUNTERBORN_MODKEY, 0x147a0)), new(new FormKey(CACO_MODKEY, 0x190b53)) }, // _DS_Food_Raw_Sabrecat -> CACO_FoodMeatSabre
        { new(new FormKey(HUNTERBORN_MODKEY, 0x14796)), new(new FormKey(CACO_MODKEY, 0x49cda3)) }, // _DS_Food_Raw_Skeever -> CACO_FoodMeatSkeeverRaw
        { new(new FormKey(HUNTERBORN_MODKEY, 0x14d24)), new(new FormKey(CACO_MODKEY, 0x190b58)) }, // _DS_Food_Raw_Slaughterfish -> CACO_FoodSeaSlaughterfishRaw
        { new(new FormKey(HUNTERBORN_MODKEY, 0x29847)), new(new FormKey(CACO_MODKEY, 0x48da5a)) }, // _DS_Food_Raw_Troll -> CACO_FoodMeatTroll
        { new(new FormKey(HUNTERBORN_MODKEY, 0x1479c)), new(new FormKey(CACO_MODKEY, 0xedb2e)) }, // _DS_Food_Raw_Wolf -> FoodDogMeat
        { new(new FormKey(HUNTERBORN_MODKEY, 0x28ccfa)), new(new FormKey(Update.ModKey, 0xcca100)) }, // _DS_Food_Water -> FoodWaterToken_CACO
        { new(new FormKey(Skyrim.ModKey, 0x1016B3)), new(new FormKey(CACO_MODKEY, 0xcca130)) }, // HumanFlesh -> CACO_FoodMeatHumanoidFlesh
        { new(new FormKey(Skyrim.ModKey, 0x034cdf)), new(new FormKey(Update.ModKey, 0xcca101)) } // SaltPile -> FoodSaltToken_CACO
    };

    static private bool IsCreature(INpcGetter npc) {
        var deathItem = npc.DeathItem;
        var edid = npc.EditorID;

        //var edidLink = edid != null ? new EDIDLink<IRaceGetter>(edid) : null;

        if (edid != null && HasForbiddenEditorId(edid)) return false;
        else if (deathItem == null) return false;
        else if (HasForbiddenDeathItem(deathItem)) return false;
        else if (HasForbiddenKeyword(npc)) return false;
        else if (HasForbiddenFaction(npc)) return false;
        else if (!HasAllowedVoice(npc)) return false;
        else return true;
    }

    static private bool HasForbiddenEditorId(String editorId) => ForbiddenNpcEditorIds.Any(edid => edid.EqualsIgnoreCase(editorId));

    static private bool HasForbiddenFaction(INpcGetter creature) =>
        creature.Factions.Any(placement => ForbiddenFactions.Contains(placement.Faction));

    static private bool HasForbiddenKeyword(INpcGetter creature) =>
        creature.Keywords?.Any(keyword => ForbiddenKeywords.Contains(keyword)) ?? false;

    static private bool HasAllowedVoice(INpcGetter creature) => AllowedVoices.Contains(creature.Voice);

    static private bool HasForbiddenDeathItem(IFormLinkGetter<ILeveledItemGetter> deathItem) => ForbiddenDeathItems.Contains(deathItem);

    /// <summary>
    /// The quest and formlists needed by the patching methods, resolved and ready.
    /// </summary>
    readonly record struct StandardRecords(
        Settings.Settings Settings,
        bool CACO_Installed,
        Quest _DS_Hunterborn,
        ILinkCache<ISkyrimMod, ISkyrimModGetter> LinkCache,
        ISkyrimMod PatchMod,
        AnimalClass Animals,
        MonsterClass Monsters,
        List<CreatureClass> CreatureClasses)
    {

        /// <summary>
        /// Retrieves the CreatureClass for a specified Plugins.
        /// </summary>
        /// <param name="d">The Plugins whose CreatureClass should be returned.</param>
        /// <returns>The CreatureClass.</returns>
        public CreatureClass GetCCFor(CreatureData d) => GetCCFor(d.Prototype.Type);

        /// <summary>
        /// Retrieves the CreatureClass for a specified EntryType.
        /// </summary>
        /// <param name="d">The EntryType whose CreatureClass should be returned.</param>
        /// <returns>The CreatureClass.</returns>
        public CreatureClass GetCCFor(EntryType t) => t switch
        {
            EntryType.Animal => Animals,
            EntryType.Monster => Monsters,
            _ => throw new InvalidOperationException("Unknown CreatureClass requested."),
        };
    }

    /// <summary>
    /// FormLists and script properties needed for patching creatures.
    /// </summary>
    record CreatureClass(
        //List<ILeveledItemGetter> KnownDeathItems,
        FormList _DS_FL_Mats__Lists,
        FormList _DS_FL_Mats__Perfect,
        FormList _DS_FL_PeltLists,
        FormList _DS_FL_DeathItems,
        FormList _DS_FL_DeathItemTokens,
        ScriptObjectListProperty Switches,
        ScriptObjectListProperty DeathDescriptors,
        ScriptObjectListProperty MeatType,
        ScriptObjectListProperty SharedDeathItems,
        ScriptStringListProperty RaceIndex,
        ScriptFloatListProperty MeatWeights,
        ScriptIntListProperty PeltValues,
        ScriptIntListProperty CarcassSizes
        );

    /// <summary>
    /// FormLists and script properties needed for patching Animals,
    /// which is just the FormList of carcasses.
    /// </summary>
    record AnimalClass(
        CreatureClass proto,
        ScriptObjectListProperty CarcassMessages,
        FormList _DS_FL_CarcassObjects) : CreatureClass(proto);

    /// <summary>
    /// FormLists and script properties needed for patching Monsters,
    /// which includes blood, venom, and discards.
    /// </summary>
    record MonsterClass(
        CreatureClass proto, 
        ScriptObjectListProperty BloodItems, 
        ScriptObjectListProperty VenomItems, 
        ScriptObjectListProperty Discards) : CreatureClass(proto);


    /// <summary>
    /// Some of the methods in this class require the resolved Hunterborn Quest and resolved FormLists.
    /// This resolves them, adds them to the patch, and packs them into a Record.
    /// 
    /// Stores the Settings object too.
    /// </summary>
    static StandardRecords CreateStandardRecords(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, Settings.Settings settings)
    {
        Quest hunterbornQuest = state.PatchMod.Quests.GetOrAddAsOverride(_DS_Hunterborn.Resolve(state.LinkCache));
        //if (settings.DebuggingMode) QueryImportantProperties(hunterbornQuest);

        var animals = new AnimalClass(new(
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Lists.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Lists)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Perfect.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Perfect)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_PeltLists.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_PeltLists)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItems.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItems)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItemTokens.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItemTokens)),

                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "ActiveAnimalSwitches"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "DeathItemLI"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "MeatTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "SharedDeathItems"),
                    GetProperty<ScriptStringListProperty>(hunterbornQuest, "_DS_HB_Animals", "AnimalIndex"),
                    GetProperty<ScriptFloatListProperty>(hunterbornQuest, "_DS_HB_Animals", "AllMeatWeights"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Animals", "DefaultPeltValues"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Animals", "CarcassSizes")),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_MAIN", "FreshCarcassMsgBoxes"),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_CarcassObjects.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_CarcassObjects)));

        var monsters = new MonsterClass(new(
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Lists_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Lists_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Perfect_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Perfect_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_PeltLists_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_PeltLists_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItems_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItems_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItemTokens_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItemTokens_Monsters)),

                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "ActiveMonsterSwitches"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "DeathItemLI"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "MeatTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "SharedDeathItems"),
                    GetProperty<ScriptStringListProperty>(hunterbornQuest, "_DS_HB_Monsters", "MonsterIndex"),
                    GetProperty<ScriptFloatListProperty>(hunterbornQuest, "_DS_HB_Animals", "AllMeatWeights"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Monsters", "DefaultPeltValues"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Monsters", "CarcassSizes")),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "BloodTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "VenomTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "NegativeTreasure"));


        StandardRecords std = new(
            settings,
            state.LoadOrder.ContainsKey(CACO_MODKEY),
            hunterbornQuest,
            state.LinkCache,
            state.PatchMod,
            animals,
            monsters,
            new() { animals, monsters });

        return std;
    }
    
    static void QueryImportantProperties(Quest hunterbornQuest)
    {
        hunterbornQuest.VirtualMachineAdapter?.Scripts.ForEach(script => {
            script.Properties
                .Where(p => p is ScriptObjectListProperty)
                .Select(p => (p as ScriptObjectListProperty)!)
                .Where(p => p.Objects.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant object array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptBoolListProperty)
                .Select(p => (p as ScriptBoolListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant bool array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptIntListProperty)
                .Select(p => (p as ScriptIntListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant int array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptFloatListProperty)
                .Select(p => (p as ScriptFloatListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant float array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptStringListProperty)
                .Select(p => (p as ScriptStringListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant string array property: {script.Name}.{p.Name}"));
        });
    }

    static ScriptTProperty GetProperty<ScriptTProperty>(Quest quest, String scriptName, String propertyName) where ScriptTProperty : ScriptProperty
    {
        String questName = quest.Name?.ToString() ?? quest.EditorID ?? "Quest";

        var scriptFilter = ScriptFilter(scriptName);
        var propertyFilter = PropertyFilter(propertyName);

        var script = quest.VirtualMachineAdapter?.Scripts.Where(scriptFilter).FirstOrDefault();
        if (script == null) throw new ScriptMissing(questName, scriptName);

        if (script.Properties.Where(propertyFilter).FirstOrDefault() is not ScriptTProperty property) 
            throw new PropertyMissing(questName, scriptName, propertyName);

        return property;
    }

    /// <summary>
    /// A predicate for matching scripts by name.
    /// </summary>
    /// <param name="name">The name to match.</param>
    /// <returns>A predicate that matches the specified name.</returns>
    /// 
    static Func<ScriptEntry, bool> ScriptFilter(String name) => (ScriptEntry s) => name.EqualsIgnoreCase(s?.Name);

    /// <summary>
    /// A predicate for matching script properties by name.
    /// </summary>
    /// <param name="name">The name to match.</param>
    /// <returns>A predicate that matches the specified name.</returns>
    /// 
    static Func<ScriptProperty, bool> PropertyFilter(String name) => (ScriptProperty s) => name.EqualsIgnoreCase(s?.Name);

    /// <summary>
    /// Convenience method for creating new LeveledItemEntry.
    /// No extra data is added.
    /// </summary>
    /// <param name="item">The item.</param>
    /// <param name="level">The player level.</param>
    /// <param name="count">The item count.</param>
    /// <returns></returns>
    static LeveledItemEntry CreateLeveledItemEntry(IFormLink<IItemGetter> item, int level, int count) =>
        new() { Data = new LeveledItemEntryData { Reference = item, Level = (short)level, Count = (short)count }};

    /// <summary>
    /// Convenience method for creating new ScriptObjectProperty wrapping a FormLink.
    /// It has to turn the Getter into a Setter internally.
    /// </summary>
    /// <param name="item">The FormLinkGetter.</param>
    /// <returns>The ScriptObjectProperty.</returns>
    static ScriptObjectProperty CreateProperty<T>(IFormLinkGetter<T> item) where T : class, ISkyrimMajorRecordGetter
    {
        var link = item.FormKey.ToLink<ISkyrimMajorRecordGetter>();
        return new() { Object = link };
    }

    /*
    readonly static private Dictionary<string, string> NameSubstitutions = new() {
        { "BearCave", "Bear, Cave" },
        { "BearSnow", "Bear, Snow" },
        { "CharusHunter", "Chaurus, Hunter"  },
        { "ElkFemale", "Elk, Female"  },
        { "ElkMale", "Elk, Male"  },
        { "FoxIce", "Fox, Snow"  },
        { "MudCrab01", "MudCrab, Small" },
        { "MudCrab02", "MudCrab, Large" },
        { "MudCrab03", "MudCrab, Giant" },
        { "SabrecatSnow", "Sabrecat, Snow" },
        { "FrostbiteSpider", "Spider, Frostbite" },
        { "FrostbiteSpiderGiant", "Spider, Giant Frostbite" },
        { "SprigganBurnt", "Spriggan, Burnt" },
        { "DeerVale", "Deer, Vale" },
        { "SabrecatVale", "Sabrecat, Vale" },
        { "WolfIce", "Wolf, Ice" },
        { "TrollFrost", "Troll, Frost" }
    };*/

    /*
    readonly static private List<String> DeathItemNameMatches = new(new String[] {
        "Werebear",
        "Bear",
        "BearCave",
        "BearSnow",
        "Bristleback",
        "Chaurus",
        "CharusHunter",
        "Chicken",
        "Cow",
        "DeerVale",
        "Deer",
        "Dog",
        "Dragon",
        "ElkFemale",
        "ElkMale",
        "FoxIce",
        "Fox",
        "FrostbiteSpiderGiant",
        "FrostbiteSpider",
        "Goat",
        "Hare",
        "Horker",
        "Horse",
        "Mammoth",
        "MudCrab01",
        "MudCrab02",
        "MudCrab03",
        "SabrecatSnow",
        "SabrecatVale",
        "Sabrecat",
        "Skeever",
        "Slaughterfish",
        "Spriggan",
        "SprigganBurnt",
        "TrollFrost",
        "Troll",
        "Werewolf",
        "WolfIce",
        "Wolf"
    });*/


    /// <summary>
    /// For printing dividers in the console output.
    /// </summary>
    static private readonly string Divider = "====================================================";

    /// <summary>
    /// For printing titled-dividers in the console output.
    /// </summary>
    static String CreateTitle(String title)
    {
        int dividerLength = Divider.Length;
        int titleLength = title.Length;
        int leftLength = Math.Max(0, (dividerLength - titleLength) / 2);
        int rightLength = Math.Max(0, (dividerLength - titleLength + 1) / 2);
        String left = Divider.Substring(0, leftLength);
        String right = Divider.Substring(0, rightLength);
        return $"{left}{title}{right}";
    }

    /// <summary>
    /// Scans a plugin for all records of a given type and outputs named FormLink definitions for them.
    /// 
    /// They take the general form:
    /// static readonly public ModKey MY_MOD = new ModKey(FILENAME, ModType.Plugin);
    /// static readonly public FormLink<IMiscItemGetter> EDITORID = new (new FormKey(MY_MOD, 0x000000));
    /// 
    /// </summary>
    /// <typeparam name="T">The type of record to scan and make FormLink definitions for.</typeparam>
    /// <param name="filename">The name of the mod to scan.</param>
    /// <param name="state">The patcher state.</param>
    /// 
    public static void PrintFormKeysDefinitions<T>(String filename, IPatcherState<ISkyrimMod, ISkyrimModGetter> state) where T : IMajorRecordGetter
    {
        state.LoadOrder.TryGetIfEnabledAndExists(new ModKey(filename, ModType.Plugin), out var mod);
        var group = mod?.GetTopLevelGroup<T>();
        if (mod == null || group == null || group.Count == 0) return;

        String modname = $"{Regex.Replace(filename.ToUpper(), "[^a-zA-Z0-9_]", "")}";
        String typeName = typeof(T).FullName ?? "TYPENAME";

        System.Console.WriteLine($"static readonly public ModKey {modname} = new ModKey(\"{filename}\"), ModType.Plugin);");

        group.Where(rec => rec.EditorID != null).ForEach(rec => {
            var edid = rec.EditorID;
            var formID = rec.FormKey.ID.ToString("x");
            Console.WriteLine($"static readonly public FormLink<I{typeName}Getter> {edid} = new (new FormKey({modname}, 0x{formID}));");
        });

    }

    static private void WriteSuccess(int tabs, string msg)
    {
        Console.Write(new String('\t', tabs));
        Console.Write(" o ");
        Console.WriteLine(msg);
    }

    static private void WriteFail(int tabs, string msg)
    {
        Console.Write(new String('\t', tabs));
        Console.Write(" x ");
        Console.WriteLine(msg);
    }

    static private void WriteAction(int tabs, string msg)
    {
        Console.Write(new String('\t', tabs));
        Console.WriteLine(msg);
    }

    sealed class Checkin
    {
        private int Counter = 0;
        public void check()
        {
            Counter++;
            Console.WriteLine($"EVERYTHING OKAY {Counter}");
        }
    }

    /// <summary>
    /// Thrown to indicate that an Npc has no DeathItem and therefore can't be processed by Hunterborn.
    /// @TODO Create a PO3-enhanced Taxonomy spell that can add DeathItems to creatures.
    /// </summary>
    sealed class NoDeathItemException : Exception
    {
        public NoDeathItemException(FormKey form) : base($"No DeathItem: {form}") { }
    }

    /// <summary>
    /// Thrown to indicate that an Npc's DeathItem has already been processed. 
    /// </summary>
    sealed class DeathItemAlreadyAddedException : Exception
    {
        public DeathItemAlreadyAddedException(FormKey form) : base($"DeathItem already processed: {form}") { }
    }

    /// <summary>
    /// Thrown to indicate that one of the forms in Hunterborn.esp couldn't be loaded.
    /// If this happens then something is terribly wrong with Hunterborn.esp.
    /// </summary>
    sealed class CoreRecordMissing : Exception
    {
        public CoreRecordMissing(IFormLinkGetter<ISkyrimMajorRecordGetter> form) : base($"Missing core record: {form} from Hunterborn.esp.") {
        }
    }

    /// <summary>
    /// Thrown to indicate that one of the scripts in the main Hunterborn quest couldn't be found.
    /// If this happens then something is terribly wrong with Hunterborn.esp.
    /// </summary>
    sealed class ScriptMissing : Exception    {
        public ScriptMissing(String questname, String scriptName) : base($"Missing script: {questname}.{scriptName}") { }
    }

    /// <summary>
    /// Thrown to indicate that one of the properties on one of the scripts in the main Hunterborn quest couldn't be found.
    /// If this happens then something is terribly wrong with Hunterborn.esp.
    /// </summary>
    sealed class PropertyMissing : Exception
    {
        public PropertyMissing(String questname, String scriptName, String propertyName) : base($"Missing property: {questname}.{scriptName}.{propertyName}") { }
    }

    /// <summary>
    /// Thrown to indicate that some data in Hunterborn.esp is invalid but in a way that can probably be ignored.
    /// 
    /// The most common cause is that some other patcher (like the zedit one) already made a patch, imperfectly.
    /// 
    /// </summary>
    /// 
    sealed class DataConsistencyError : Exception
    {
        public DataConsistencyError(EntryType type, String name, int index, string msg) : base($"Inconsistent data for {type} #{index}: {name}. {msg}") { }
    }


}

/// <summary>
/// Adds an EqualsIgnoreCase method to String.
/// </summary>
public static class StringEqualsIgnoreCase
{
    /// <summary>
    /// Equivalent to s1.ToLower().Equals(s2.ToLower()) with identity and null checking.
    /// </summary>
    public static bool EqualsIgnoreCase(this String s1, String? s2)
    {
        if (s1 == s2) return true;
        else if (s1 == null || s2 == null) return false;
        else return s1.ToLower().Equals(s2.ToLower());
    }

}

/// <summary>
/// Adds pretty-printing methods to lists, arrays, dictionaries, and lists of dictionaries.
/// </summary>
public static class GenericPrettyPrinting
{
    public static string Pretty<T>(this T[] array) where T : notnull => "[" + string.Join(", ", array) + "]";

    public static string Pretty<T>(this List<T> list) where T : notnull => "[" + string.Join(", ", list) + "]";

    public static string Pretty<S, T>(this Dictionary<S, T> dict) where S : notnull => "{" + string.Join(", ", dict) + "}";

    public static string Pretty<S, T>(this List<Dictionary<S, T>> listOfDicts) where S : notnull => "[" + string.Join(", ", listOfDicts.Select(l => l.Pretty())) + "]";

}