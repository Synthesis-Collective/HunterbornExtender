namespace HunterbornExtender;
using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Noggog;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins.Cache;
using static HunterbornExtender.FormKeys;
using System.Linq;
using System.Text.RegularExpressions;
using Mutagen.Bethesda.Plugins.Records;
using Microsoft.CodeAnalysis;
using DynamicData;
using HunterbornExtender.Settings;
using Mutagen.Bethesda.Plugins.Exceptions;
using AssemblyVersionGenerator;
using Mutagen.Bethesda.Plugins.Aspects;


#pragma warning disable IDE1006 // Naming Styles

sealed internal class Program
{

    /// 
    /// <summary>
    /// Stores token prototypes created for each PluginEntry.
    /// </summary>
    //static private Dictionary<PluginEntry, IMiscItemGetter> PluginTokens = new();
    //static private List<DeathItemSelection> MonsterTypes = new();
    //static private List<DeathItemSelection> AnimalTypes = new();

    record CreatureData(INpcGetter Target, ILeveledItemGetter DeathItem, String InternalName, PluginEntry Prototype, bool IsAnimal, bool IsMonster);
    static readonly Dictionary<PluginEntry, IMiscItemGetter> KnownCarcasses = new();
    static readonly Dictionary<PluginEntry, IFormLinkGetter<IItemGetter>[]> KnownPelts = new();
    static readonly Dictionary<ILeveledItemGetter, PluginEntry> KnownDeathItems = new();
    private static Lazy<Settings.Settings> _settings = null!;


    public static Task<int> Main(string[] args)
    {
        return SynthesisPipeline.Instance
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch, new PatcherPreferences()
            {
                ExclusionMods = new List<ModKey>() {
                    new ModKey("HunterbornExtenderPatch.esp", ModType.Plugin),
                },
            })
            .SetTypicalOpen(GameRelease.SkyrimSE, "HunterbornExtenderPatch.esp")
            .SetAutogeneratedSettings("settings", "settings.json", out _settings)
            .Run(args);
    }


    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        /*
        PatcherSettings jsonData;
        try
        {
            Console.WriteLine("Trying to load stored DeathItem selections.");
            jsonData = JSONhandler<PatcherSettings>.LoadJSONFile("settings.json") ?? new();
            Console.WriteLine($"\tRead {jsonData.DeathItems.Count} selections and {jsonData.CreatureData.Count} plugins.");

            if (jsonData.DeathItems.Count > 0 || jsonData.CreatureData.Count > 0)
                Console.WriteLine($" ✓ Success: {jsonData.DeathItems.Count} selections and {jsonData.CreatureData.Count} plugins loaded.");

            else throw new InvalidOperationException("No data.");
        }
        catch (Exception ex)
        {
            Console.WriteLine(" x Failed to load stored DeathItem selections.");
            Console.WriteLine("=================================");
            Console.WriteLine(ex);
            Console.WriteLine("=================================");
            return;
        }*/


        //
        // However we do it, this is where we get a List<PluginEntry> from the addon jsons.
        //
        var settings = _settings.Value;

        // link death item selection to corresponding creature entry
        foreach (var deathItem in settings.DeathItemSelections)
        {
            deathItem.Selection = settings.CreatureData.Where(x => x.Name == deathItem.CreatureEntryName).FirstOrDefault();
        }

        Console.WriteLine("Imported death plugin support for {0} creatures", settings.CreatureData.Count);
        Console.WriteLine("Imported {0} death item selections", settings.DeathItemSelections.Length);

        Console.WriteLine("========================");
        Console.WriteLine("Importing plugins.");
        var plugins = LegacyConverter.ImportAndConvert(state);
        Console.WriteLine($" o Success:{plugins.Count} creature types imported.");

        //
        // Resolve and locate all the FormLists and ScriptProperties that need patching.
        // 
        StandardRecords std;

        try
        {
            Console.WriteLine("========================");
            Console.WriteLine("Trying to resolve required forms from Hunterborn.esp, and preparing the patch structure.");
            std = CreateStandardRecords(state);
            Console.WriteLine($" o Success: {std.PatchMod}");
        }
        catch (RecordException ex)
        {
            Console.WriteLine(" x Failed to resolve required forms because of unresolved reference [{ex.FormKey}].");
            Console.WriteLine(ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            Console.WriteLine(" x Failed to resolve required forms.");
            Console.WriteLine(ex);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        // 
        // Import allowed and forbidden values from plugins.
        //
        foreach (var plugin in settings.CreatureData)
        {
            if (!plugin.Voice.IsNull) AllowedVoices.Add(plugin.Voice);
        }

        //
        // Create a List<PluginEntry> for the hard-coded creatures.
        // Merge it into the previous list.
        //
        List<PluginEntry> corePlugins;
        
        try
        {
            Console.WriteLine("========================");
            Console.WriteLine("Trying to recreate the hard-coded core plugin from Hunterborn.esp.");
            corePlugins = RecreateCorePlugins(std);

            if (corePlugins.Count > 0)
            {
                Console.WriteLine($" o Success: {corePlugins.Count} hard-coded creature types found.");
                plugins.AddRange(corePlugins, 0);
                Console.WriteLine($" o Add-on creatures and hard-coded creatures merged; {plugins.Count} total.");
            } 
            else
            {
                Console.WriteLine($" x No hard-coded creature types found. Check your Hunterborn installation.");
                return;
            }
        }
        catch (RecordException ex)
        {
            Console.WriteLine($" x Failed to recreate core plugin because of unresolved reference [{ex.FormKey}].");
            Console.WriteLine(ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }
        catch (Exception ex)
        {
            Console.WriteLine(" x Failed to recreate core plugin.");
            Console.WriteLine(ex.Message);
            Console.WriteLine(ex.StackTrace);
            return;
        }

        //
        // Scan the load order and update the selections.
        // 
        //
        DeathItemSelection[] SELECTIONS = MakeHeuristicSelections(plugins, state);
        settings.DeathItemSelections = SELECTIONS;

        //================
        //================
        // @TODO THIS IS WHERE THE UI WOULD BE DISPLAYED.
        // The UI should give the user the chance to change the Selection fields of the DeathItemSelections.
        //
        //================
        // Rui_UI_On(PICKS, settings.plugins);

        //
        //================
        //================

        foreach (var selection in SELECTIONS)
        {
            var name = selection.CreatureEntryName;
            Console.WriteLine(CreateTitle(name));

            PluginEntry? prototype = selection.Selection;

            // null is used to indicate "SKIP".
            if (prototype == null)
            {
                if (settings.DebuggingMode) Console.WriteLine(CreateTitle($"(SKIPPED) {name}"));
                continue;
            }

            Console.WriteLine(CreateTitle($"{name} -> {prototype.Name}"));

            // Filter the NPCs.
            var NPCs = selection.AssignedNPCs
                .Where(npc => npc.EditorID != null && !ForbiddenNpcEditorIds
                .Contains(npc.EditorID))
                .ToList();

            // Why does the original patcher scan ALL the npcs??
            //p.Key.AssignedNPCs.ForEach(npc =>
            //dis.AssignedNPCs.Take(1).ForEach(npc =>
            if (NPCs.Count == 0)
            {
                Console.WriteLine($"\tSkipped {name}: No creatures found.");
                continue;
            }

            try
            {
                var data = CreateCreatureData(NPCs.First(), prototype, std);
                if (settings.DebuggingMode) Console.WriteLine($"\t o Creating creature Data structure.");

                if (ForbiddenDeathItems.Contains(data.DeathItem.ToLink()))
                {
                    Console.WriteLine($"\t x Skipped {name}: DeathItem blacklisted.");
                }
                else if (KnownDeathItems.ContainsKey(data.DeathItem))
                {
                    Console.WriteLine($"\t x Skipped {name}: DeathItem already processed.");
                } 
                else
                {
                    KnownDeathItems.Add(data.DeathItem, prototype);
                    AddRecord(data, std);
                }
            }
            catch (DeathItemAlreadyAddedException)
            {
                Console.WriteLine($"\t x Skipped {name}: DeathItem already processed.");
            }
            catch (NoDeathItemException)
            {
                Console.WriteLine($"\t x Skipped {name}: No DeathItem.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"\t x Skipped {name}: {ex.Message}");
            }
        }
    }


    static DeathItemSelection[] MakeHeuristicSelections(List<PluginEntry> plugins, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        // For each DeathItem, there will be a weighted set of plausible Plugins.
        // HeuristicMatcher assigns the weights.
        Dictionary<DeathItemSelection, Dictionary<PluginEntry, int>> selectionWeights = new();
        Dictionary<ILeveledItemGetter, DeathItemSelection> indexer = new();

        foreach (var npc in state.LoadOrder.PriorityOrder.Npc().WinningOverrides().Where(IsCreature))
        {
            if (npc.DeathItem is ILeveledItemGetter deathItem && !KnownDeathItems.ContainsKey(deathItem))
            {
                // If there is no DeathItemSelection record for the NPC's DeathItem, create it.
                // Try as hard as possible to give the DeathItemSelection a name. Fallbacks on fallbacks.
                if (!indexer.ContainsKey(deathItem))
                {
                    indexer[deathItem] = new DeathItemSelection()
                    {
                        DeathItemList = deathItem.FormKey,
                        CreatureEntryName = deathItem.EditorID ?? npc.EditorID ?? npc.Name?.ToString() ?? Guid.NewGuid().ToString()
                    };
                    selectionWeights[indexer[deathItem]] = new();
                }

                // Add the NPC to the assigned NPCs of the DeathItemSelection.
                var deathItemSelection = indexer[deathItem];
                deathItemSelection.AssignedNPCs.Add(npc);

                // Run the heuristic matcher.
                var npcWeights = HeuristicMatcher(npc, plugins, state.LinkCache);
                var itemWeights = selectionWeights[deathItemSelection];

                foreach (PluginEntry plugin in npcWeights.Keys)
                    itemWeights[plugin] = itemWeights.GetValueOrDefault(plugin, 0) + npcWeights[plugin];
            }
        }

        DeathItemSelection[] selections = selectionWeights.Keys.ToArray();
        Dictionary<FormKey, PluginEntry?> savedSelections = _settings.Value.DeathItemSelections.ToDictionary(v => v.DeathItemList, v => v.Selection);

        foreach (var selection in selections)
        {
            if (_settings.Value.ReuseSelections && savedSelections.ContainsKey(selection.DeathItemList))
            {
                selection.Selection = savedSelections[selection.DeathItemList];
                if (_settings.Value.DebuggingMode) Console.WriteLine($"\t\t\tPreviously selected {selection.Selection}.");
            }
            else
            {
                var itemWeights = selectionWeights[selection];
                List<PluginEntry> options = new(itemWeights.Keys);
                if (options.Count == 0) continue;

                options.Sort((a, b) => itemWeights[b].CompareTo(itemWeights[a]));
                selection.Selection = options.First();
                if (_settings.Value.DebuggingMode) Console.WriteLine($"\t\t\t{itemWeights.Pretty()}");
                if (_settings.Value.DebuggingMode) Console.WriteLine($"\t\t\tHeuristic selected {selection.Selection}.");
            }
        }

        return selections;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <returns></returns>
    static Dictionary<PluginEntry, int> HeuristicMatcher(INpcGetter npc, List<PluginEntry> plugins, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
    {
        Dictionary<PluginEntry, int> candidates = new();
        var clicker = DictionaryIncrementer(candidates);

        // Check for humanoid keywords. Skip if found.
        if (npc.HasKeyword(Skyrim.Keyword.ActorTypeNPC)) return candidates;

        // Try to match the voice.
        if (!npc.Voice.IsNull)
        {
            plugins
                .Where(plugin => !plugin.Voice.IsNull)
                .Where(plugin => plugin.Voice.Equals(npc.Voice))
                .ForEach(clicker(10));
        }

        // Match the creature's editorId, name, and race name to the names of plugins.
        var nameMatches = new HashSet<PluginEntry>();
        var race = npc.Race.Resolve(linkCache);

        if (npc.EditorID is string npcEditorId) plugins.Where(PluginNameMatch(npcEditorId)).ForEach(clicker(1));
        if (npc.Name?.ToString() is string npcName) plugins.Where(PluginNameMatch(npcName)).ForEach(clicker(1));
        if (race.EditorID is string raceEditorId) plugins.Where(PluginNameMatch(raceEditorId)).ForEach(clicker(1));
        if (race.Name?.ToString() is string raceName) plugins.Where(PluginNameMatch(raceName)).ForEach(clicker(1));

        // @TODO Add matching for distinctive keywords?
        // @TODO Add exclusion terms?

        return candidates;
    }

    /// <summary>
    /// Matcher for plugin names. 
    /// A match occurs if the plugin name is contained in the target string.
    /// Case-insensitive.
    /// 
    /// </summary>
    /// <param name="str">The string against which to match the plugin names.</param>
    /// <returns>The matcher.</returns>
    /// 
    static Func<PluginEntry,bool> PluginNameMatch(String str) => plugin => str.ContainsInsensitive(plugin.Name);

    /// <summary>
    /// This thing is ridiculous but convenient. Can you say "Currying"?
    /// 
    /// </summary>
    /// 
    static Func<int,Action<T>> DictionaryIncrementer<T>(Dictionary<T,int> dict) where T : notnull 
        => val => plugin => dict[plugin] = dict.GetValueOrDefault(plugin, 0) + val;

    static List<PluginEntry> RecreateCorePlugins(StandardRecords std)
    {
        List<PluginEntry> core = new();

        foreach (var type in new List<EntryType>() { EntryType.Animal, EntryType.Monster })
        {
            int count = std.GetCCFor(type).RaceIndex.Data.Count;
            Console.WriteLine($"\tRecreating {count} {type} plugin entries.");

            if (_settings.Value.DebuggingMode)
            {
                if (type == EntryType.Animal) Console.WriteLine($"\tChecks: names={std.GetCCFor(type)._DS_FL_DeathItems.Items.Count}, pelts={std.GetCCFor(type)._DS_FL_PeltLists.Items.Count}, carcasses={std.Animals._DS_FL_CarcassObjects.Items.Count}");
                else Console.WriteLine($"\tChecks: names={std.GetCCFor(type)._DS_FL_DeathItems.Items.Count}, pelts={std.GetCCFor(type)._DS_FL_PeltLists.Items.Count}");
            }

            for (int index = 0; index < count; index++)
            {
                PluginEntry entry = RecreateCorePluginEntry(type, index, std);
                core.Add(entry);
            }
        }

        return core;
    }

    static PluginEntry RecreateCorePluginEntry(EntryType type, int index, StandardRecords std)
    {
        String name = std.GetCCFor(type).RaceIndex.Data[index];

        try
        {
            PluginEntry plugin = new(type, name) { ProperName = name, SortName = name };

            var toggle = std.GetCCFor(type).Switches.Objects[index].Object;
            if (toggle.IsNull) plugin.Toggle = new FormLink<IGlobalGetter>();
            else plugin.Toggle = toggle.Resolve<IGlobalGetter>(std.LinkCache).ToLink();

            var msg = std.GetCCFor(type).CarcassMessages.Objects[index].Object;
            if (msg.IsNull) plugin.CarcassMessageBox = new FormLink<IMessageGetter>();
            else plugin.CarcassMessageBox = msg.Resolve<IMessageGetter>(std.LinkCache).ToLink();

            var meat = std.GetCCFor(type).MeatType.Objects[index].Object;
            if (meat.IsNull) plugin.Meat = new FormLink<IItemGetter>();
            else plugin.Meat = meat.Resolve<IItemGetter>(std.LinkCache).ToLink();

            var shared = std.GetCCFor(type).SharedDeathItems.Objects[index].Object;
            if (shared.IsNull) plugin.SharedDeathItems = new FormLink<IFormListGetter>();
            else plugin.SharedDeathItems = shared.Resolve<IFormListGetter>(std.LinkCache).ToLink();

            plugin.CarcassSize = std.GetCCFor(type).CarcassSizes.Data[index];

            if (type == EntryType.Monster)
            {
                var venom = std.Monsters.VenomItems.Objects[index].Object;
                if (venom.IsNull) plugin.Venom = new FormLink<IIngestibleGetter>();
                else plugin.Venom = venom.Resolve<IIngestibleGetter>(std.LinkCache).ToLink();

                var blood = std.Monsters.BloodItems.Objects[index].Object;
                if (blood.IsNull) plugin.BloodType = new FormLink<IItemGetter>();
                else plugin.BloodType = blood.Resolve<IItemGetter>(std.LinkCache).ToLink();

                plugin.CarcassWeight = 0;
                plugin.CarcassValue = 0;
            }
            else if (type == EntryType.Animal)
            {
                plugin.Venom = new FormLink<IIngestibleGetter>();
                plugin.BloodType = new FormLink<IItemGetter>();

                var carcass = std.Animals._DS_FL_CarcassObjects.Items[index].Resolve<IMiscItemGetter>(std.LinkCache);
                plugin.CarcassWeight = (int)carcass.Weight;
                plugin.CarcassValue = (int)carcass.Value;
            }

            plugin.Discard = type != EntryType.Monster
                ? new()
                : std.Monsters.Discards.Objects[index].Object
                .Resolve<IFormListGetter>(std.LinkCache).Items
                .Select(item => item as IFormLinkGetter<IItemGetter>)
                .Where(item => item != null)
                .Select(item => item!).ToList();

            plugin.PeltCount = Array.Empty<int>();
            plugin.FurPlateCount = Array.Empty<int>();
            plugin.Materials = new();


            // The voice field is unnecessary because the core voices are hard-coded.
            // But it's nice to have it just in case.
            // 
            // We could scan through all NPCs looking for the matching DeathItem and grab the voice of
            // the first match.
            //
            // BUT
            // 
            // Vanilla voices are named very predictably, so just use that.
            //
            std.LinkCache.TryResolve<VoiceType>($"Cr{plugin.Name}Voice", out var voice);
            plugin.Voice = voice == null
                ? new FormLink<IVoiceTypeGetter>()
                : voice.ToLink();


            /*
             * @TODO Finish recreating these from recipes.
            entry.Pelts;
            entry.Mats;
            entry.PeltCount;
            entry.FurPlateCount;
            */

            // Populate the KnownDeathItems, KnownCarcasses, and KnownPelts.
            // Having these means that when new Pelts, DeathItems, and Carcasses get created, they
            // can copy the models and keywords from existing ones.

            // Get the DeathItem link from the formlist, resolve it, and put it in KnownDeathItems.
            if (std.GetCCFor(plugin.Type)._DS_FL_DeathItems.Items[index].Resolve(std.LinkCache) is not ILeveledItemGetter deathItem)
                throw new CoreRecordMissing(std.GetCCFor(plugin.Type)._DS_FL_DeathItems.Items[index]);
            KnownDeathItems.Add(deathItem, plugin);

            // Get the Carcass link from the formlist, resolve it, and put it in KnownCarcasses.
            // Only animals have carcasses. I guess you can't carry monster corpses around.
            if (type == EntryType.Animal)
            {
                if (std.Animals._DS_FL_CarcassObjects.Items[index].Resolve(std.LinkCache) is not IMiscItemGetter carcass)
                    throw new CoreRecordMissing(std.Animals._DS_FL_CarcassObjects.Items[index]);
                KnownCarcasses.Add(plugin, carcass);
            }

            // Get the Pelts link from the formlist, resolve it, transform it into an array, and put it in KnownPelts.
            if (std.GetCCFor(plugin.Type)._DS_FL_PeltLists.Items[index].Resolve(std.LinkCache) is not IFormListGetter pelts)
                throw new CoreRecordMissing(std.GetCCFor(plugin.Type)._DS_FL_PeltLists.Items[index]);

            IFormLinkGetter<IItemGetter>[] peltsArray = pelts.Items.OfType<IFormLinkGetter<IItemGetter>>().ToArray();
            if (peltsArray.Length != 0 && peltsArray.Length != 4)
                throw new InvalidOperationException($"Wrong length for pelts: {plugin.Name} -- {std.GetCCFor(plugin.Type)._DS_FL_PeltLists.Items[index]}");
            KnownPelts.Add(plugin, peltsArray);

            return plugin;

        } catch(Exception)
        {
            Console.WriteLine(CreateTitle($"Problem with {type} {name}"));
            throw;
        }
    }

    /// <summary>
    /// Things that have to be done for each race:
    /// 
    /// 
    /// ==NEW RECORDS==
    /// Create a token MiscItem that identifies the creature as being Hunterborn-enabled.
    /// Create a carcass MiscItem that can go in the player's inventory.
    /// 
    /// Create a materials FormList containing 4 leveled lists of stuff, for the four levels of harvesting skill.
    /// 
    /// Create either 3 or 4 pelt MiscItems (3 if there's a default one the creature already).
    /// Create Leather and Fur Plate recipes for the pelts.
    /// 
    /// Add the creature's DeathItem to the DeathItems formlist.
    /// 
    /// Creature a new CustomDeathItem that contains tokens for the actions supported by the creature.
    /// 
    /// 
    /// ==HUNTERBORN QUEST SCRIPT==
    /// Add the carcass size to its array property.
    /// Add the carcass custom message (if any) to its array property.
    /// Add the CustomDeathItem to its array property.
    /// Add the meat type (if any) to its array property.
    /// Add the meat weight (if any) to its array property.
    /// Add the default pelt value (if any) to its array property.
    /// Add the shared death item (if any) to its array property.
    /// Add the proper name to its array property.
    /// 
    /// For monsters:
    /// Add the venom (if any) to its array property.
    /// Add the blood (if any) to its array property.
    /// Add the "negative treasure" (if any) to its array property.
    /// 
    /// </summary>
    /// 
    static void AddRecord(CreatureData data, StandardRecords std)
    {
        var token = CreateToken(data, std);
        var carcass = CreateCarcass(data, std);
        var mats = CreateMaterials(data, std);
        var pelts = CreatePelts(data, std);
        var deathDescriptor = CreateDeathDescriptor(data, std, pelts, mats);
        if (data.IsMonster) CreateDiscards(data, std);

        std.GetCCFor(data).RaceIndex.Data.Add(data.InternalName);
        std.GetCCFor(data).CarcassMessages.Objects.Add(CreateProperty(data.Prototype.CarcassMessageBox));
        std.GetCCFor(data).CarcassSizes.Data.Add(data.Prototype.CarcassWeight);
        std.GetCCFor(data).MeatType.Objects.Add(CreateProperty(data.Prototype.Meat));
        std.GetCCFor(data).MeatWeights.Data.Add(std.LinkCache.Resolve(data.Prototype.Meat) is IWeightValueGetter w ? w.Weight : 0.0f);
        std.GetCCFor(data).Switches.Objects.Add(CreateProperty(data.Prototype.Toggle));
        std.GetCCFor(data).SharedDeathItems.Objects.Add(CreateProperty(data.Prototype.SharedDeathItems));

        if (data.IsMonster)
        {
            std.Monsters.BloodItems.Objects.Add(CreateProperty(data.Prototype.BloodType));
            std.Monsters.VenomItems.Objects.Add(CreateProperty(data.Prototype.Venom));
        }

        if (_settings.Value.DebuggingMode)
        {
            Console.WriteLine($"\tCreated new forms:");
            Console.WriteLine($"\t\t o ID Token: {token}");
            Console.WriteLine($"\t\t o Carcass item: {carcass}");
            Console.WriteLine($"\t\t o Materials: {mats}");
            Console.WriteLine($"\t\t o Pelts: {pelts}");
            Console.WriteLine($"\t\t o Descriptor: {deathDescriptor}");
            Console.WriteLine($"\t\t o Updated quest script properties.");
        }
    }

    static CreatureData CreateCreatureData(INpcGetter npc, PluginEntry prototype, StandardRecords std)
    {
        npc.DeathItem.TryResolve(std.LinkCache, out var deathItem);
        if (deathItem == null) throw new NoDeathItemException(npc.FormKey);
        //if (MiscItems.Contains(deathItem)) throw new DeathItemAlreadyAddedException(deathItem.FormKey);
        CreatureData data = new(npc, deathItem, CreateInternalName(deathItem), prototype, prototype.Type == EntryType.Animal, prototype.Type == EntryType.Monster);
        return data;
    }

    /// <summary>
    /// Creates a unique internal name for the specified DeathItem. 
    /// This is used to derive the editorIds for the new forms that will be created 
    /// for the specified DeathItem.
    /// </summary>
    /// <param name="deathItem">The DeathItem to create a reasonably unique name for.</param>
    /// <returns>A reasonably unique name.</returns>
    /// 
    static String CreateInternalName(ILeveledItemGetter deathItem)
    {
        String internalName = $"{deathItem.EditorID ?? deathItem.FormKey.ToString()}";
        return NAME_FILTER.Replace(internalName, "");
    }
    readonly static private Regex NAME_FILTER = new("[^a-zA-Z0-9_]", RegexOptions.IgnoreCase);

    /// <summary>
    /// Creates the Misc deathtoken for a creature.
    /// 
    /// The new deathtoken is appended to the deathtoken formlist for animals or monsters.
    /// 
    /// The deathtoken will be derived from the prototype's token (if it exists) or derived from the COW's deathtoken.
    /// 
    /// Naming is done heuristically. 
    /// </summary>
    /// 
    static private MiscItem CreateToken(CreatureData data, StandardRecords std)
    {
        // Get a pre-existing token that already has the keywords and model set.
        // That way all that needs to be done is to change the name and editor ID.
        var existingTokenLink = data.IsAnimal ? DEFAULT_TOKEN_ANIMAL : DEFAULT_TOKEN_MONSTER;
        existingTokenLink.TryResolve(std.LinkCache, out var existingToken);
        if (existingToken == null) throw new CoreRecordMissing(existingTokenLink);

        // Add the token to the patch.
        var token = std.PatchMod.MiscItems.AddNew();
        if (token == null) throw new InvalidOperationException();
        token.DeepCopyIn(existingToken);

        // Set the EditorID.
        token.EditorID = $"_DS_DI{data.InternalName}";
        token.Name = $"{data.InternalName} Token";

        // Put the token in the correct formlist.
        std.GetCCFor(data)._DS_FL_DeathItemTokens.Items.Add(token);

        return token;
    }

    static MiscItem CreateCarcass(CreatureData data, StandardRecords std)
    {
        // Get a pre-existing carcass that already has the keywords set.
        DEFAULT_CARCASS.TryResolve(std.LinkCache, out var existingCarcass);
        if (existingCarcass == null) throw new CoreRecordMissing(DEFAULT_CARCASS);

        // Add the carcass to the patch.
        var carcass = std.PatchMod.MiscItems.AddNew();
        if (carcass == null) throw new InvalidOperationException();
        carcass.DeepCopyIn(existingCarcass);

        var oldName = carcass.Name?.String;
        if (oldName.IsNullOrEmpty()) oldName = "Cow Carcass";

        carcass.EditorID = $"_DS_Carcass{data.InternalName}";
        carcass.Name = oldName.Replace("Cow", $"{data.Prototype.ProperName}");

        carcass.Value = (uint)data.Prototype.CarcassValue;
        carcass.Weight = data.Prototype.CarcassWeight;

        carcass.Model = KnownCarcasses.ContainsKey(data.Prototype)
            ? KnownCarcasses[data.Prototype].Model?.DeepCopy() ?? CreateDefaultCarcassModel()
            : CreateDefaultCarcassModel();

        // Put the carcass in the correct formlist.
        if (data.IsAnimal) std.Animals._DS_FL_CarcassObjects.Items.Add(carcass);

        return carcass;
    }

    static Model CreateDefaultCarcassModel()
    {
        return new Model { File = "Clutter\\Containers\\MiscSackLarge.nif", AlternateTextures = null };
    }

    static FormList CreateMaterials(CreatureData data, StandardRecords std)
    {
        //DEFAULT_MATS.TryResolve(state.LinkCache, out var existingMaterials);
        //if (existingMaterials == null) throw new CoreRecordMissing(DEFAULT_MATS.FormKey);

        var mats = std.PatchMod.FormLists.AddNew();
        if (mats == null) throw new InvalidOperationException();
        //mats.DeepCopyIn(existingMaterials);
        //mats.Items.RemoveAll();
        mats.EditorID = $"_DS_FL_Mats_{data.InternalName}";


        for (int index = 0; index < data.Prototype.Materials.Count; index++)
        {
            var template = data.Prototype.Materials[index];
            var mat = std.PatchMod.LeveledItems.AddNew();
            if (mat == null) throw new InvalidOperationException();

            mat.EditorID = $"{mats.EditorID}{index:D2}";
            var entries = mat.Entries = new();

            foreach (var subTemplate in template) {
                var item = new FormLink<IItemGetter>(subTemplate.Key.FormKey);
                entries.Add(CreateLeveledItemEntry(item, 1, subTemplate.Value));
            }

            mats.Items.Add(mat);
        }

        // Put the materials formlist in the correct formlist.
        std.GetCCFor(data)._DS_FL_Mats__Lists.Items.Add(mats);

        return mats;
    }

    static FormList CreatePelts(CreatureData data, StandardRecords std)
    {
        var pelts = std.PatchMod.FormLists.AddNew();
        if (pelts == null) throw new InvalidOperationException();
        pelts.EditorID = $"_DS_FL_Pelts_{data.InternalName}";

        if (!KnownPelts.ContainsKey(data.Prototype))
        {
            IItemGetter standard = GetDefaultPelt(data, std);
            var poor = std.PatchMod.MiscItems.AddNew();
            var fine = std.PatchMod.MiscItems.AddNew();
            var flawless = std.PatchMod.MiscItems.AddNew();

            poor.DeepCopyIn(standard);
            fine.DeepCopyIn(standard);
            flawless.DeepCopyIn(standard);

            String edid = $"_DS_Pelt_{standard.EditorID ?? data.InternalName}";
            poor.EditorID = $"{edid}_00";
            fine.EditorID = $"{edid}_02";
            flawless.EditorID = $"{edid}_03";

            // Store the pelt value to the Hunterborn quest script.
            std.GetCCFor(data).PeltValues.Data.Add((int) poor.Value);

            // Adjust the values of the non-standard pelts.
            poor.Value /= 2;
            fine.Value *= 2;
            flawless.Value *= 20;
            KnownPelts[data.Prototype] = new IFormLinkGetter<IItemGetter>[4] { poor.ToLink(), standard.ToLink(), fine.ToLink(), flawless.ToLink() };
            //KnownPelts[data.Prototype] = pelts;
        }

        // Add the pelts to the pelts formlist.
        pelts.Items.AddRange(KnownPelts[data.Prototype]);

        // Put the pelts formlist in the correct formlist.
        std.GetCCFor(data)._DS_FL_PeltLists.Items.Add(pelts);
        return pelts;
    }

    static readonly Regex DefaultPeltRegex = new("Pelt|Hide|Skin|Fur|Wool|Leather", RegexOptions.IgnoreCase);

    /// <summary>
    /// Checks the creature's DeathItem for anything whose name or editorID contains a string-match
    /// that indicates it's probably a pelt. Returns the pelt.
    /// 
    /// If no default pelt was found, one will be created and added to the patch.
    /// 
    /// </summary>
    /// 
    static IItemGetter GetDefaultPelt(CreatureData data, StandardRecords std)
    {
        IReadOnlyList<ILeveledItemEntryGetter>? entries = data.DeathItem.Entries;
        if (entries == null) return CreateDefaultPelt(data, std);

        foreach (var entry in entries)
        {
            var item = entry.Data?.Reference.TryResolve(std.LinkCache);
            var edid = item?.EditorID ?? "";
            if (item == null || edid == null) continue;
            if (DefaultPeltRegex.Matches(edid).Any()) return item;
        }

        return CreateDefaultPelt(data, std);
    }

    /// <summary>
    /// Create a new default pelt for a creature using a pre-existing pelt as a template.
    /// 
    /// </summary>
    /// <param name="data"></param>
    /// <param name="std"></param>
    /// <returns></returns>
    /// <exception cref="CoreRecordMissing"></exception>
    /// <exception cref="InvalidOperationException"></exception>
    static IItemGetter CreateDefaultPelt(CreatureData data, StandardRecords std)
    {
        DEFAULT_PELT.TryResolve(std.LinkCache, out var existingPelt);
        if (existingPelt == null) throw new CoreRecordMissing(DEFAULT_PELT);

        var pelt = std.PatchMod.MiscItems.AddNew();
        if (pelt == null) throw new InvalidOperationException();
        pelt.DeepCopyIn(DEFAULT_PELT.Resolve(std.LinkCache));

        pelt.EditorID = $"_DS_Pelt_{data.InternalName}_01";
        pelt.Name = $"{data.Prototype.ProperName} Pelt";

        // @TODO Fill this in with something better.
        pelt.Value = (uint)data.Prototype.CarcassValue / 2;
        return pelt;
    }

    /// <summary>
    /// Create a new discards formlist for a monster.
    /// Dicards are also called "negativetreasure" internally.
    /// </summary>
    /// 
    static void CreateDiscards(CreatureData data, StandardRecords std)
    {
        var discards = std.PatchMod.FormLists.AddNew();
        if (discards == null) throw new InvalidOperationException();
        discards.Items.AddRange(data.Prototype.Discard);
    }

    /// <summary>
    /// Create a new DeathDescriptor for a creature.
    /// This is a LeveledItem that gets added to a carcass's inventory when the
    /// player interacts with the carcass for the first time.
    /// 
    /// The Tokens it adds are what determine which actions the player can take.
    /// 
    /// </summary>
    /// 
    static ILeveledItemGetter CreateDeathDescriptor(CreatureData data, StandardRecords std, FormList pelts, FormList mats)
    {
        // Create the new descriptor.
        LeveledItem deathDescriptor = std.PatchMod.LeveledItems.AddNew();
        deathDescriptor.EditorID = $"_DS_DeathItem_{data.InternalName}";
        deathDescriptor.Entries = new();

        // If the pelts FormList isn't empty, then harvesting pelts is enabled.
        if (pelts.Items != null && pelts.Items.Count > 0)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Pelt, 1, 1));

        // If the materials FormList isn't empty, then harvesting materials is enabled.
        if (mats.Items != null && mats.Items.Count > 0)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Mat, 1, 1));

        // Animals need to be cleaned. Monsters apparently not?
        if (data.IsAnimal)
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Carcass_Clean, 1, 1));

        // If the Meat field in the PluginEntry isn't null then harvesting meat is enabled.
        if (!data.Prototype.Meat.IsNull)
        {
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Meat, 1, 1));
            deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Meat_Fresh, 1, 1));
        }

        // If the Venom or Blood fields in the PluginEntry aren't null then harvesting venom and/or blood is enabled.
        if (data.IsMonster)
        {
            if (!data.Prototype.Venom.IsNull)
                deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Venom, 1, 1));
            if (!data.Prototype.BloodType.IsNull)
                deathDescriptor.Entries.Add(CreateLeveledItemEntry(_DS_Token_Venom, 1, 1));
        }

        // Add the creature's actual DeathItem to the appropriate FormList.
        // When hunterborn starts up, the creature's Token will be added to this formlist.
        // THIS IS HOW HUNTERBORN RECOGNIZES HARVESTABLE CREATURES.
        std.GetCCFor(data)._DS_FL_DeathItems.Items.Add(data.DeathItem);

        // Add the DeathDescriptor to the quest array property.
        std.GetCCFor(data).DeathDescriptors.Objects.Add(new() { Object = deathDescriptor.ToLink() });

        return deathDescriptor;
    }

    /// <summary>
    /// To be recognized as a creature by the patcher, an Npc must not belong to any of these factions.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    readonly static private HashSet<FormLink<IFactionGetter>> ForbiddenFactions = new() {
        Dawnguard.Faction.DLC1VampireFaction,
        Dragonborn.Faction.DLC2AshSpawnFaction,
        Skyrim.Faction.DragonPriestFaction,
        Skyrim.Faction.DraugrFaction,
        Skyrim.Faction.DwarvenAutomatonFaction,
        Skyrim.Faction.IceWraithFaction,
        Dawnguard.Faction.SoulCairnFaction,
        Skyrim.Faction.VampireFaction,
        Skyrim.Faction.WispFaction
    };

    /// <summary>
    /// Voices of creatures. To be recognized as a creature by the patcher, an Npc must have a voiceType from
    /// this list.
    /// 
    /// VoiceTypes from addons will get added to this list at runtime.
    /// Isn't that forward thinking? Why don't the other Forbidden/Allowed lists get
    /// populated from addons?
    /// 
    /// </summary>
    readonly static private HashSet<IFormLinkGetter<IVoiceTypeGetter>> AllowedVoices = new() {
        Skyrim.VoiceType.CrBearVoice,
        Skyrim.VoiceType.CrChickenVoice,
        Skyrim.VoiceType.CrCowVoice,
        Skyrim.VoiceType.CrDeerVoice,
        Skyrim.VoiceType.CrDogVoice,
        Dawnguard.VoiceType.CrDogHusky,
        Skyrim.VoiceType.CrFoxVoice,
        Skyrim.VoiceType.CrGoatVoice,
        Skyrim.VoiceType.CrHareVoice,
        Skyrim.VoiceType.CrHorkerVoice,
        Skyrim.VoiceType.CrHorseVoice,
        Skyrim.VoiceType.CrMammothVoice,
        Skyrim.VoiceType.CrMudcrabVoice,
        Skyrim.VoiceType.CrSabreCatVoice,
        Skyrim.VoiceType.CrSkeeverVoice,
        Skyrim.VoiceType.CrSlaughterfishVoice,
        Skyrim.VoiceType.CrWolfVoice,
        Dragonborn.VoiceType.DLC2CrBristlebackVoice,
        Skyrim.VoiceType.CrChaurusVoice,
        Skyrim.VoiceType.CrFrostbiteSpiderVoice,
        Skyrim.VoiceType.CrFrostbiteSpiderGiantVoice,
        Skyrim.VoiceType.CrSprigganVoice,
        Skyrim.VoiceType.CrTrollVoice,
        Skyrim.VoiceType.CrWerewolfVoice,
        Skyrim.VoiceType.CrDragonVoice,
        Dawnguard.VoiceType.CrChaurusInsectVoice
    };

    /// <summary>
    /// A list of EditorIDs of creatures that should never be processed.
    /// I wish this was explained.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    static readonly private List<String> ForbiddenNpcEditorIds = new() { "HISLCBlackWolf", "BSKEncRat" };

    /// <summary>
    /// A list of DeathItems that should never be processed. 
    /// Creatures with one of these DeathItems should be ignored by Hunterborn and by this patcher.
    /// 
    /// @TODO Addons should be allowed to add to this list.
    /// 
    /// </summary>
    private static readonly List<FormLink<ILeveledItemGetter>> ForbiddenDeathItems = new() {
        Skyrim.LeveledItem.DeathItemDragonBonesOnly,
        Skyrim.LeveledItem.DeathItemVampire,
        Skyrim.LeveledItem.DeathItemForsworn,
        Dawnguard.LeveledItem.DLC1DeathItemDragon06,
        Dawnguard.LeveledItem.DLC1DeathItemDragon07,
        new(new FormKey(new("Skyrim Immersive Creatures Special Edition", type : ModType.Plugin), 0x11B217))
    };

    /*
    static readonly private Dictionary<string, string> SortingNames = new() {
        { "BearCave", "Bear, Cave" },
        { "BearSnow", "Bear, Snow" },
        { "CharusHunter", "Chaurus, Hunter" },
        { "ElkFemale", "Elk, Female" },
        { "ElkMale", "Elk, Male" },
        { "FoxIce", "Fox, Snow" },
        { "MudCrab01", "MudCrab, Small" },
        { "MudCrab02", "MudCrab, Large" },
        { "MudCrab03", "MudCrab, Giant" },
        { "SabrecatSnow", "Sabrecat, Snow" },
        { "FrostbiteSpider", "Spider, Frostbite" },
        { "FrostbiteSpiderGiant", "Spider, Giant Frostbite" },
        { "SprigganBurnt", "Spriggan, Burnt" },
        { "DeerVale", "Deer, Vale" },
        { "SabrecatVale", "Sabrecat, Vale" },
        { "WolfIce", "Wolf, Ice" },
        { "TrollFrost", "Troll, Frost" }
    };

    static private Dictionary<string, string> VanillaToCaco = new Dictionary<string, string>() {
        { "_DS_Food_Raw_Bear", "CACO_FoodMeatBear" },
            { "_DS_Food_Raw_Chaurus", "CACO_FoodMeatChaurusMeat" },
            { "_DS_Food_Raw_Dragon", "_DS_Food_Raw_Dragon" },
            { "_DS_Food_Raw_Elk", "FoodMeatVenison" },
            { "_DS_Food_Raw_Fox", "CACO_FoodMeatFox" },
            { "_DS_Food_Raw_Goat", "CACO_FoodMeatGoatPortionRaw" },
            { "_DS_Food_Raw_Hare", "_DS_Food_Raw_Hare" },
            { "_DS_Food_Raw_Mammoth", "CACO_FoodMeatMammoth" },
            { "_DS_Food_Raw_Mudcrab", "_DS_Food_Raw_Mudcrab" },
            { "_DS_Food_Raw_Sabrecat", "CACO_FoodMeatSabre" },
            { "_DS_Food_Raw_Skeever", "CACO_FoodMeatSkeeverRaw" },
            { "_DS_Food_Raw_Slaughterfish", "CACO_FoodSeaSlaughterfishRaw" },
            { "_DS_Food_Raw_Spider", "_DS_Food_Raw_Spider" },
            { "_DS_Food_Raw_Troll", "CACO_FoodMeatTroll" },
            { "_DS_Food_Raw_Wolf", "FoodDogMeat" },
            { "FoodBeef", "FoodBeef" },
            { "FoodChicken", "FoodChicken" },
            { "FoodClamMeat", "FoodClamMeat" },
            { "FoodDogMeat", "FoodDogMeat" },
            { "FoodGoatMeat", "FoodGoatMeat" },
            { "FoodHorkerMeat", "FoodHorkerMeat" },
            { "FoodHorseMeat", "FoodHorseMeat" },
            { "FoodMammothMeat", "FoodMammothMeat" },
            { "FoodPheasant", "FoodPheasant" },
            { "FoodRabbit", "FoodRabbit" },
            { "FoodSalmon", "FoodSalmon" },
            { "FoodVenison", "FoodVenison" },
            { "DLC2FoodAshHopperMeat", "DLC2FoodAshHopperMeat" },
            { "DLC2FoodAshHopperLeg", "DLC2FoodAshHopperLeg" },
            { "DLC2FoodBoarMeat", "DLC2FoodBoarMeat" },
            { "HumanFlesh", "CACO_FoodMeatHumanoidFlesh" }
    };
    */

    /*
    */

    static private bool IsCreature(INpcGetter actor) {
        var deathItem = actor.DeathItem;
        var edid = actor.EditorID;

        //var edidLink = edid != null ? new EDIDLink<IRaceGetter>(edid) : null;

        if (edid != null && HasForbiddenEditorId(edid)) return false;
        else if (deathItem == null) return false;
        else if (HasForbiddenFaction(actor)) return false;
        else if (HasForbiddenDeathItem(deathItem)) return false;
        else if (!HasAllowedVoice(actor)) return false;
        //else if (!KnownDeathItems.Contains(deathItem)) return false;
        else return true;
    }

    static private bool HasForbiddenEditorId(String editorId) => ForbiddenNpcEditorIds.Any(edid => edid.EqualsIgnoreCase(editorId));

    static private bool HasForbiddenFaction(INpcGetter creature) =>
        creature.Factions.Where(placement => ForbiddenFactions.Contains(placement.Faction)).Any();

    static private bool HasAllowedVoice(INpcGetter creature) => AllowedVoices.Contains(creature.Voice);

    static private bool HasForbiddenDeathItem(IFormLinkGetter<ILeveledItemGetter> deathItem) => ForbiddenDeathItems.Contains(deathItem);

    /// <summary>
    /// The quest and formlists needed by the patching methods, resolved and ready.
    /// </summary>
    readonly record struct StandardRecords(
        Quest _DS_Hunterborn,
        ILinkCache<ISkyrimMod, ISkyrimModGetter> LinkCache,
        ISkyrimMod PatchMod,
        AnimalClass Animals,
        MonsterClass Monsters,
        List<CreatureClass> CreatureClasses)
    {

        /// <summary>
        /// Retrieves the CreatureClass for a specified CreatureData.
        /// </summary>
        /// <param name="d">The CreatureData whose CreatureClass should be returned.</param>
        /// <returns>The CreatureClass.</returns>
        public CreatureClass GetCCFor(CreatureData d) => GetCCFor(d.Prototype.Type);

        /// <summary>
        /// Retrieves the CreatureClass for a specified EntryType.
        /// </summary>
        /// <param name="d">The EntryType whose CreatureClass should be returned.</param>
        /// <returns>The CreatureClass.</returns>
        public CreatureClass GetCCFor(EntryType t) => t switch
        {
            EntryType.Animal => Animals,
            EntryType.Monster => Monsters,
            _ => throw new InvalidOperationException("Unknown CreatureClass requested."),
        };
    }

    /// <summary>
    /// FormLists and script properties needed for patching creatures.
    /// </summary>
    record CreatureClass(
        //List<ILeveledItemGetter> KnownDeathItems,
        FormList _DS_FL_Mats__Lists,
        FormList _DS_FL_Mats__Perfect,
        FormList _DS_FL_PeltLists,
        FormList _DS_FL_DeathItems,
        FormList _DS_FL_DeathItemTokens,
        ScriptObjectListProperty CarcassMessages,
        ScriptObjectListProperty Switches,
        ScriptObjectListProperty DeathDescriptors,
        ScriptObjectListProperty MeatType,
        ScriptObjectListProperty SharedDeathItems,
        ScriptStringListProperty RaceIndex,
        ScriptFloatListProperty MeatWeights,
        ScriptIntListProperty PeltValues,
        ScriptIntListProperty CarcassSizes
        );

    /// <summary>
    /// FormLists and script properties needed for patching Animals,
    /// which is just the FormList of carcasses.
    /// </summary>
    record AnimalClass(
        CreatureClass proto,
        FormList _DS_FL_CarcassObjects) : CreatureClass(proto);

    /// <summary>
    /// FormLists and script properties needed for patching Monsters,
    /// which includes blood, venom, and discards.
    /// </summary>
    record MonsterClass(
        CreatureClass proto, 
        ScriptObjectListProperty BloodItems, 
        ScriptObjectListProperty VenomItems, 
        ScriptObjectListProperty Discards) : CreatureClass(proto);


    /// <summary>
    /// Some of the methods in this class require the resolved Hunterborn Quest and resolved FormLists.
    /// This resolves them, adds them to the patch, and packs them into a Record.
    /// </summary>
    static StandardRecords CreateStandardRecords(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        Quest hunterbornQuest = state.PatchMod.Quests.GetOrAddAsOverride(_DS_Hunterborn.Resolve(state.LinkCache));
        //if (_settings.Value.DebuggingMode) QueryImportantProperties(hunterbornQuest);

        var animals = new AnimalClass(new(
                    //new(GetKnownDeathItemsAnimals(state.LinkCache)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Lists.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Lists)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Perfect.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Perfect)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_PeltLists.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_PeltLists)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItems.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItems)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItemTokens.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItemTokens)),

                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_MAIN", "FreshCarcassMsgBoxes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "ActiveAnimalSwitches"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "DeathItemLI"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "MeatTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Animals", "SharedDeathItems"),
                    GetProperty<ScriptStringListProperty>(hunterbornQuest, "_DS_HB_Animals", "AnimalIndex"),
                    GetProperty<ScriptFloatListProperty>(hunterbornQuest, "_DS_HB_Animals", "AllMeatWeights"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Animals", "DefaultPeltValues"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Animals", "CarcassSizes")),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_CarcassObjects.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_CarcassObjects)));

        var monsters = new MonsterClass(new(
                    //new(GetKnownDeathItemsMonsters(state.LinkCache)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Lists_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Lists_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_Mats__Perfect_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_Mats__Perfect_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_PeltLists_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_PeltLists_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItems_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItems_Monsters)),
                    state.PatchMod.FormLists.GetOrAddAsOverride(_DS_FL_DeathItemTokens_Monsters.Resolve(state.LinkCache) ?? throw new CoreRecordMissing(_DS_FL_DeathItemTokens_Monsters)),

                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_MAIN", "FreshCarcassMsgBoxes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "ActiveMonsterSwitches"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "DeathItemLI"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "MeatTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "SharedDeathItems"),
                    GetProperty<ScriptStringListProperty>(hunterbornQuest, "_DS_HB_Monsters", "MonsterIndex"),
                    GetProperty<ScriptFloatListProperty>(hunterbornQuest, "_DS_HB_Animals", "AllMeatWeights"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Monsters", "DefaultPeltValues"),
                    GetProperty<ScriptIntListProperty>(hunterbornQuest, "_DS_HB_Monsters", "CarcassSizes")),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "BloodTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "VenomTypes"),
                    GetProperty<ScriptObjectListProperty>(hunterbornQuest, "_DS_HB_Monsters", "NegativeTreasure"));


        StandardRecords std = new(
                hunterbornQuest,
                state.LinkCache,
                state.PatchMod,
                animals,
                monsters,
                new() { animals, monsters }
                );

        return std;
    }
    
    static void QueryImportantProperties(Quest hunterbornQuest)
    {
        hunterbornQuest.VirtualMachineAdapter?.Scripts.ForEach(script => {
            script.Properties
                .Where(p => p is ScriptObjectListProperty)
                .Select(p => (p as ScriptObjectListProperty)!)
                .Where(p => p.Objects.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant object array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptBoolListProperty)
                .Select(p => (p as ScriptBoolListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant bool array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptIntListProperty)
                .Select(p => (p as ScriptIntListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant int array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptFloatListProperty)
                .Select(p => (p as ScriptFloatListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant float array property: {script.Name}.{p.Name}"));

            script.Properties
                .Where(p => p is ScriptStringListProperty)
                .Select(p => (p as ScriptStringListProperty)!)
                .Where(p => p.Data.Count >= 10)
                .ForEach(p => Console.WriteLine($"\tRelevant string array property: {script.Name}.{p.Name}"));
        });
    }

    static ScriptTProperty GetProperty<ScriptTProperty>(Quest quest, String scriptName, String propertyName) where ScriptTProperty : ScriptProperty
    {
        String questName = quest.Name?.ToString() ?? quest.EditorID ?? "Quest";

        var scriptFilter = ScriptFilter(scriptName);
        var propertyFilter = PropertyFilter(propertyName);

        var script = quest.VirtualMachineAdapter?.Scripts.Where(scriptFilter).FirstOrDefault();
        if (script == null) throw new ScriptMissing(questName, scriptName);

        if (script.Properties.Where(propertyFilter).FirstOrDefault() is not ScriptTProperty property) 
            throw new PropertyMissing(questName, scriptName, propertyName);

        return property;
    }

    /// <summary>
    /// A predicate for matching scripts by name.
    /// </summary>
    /// <param name="name">The name to match.</param>
    /// <returns>A predicate that matches the specified name.</returns>
    /// 
    static Func<ScriptEntry, bool> ScriptFilter(String name) => (ScriptEntry s) => name.EqualsIgnoreCase(s?.Name);

    /// <summary>
    /// A predicate for matching script properties by name.
    /// </summary>
    /// <param name="name">The name to match.</param>
    /// <returns>A predicate that matches the specified name.</returns>
    /// 
    static Func<ScriptProperty, bool> PropertyFilter(String name) => (ScriptProperty s) => name.EqualsIgnoreCase(s?.Name);

    /// <summary>
    /// Convenience method for creating new LeveledItemEntry.
    /// No extra data is added.
    /// </summary>
    /// <param name="item">The item.</param>
    /// <param name="level">The player level.</param>
    /// <param name="count">The item count.</param>
    /// <returns></returns>
    static LeveledItemEntry CreateLeveledItemEntry(IFormLink<IItemGetter> item, int level, int count) =>
        new() { Data = new LeveledItemEntryData { Reference = item, Level = (short)level, Count = (short)count }};

    /// <summary>
    /// Convenience method for creating new ScriptObjectProperty wrapping a FormLink.
    /// It has to turn the Getter into a Setter internally.
    /// </summary>
    /// <param name="item">The FormLinkGetter.</param>
    /// <returns>The ScriptObjectProperty.</returns>
    static ScriptObjectProperty CreateProperty<T>(IFormLinkGetter<T> item) where T : class, ISkyrimMajorRecordGetter
    {
        var link = item.FormKey.ToLink<ISkyrimMajorRecordGetter>();
        return new() { Object = link };
    }

    /*
    readonly static private Dictionary<string, string> NameSubstitutions = new() {
        { "BearCave", "Bear, Cave" },
        { "BearSnow", "Bear, Snow" },
        { "CharusHunter", "Chaurus, Hunter"  },
        { "ElkFemale", "Elk, Female"  },
        { "ElkMale", "Elk, Male"  },
        { "FoxIce", "Fox, Snow"  },
        { "MudCrab01", "MudCrab, Small" },
        { "MudCrab02", "MudCrab, Large" },
        { "MudCrab03", "MudCrab, Giant" },
        { "SabrecatSnow", "Sabrecat, Snow" },
        { "FrostbiteSpider", "Spider, Frostbite" },
        { "FrostbiteSpiderGiant", "Spider, Giant Frostbite" },
        { "SprigganBurnt", "Spriggan, Burnt" },
        { "DeerVale", "Deer, Vale" },
        { "SabrecatVale", "Sabrecat, Vale" },
        { "WolfIce", "Wolf, Ice" },
        { "TrollFrost", "Troll, Frost" }
    };*/

    /*
    readonly static private List<String> DeathItemNameMatches = new(new String[] {
        "Werebear",
        "Bear",
        "BearCave",
        "BearSnow",
        "Bristleback",
        "Chaurus",
        "CharusHunter",
        "Chicken",
        "Cow",
        "DeerVale",
        "Deer",
        "Dog",
        "Dragon",
        "ElkFemale",
        "ElkMale",
        "FoxIce",
        "Fox",
        "FrostbiteSpiderGiant",
        "FrostbiteSpider",
        "Goat",
        "Hare",
        "Horker",
        "Horse",
        "Mammoth",
        "MudCrab01",
        "MudCrab02",
        "MudCrab03",
        "SabrecatSnow",
        "SabrecatVale",
        "Sabrecat",
        "Skeever",
        "Slaughterfish",
        "Spriggan",
        "SprigganBurnt",
        "TrollFrost",
        "Troll",
        "Werewolf",
        "WolfIce",
        "Wolf"
    });*/


    /// <summary>
    /// For printing dividers in the console output.
    /// </summary>
    static private readonly string Divider = "====================================================";

    /// <summary>
    /// For printing titled-dividers in the console output.
    /// </summary>
    static String CreateTitle(String title)
    {
        int dividerLength = Divider.Length;
        int titleLength = title.Length;
        int leftLength = (dividerLength - titleLength) / 2;
        int rightLength = (dividerLength - titleLength + 1) / 2;
        String left = Divider.Substring(0, leftLength);
        String right = Divider.Substring(0, rightLength);
        return $"{left}{title}{right}";
    }

    /// <summary>
    /// Scans a plugin for all records of a given type and outputs named FormLink definitions for them.
    /// 
    /// They take the general form:
    /// static readonly public ModKey MY_MOD = new ModKey(FILENAME, ModType.Plugin);
    /// static readonly public FormLink<IMiscItemGetter> EDITORID = new (new FormKey(MY_MOD, 0x000000));
    /// 
    /// </summary>
    /// <typeparam name="T">The type of record to scan and make FormLink definitions for.</typeparam>
    /// <param name="filename">The name of the mod to scan.</param>
    /// <param name="state">The patcher state.</param>
    /// 
    public static void PrintFormKeysDefinitions<T>(String filename, IPatcherState<ISkyrimMod, ISkyrimModGetter> state) where T : IMajorRecordGetter
    {
        state.LoadOrder.TryGetIfEnabledAndExists(new ModKey(filename, ModType.Plugin), out var mod);
        var group = mod?.GetTopLevelGroup<T>();
        if (mod == null || group == null || group.Count == 0) return;

        String modname = $"{Regex.Replace(filename.ToUpper(), "[^a-zA-Z0-9_]", "")}";
        String typeName = typeof(T).FullName ?? "TYPENAME";

        System.Console.WriteLine($"static readonly public ModKey {modname} = new ModKey(\"{filename}\"), ModType.Plugin);");

        group.Where(rec => rec.EditorID != null).ForEach(rec => {
            var edid = rec.EditorID;
            var formID = rec.FormKey.ID.ToString("x");
            Console.WriteLine($"static readonly public FormLink<I{typeName}Getter> {edid} = new (new FormKey({modname}, 0x{formID}));");
        });

    }

    /// <summary>
    /// Thrown to indicate that an Npc has no DeathItem and therefore can't be processed by Hunterborn.
    /// @TODO Create a PO3-enhanced Taxonomy spell that can add DeathItems to creatures.
    /// </summary>
    sealed class NoDeathItemException : Exception
    {
        public NoDeathItemException(FormKey form) : base($"No DeathItem: {form}") { }
    }

    /// <summary>
    /// Thrown to indicate that an Npc's DeathItem has already been processed. 
    /// </summary>
    sealed class DeathItemAlreadyAddedException : Exception
    {
        public DeathItemAlreadyAddedException(FormKey form) : base($"DeathItem already processed: {form}") { }
    }

    /// <summary>
    /// Thrown to indicate that one of the forms in Hunterborn.esp couldn't be loaded.
    /// If this happens then something is terribly wrong with Hunterborn.esp.
    /// </summary>
    sealed class CoreRecordMissing : Exception
    {
        public CoreRecordMissing(IFormLinkGetter<ISkyrimMajorRecordGetter> form) : base($"Missing core record: {form} from Hunterborn.esp.") {
        }
    }

    /// <summary>
    /// Thrown to indicate that one of the scripts in the main Hunterborn quest couldn't be found.
    /// If this happens then something is terribly wrong with Hunterborn.esp.
    /// </summary>
    sealed class ScriptMissing : Exception    {
        public ScriptMissing(String questname, String scriptName) : base($"Missing script: {questname}.{scriptName}") { }
    }

    /// <summary>
    /// Thrown to indicate that one of the properties on one of the scripts in the main Hunterborn quest couldn't be found.
    /// If this happens then something is terribly wrong with Hunterborn.esp.
    /// </summary>
    sealed class PropertyMissing : Exception
    {
        public PropertyMissing(String questname, String scriptName, String propertyName) : base($"Missing property: {questname}.{scriptName}.{propertyName}") { }
    }

}

/// <summary>
/// Adds an EqualsIgnoreCase method to String.
/// </summary>
public static class StringEqualsIgnoreCase
{
    /// <summary>
    /// Equivalent to s1.ToLower().Equals(s2.ToLower()) with identity and null checking.
    /// </summary>
    public static bool EqualsIgnoreCase(this String s1, String? s2)
    {
        if (s1 == s2) return true;
        else if (s1 == null || s2 == null) return false;
        else return s1.ToLower().Equals(s2.ToLower());
    }

}

/// <summary>
/// Adds pretty-printing methods to lists, arrays, dictionaries, and lists of dictionaries.
/// </summary>
public static class GenericPrettyPrinting
{
    public static string Pretty<T>(this T[] array) where T : notnull => "[" + string.Join(", ", array) + "]";

    public static string Pretty<T>(this List<T> list) where T : notnull => "[" + string.Join(", ", list) + "]";

    public static string Pretty<S, T>(this Dictionary<S, T> dict) where S : notnull => "{" + string.Join(", ", dict) + "}";

    public static string Pretty<S, T>(this List<Dictionary<S, T>> listOfDicts) where S : notnull => "[" + string.Join(", ", listOfDicts.Select(l => l.PPrint())) + "]";

}

